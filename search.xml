<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java memory allocation</title>
      <link href="/java-memory-allocation/"/>
      <url>/java-memory-allocation/</url>
      
        <content type="html"><![CDATA[<p>逃逸分析</p><p>标量替换</p><p>TLAB</p><p>指针碰撞</p><p>空闲列表</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/12%20%20%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%20jemalloc%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md">他山之石：高性能内存分配器 jemalloc 基本原理</a></li></ol><p>聊聊jvm中的标量替换   <a href="https://juejin.cn/post/6877004782130151438">https://juejin.cn/post/6877004782130151438</a></p><p>【【Java面试】说说对象的内存分配流程】<a href="https://www.bilibili.com/video/BV1114y1r7V3?vd_source=d5ca709fc65e24989c7d73f89369b6a5">https://www.bilibili.com/video/BV1114y1r7V3?vd_source=d5ca709fc65e24989c7d73f89369b6a5</a></p><p>TLAB  <a href="https://blog.csdn.net/fclwd/article/details/114080986">https://blog.csdn.net/fclwd/article/details/114080986</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/db-design/"/>
      <url>/db-design/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.youtube.com/playlist?list=PLSE8ODhjZXjasmrEd2_Yi1deeE360zv5O">https://www.youtube.com/playlist?list=PLSE8ODhjZXjasmrEd2_Yi1deeE360zv5O</a></p><p><a href="https://www.luozhiyun.com/archives/273">https://www.luozhiyun.com/archives/273</a></p><p><a href="https://www.luozhiyun.com/archives/280">https://www.luozhiyun.com/archives/280</a></p><p>CMU 15721 课程笔记  <a href="https://www.zhihu.com/column/c_1624789464953364480">https://www.zhihu.com/column/c_1624789464953364480</a></p><p>PAX：一个 Cache 友好高效的行列混存方案    <a href="https://blog.csdn.net/weixin_42241611/article/details/130050128">https://blog.csdn.net/weixin_42241611/article/details/130050128</a></p><p><a href="https://zhuanlan.zhihu.com/p/158622349">Latch-crabbing/Latch-couping</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSM-Tree</title>
      <link href="/lsm/"/>
      <url>/lsm/</url>
      
        <content type="html"><![CDATA[<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>适合写多读少</p><ol><li>日志系统</li><li>推荐系统</li><li>海量数据存储</li><li>数据分析</li></ol><h2 id="三大问题"><a href="#三大问题" class="headerlink" title="三大问题"></a>三大问题</h2><h3 id="读放大"><a href="#读放大" class="headerlink" title="读放大"></a>读放大</h3><p>读操作需要从新值到旧值依次读取, 在此过程中会涉及不止依次IO。尤其是范围查询时, 导致影响很明显 </p><h3 id="空间放大"><a href="#空间放大" class="headerlink" title="空间放大"></a>空间放大</h3><p>LSM通过append方式在末尾追击记录, 过期或者删除的数据不会立即清理, 所以会导致空间放大。</p><p>就是指存储引擎中的数据实际占用的磁盘空间比数据的真正大小偏多的情况。例如，数据的真正大小是10MB，但实际存储时耗掉了25MB空间，那么空间放大因子（space amplification factor）就是2.5</p><p>为什么会出现空间放大呢？很显然，LSM-based存储引擎中数据的增删改都不是in-place的，而是需要等待compaction执行到对应的key才算完。也就是说，一个key可能会同时对应多个value（删除标记算作特殊的value），而只有一个value是真正有效的，其余那些就算做空间放大。另外，在compaction过程中，原始数据在执行完成之前是不能删除的（防止出现意外无法恢复），所以同一份被compaction的数据最多可能膨胀成原来的两倍，这也算作空间放大的范畴。</p><h3 id="写放大"><a href="#写放大" class="headerlink" title="写放大"></a>写放大</h3><p>为了减少读放大和空间放大, 会进行压缩合并。压缩合并的过程中对一条数据会涉及多次写, 导致写放大。</p><h2 id="Tiering"><a href="#Tiering" class="headerlink" title="Tiering"></a>Tiering</h2><p>写优化, 空间放大。Cassandra。</p><h2 id="leveling"><a href="#leveling" class="headerlink" title="leveling"></a>leveling</h2><p>读优化, 写放大。RocksDB。</p><h2 id="Monkey-Optimal-Navigable-Key-Value-Store"><a href="#Monkey-Optimal-Navigable-Key-Value-Store" class="headerlink" title="Monkey: Optimal Navigable Key-Value Store"></a>Monkey: Optimal Navigable Key-Value Store</h2><p>调整布隆过滤器的容错率</p><h2 id="Dostoevsky"><a href="#Dostoevsky" class="headerlink" title="Dostoevsky"></a>Dostoevsky</h2><h3 id="Lazy-Leveling"><a href="#Lazy-Leveling" class="headerlink" title="Lazy Leveling"></a>Lazy Leveling</h3><p>写优化、点查优化。原理非常简单，也就是混合了 Tiered 以及 Leveled，在最大层使用 Leveled，而其它层使用 Tiered。</p><h3 id="Fluid-LSM-Tree"><a href="#Fluid-LSM-Tree" class="headerlink" title="Fluid LSM-Tree"></a>Fluid LSM-Tree</h3><p>Fluid 使用了一个可调解的方式，在最大层使用最多 Z runs，而其它层最多使用 K runs。</p><p>可以发现：</p><ol><li>Z = 1， K = 1，就是 Leveled Compaction</li><li>Z = T - 1， K = T - 1，就是 Tiered Compaction</li><li>Z = 1， K = T - 1，就是 Lazy Leveling</li></ol><h2 id="Wacky"><a href="#Wacky" class="headerlink" title="Wacky"></a>Wacky</h2><p>适合大量写入、点读。缺点是范围读</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="lsm-hash"><a href="#lsm-hash" class="headerlink" title="lsm hash"></a>lsm hash</h3><h4 id="bitcask-riak"><a href="#bitcask-riak" class="headerlink" title="bitcask(riak)"></a>bitcask(riak)</h4><h4 id="rosedb"><a href="#rosedb" class="headerlink" title="rosedb"></a>rosedb</h4><h4 id="nutsdb"><a href="#nutsdb" class="headerlink" title="nutsdb"></a>nutsdb</h4><h3 id="lsm-array"><a href="#lsm-array" class="headerlink" title="lsm array"></a>lsm array</h3><h4 id="moss"><a href="#moss" class="headerlink" title="moss"></a>moss</h4><h3 id="lsm-tree"><a href="#lsm-tree" class="headerlink" title="lsm tree"></a>lsm tree</h3><h4 id="pebble"><a href="#pebble" class="headerlink" title="pebble"></a>pebble</h4><h4 id="leveldb"><a href="#leveldb" class="headerlink" title="leveldb"></a>leveldb</h4><h4 id="rocksdb"><a href="#rocksdb" class="headerlink" title="rocksdb"></a>rocksdb</h4><h5 id="TTL实现"><a href="#TTL实现" class="headerlink" title="TTL实现"></a>TTL实现</h5><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><h5 id="TTL实现-1"><a href="#TTL实现-1" class="headerlink" title="TTL实现"></a>TTL实现</h5><h3 id="BigTable"><a href="#BigTable" class="headerlink" title="BigTable"></a>BigTable</h3><h3 id="DynamoDB"><a href="#DynamoDB" class="headerlink" title="DynamoDB"></a>DynamoDB</h3><h3 id="cassandra"><a href="#cassandra" class="headerlink" title="cassandra"></a>cassandra</h3><h5 id="TTL实现-2"><a href="#TTL实现-2" class="headerlink" title="TTL实现"></a>TTL实现</h5><h3 id="accumulo"><a href="#accumulo" class="headerlink" title="accumulo"></a>accumulo</h3><h3 id="couchbase"><a href="#couchbase" class="headerlink" title="couchbase"></a>couchbase</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/baichoufei90/article/details/84841289">论文阅读-The Log-Structured Merge-Tree (LSM-Tree)</a></li><li><a href="https://www.dazhuanlan.com/mongolzhang/topics/1102894">Monkey: Optimal Navigable Key-Value Store (中文翻译)</a></li><li><a href="https://www.jianshu.com/p/8fb8f2458253">Dostoevsky: 一种更好的平衡 LSM 空间和性能的方式</a></li><li><a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">Log-structured merge-tree</a></li><li><a href="https://www.scylladb.com/2018/01/17/compaction-series-space-amplification/">Scylla’s Compaction Strategies Series: Space Amplification in Size-Tiered Compaction</a></li><li><a href="https://blog.csdn.net/nazeniwaresakini/article/details/104220140">LSM Tree-Based存储引擎的compaction策略（feat. RocksDB）</a></li><li><a href="https://cloud.tencent.com/developer/article/1399365">深入 LevelDB 数据文件 SSTable 的结构</a></li><li><a href="https://zhuanlan.zhihu.com/p/141186118">深入探讨LSM Compaction机制</a></li><li><a href="https://www.toberoot.com/news/2020/12/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFLSM-Tree/">深入理解什么是LSM-Tree</a></li><li><a href="https://niceaz.com/2018/11/27/sstable">SSTable 原理</a></li><li><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">Log Structured Merge Trees</a></li><li><a href="https://nan01ab.github.io/2019/06/LSM-Bush.html">The Log-Structured Merge-Bush &amp; the Wacky Continuum 中文</a></li><li><a href="https://zhuanlan.zhihu.com/p/380013595">REMIX: Efficient Range Query for LSM-trees</a></li></ol><p><a href="https://blog.csdn.net/weixin_32496547/article/details/114098111">https://blog.csdn.net/weixin_32496547/article/details/114098111</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&amp;rep=rep1&amp;type=pdf</a></p><p><a href="http://blog.fatedier.com/2016/06/15/learn-lsm-tree/">http://blog.fatedier.com/2016/06/15/learn-lsm-tree/</a></p><p><a href="http://www.blogjava.net/DLevin/archive/2015/09/25/427481.html">http://www.blogjava.net/DLevin/archive/2015/09/25/427481.html</a></p><p><a href="https://izualzhy.cn/leveldb-sstable">https://izualzhy.cn/leveldb-sstable</a></p><p><a href="https://www.cnblogs.com/fxjwind/archive/2012/08/14/2638371.html">https://www.cnblogs.com/fxjwind/archive/2012/08/14/2638371.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/103968892">https://zhuanlan.zhihu.com/p/103968892</a></p><p><a href="https://zhuanlan.zhihu.com/p/103855686">https://zhuanlan.zhihu.com/p/103855686</a></p><p><a href="https://xiaozhuanlan.com/topic/7130689425">WiscKey —— SSD 介质下的 LSM-tree 优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/181498475">https://zhuanlan.zhihu.com/p/181498475</a></p><p><a href="https://rocksdb.org.cn/doc/Leveled-Compaction.html">https://rocksdb.org.cn/doc/Leveled-Compaction.html</a></p><p><a href="https://rocksdb.org.cn/doc/Universal-Compaction.html">https://rocksdb.org.cn/doc/Universal-Compaction.html</a></p><p><a href="https://www.open-open.com/lib/view/open1424916275249.html">https://www.open-open.com/lib/view/open1424916275249.html</a></p><p><a href="http://www.petermao.com/leveldb/leveldb-0-start.html">http://www.petermao.com/leveldb/leveldb-0-start.html</a></p><p><a href="https://github.com/google/leveldb/blob/master/doc/impl.md">https://github.com/google/leveldb/blob/master/doc/impl.md</a></p><p><a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html</a></p><p><a href="http://www.petermao.com/leveldb/leveldb-1-overview.html">http://www.petermao.com/leveldb/leveldb-1-overview.html</a></p><p><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">http://www.benstopford.com/2015/02/14/log-structured-merge-trees/</a></p><p><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">http://www.benstopford.com/2015/02/14/log-structured-merge-trees/</a></p><p><a href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">https://github.com/facebook/rocksdb/wiki/Leveled-Compaction</a></p><p><a href="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/">https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/</a></p><p><a href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/">https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/</a></p><p><a href="http://daslab.seas.harvard.edu/classes/cs265/project.html">http://daslab.seas.harvard.edu/classes/cs265/project.html</a></p><p><a href="http://www.youtube.com/watch?v=b6SI8VbcT4w">http://www.youtube.com/watch?v=b6SI8VbcT4w</a></p><p><a href="http://www.youtube.com/watch?v=ttebJcN5bgQ">http://www.youtube.com/watch?v=ttebJcN5bgQ</a></p><p><a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/05/Scaling-Write-Intensive-Key-Value-Stores-slides.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2019/05/Scaling-Write-Intensive-Key-Value-Stores-slides.pdf</a></p><p><a href="https://speakerdeck.com/mschoch/value-store-in-go?slide=3">https://speakerdeck.com/mschoch/value-store-in-go?slide=3</a></p><p><a href="https://izualzhy.cn/leveldb-table">https://izualzhy.cn/leveldb-table</a></p><p><a href="https://izualzhy.cn/leveldb-sstable">https://izualzhy.cn/leveldb-sstable</a></p><p><a href="https://scholar.harvard.edu/files/stratos/files/dostoevskykv.pdf">https://scholar.harvard.edu/files/stratos/files/dostoevskykv.pdf</a></p><p><a href="https://www.jianshu.com/p/8fb8f2458253">https://www.jianshu.com/p/8fb8f2458253</a></p><p><a href="https://github.com/elithnever/paperreading/blob/master/lsm-tree-1.md">https://github.com/elithnever/paperreading/blob/master/lsm-tree-1.md</a></p><p><a href="https://github.com/elithnever/paperreading/blob/master/lsm-tree-2.md">https://github.com/elithnever/paperreading/blob/master/lsm-tree-2.md</a></p><p><a href="https://github.com/elithnever/paperreading/blob/master/lsm-tree-3.md">https://github.com/elithnever/paperreading/blob/master/lsm-tree-3.md</a></p><p><a href="https://www.jianshu.com/p/3fb899684392">https://www.jianshu.com/p/3fb899684392</a></p><p><a href="https://www.youtube.com/watch?v=oUNjDHYFES8">LSM trees (Log Structured Merge Trees) - Detailed video, 印度口音, 而且没字幕</a></p><p><a href="https://www.youtube.com/watch?v=ttebJcN5bgQ">GopherCon 2017: Marty Schoch - Building a High-Performance Key/Value Store in Go</a></p><p><a href="https://zhuanlan.zhihu.com/p/80523835">https://zhuanlan.zhihu.com/p/80523835</a></p><p><a href="https://www.iteblog.com/archives/2548.html">Apache Cassandra SSTable 存储格式详解</a></p><p><a href="https://blog.csdn.net/qq_21125183/article/details/103915326">https://blog.csdn.net/qq_21125183/article/details/103915326</a></p><p><a href="https://blog.csdn.net/SweeNeil/article/details/86482781">https://blog.csdn.net/SweeNeil/article/details/86482781</a></p><p><a href="https://www.cnblogs.com/qwj-sysu/p/5640256.html">https://www.cnblogs.com/qwj-sysu/p/5640256.html</a></p><p><a href="https://daemondshu.github.io/2019/03/21/Programming/Data%20Structure/LevelDB_RocksDB/">https://daemondshu.github.io/2019/03/21/Programming/Data%20Structure/LevelDB_RocksDB/</a></p><p><a href="https://www.shuzhiduo.com/A/amd0LMe1dg/">https://www.shuzhiduo.com/A/amd0LMe1dg/</a></p><p><a href="https://blog.csdn.net/zxpoiu/article/details/116190330">https://blog.csdn.net/zxpoiu/article/details/116190330</a></p><p><a href="https://zhuanlan.zhihu.com/p/65557081">https://zhuanlan.zhihu.com/p/65557081</a></p><p><a href="https://yetanotherdevblog.com/lsm/">https://yetanotherdevblog.com/lsm/</a></p><p><a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf">https://www.cs.umb.edu/~poneil/lsmtree.pdf</a></p><p><a href="https://tikv.org/deep-dive/key-value-engine/b-tree-vs-lsm/">https://tikv.org/deep-dive/key-value-engine/b-tree-vs-lsm/</a></p><p><a href="https://www.usenix.org/conference/atc15/technical-session/presentation/wu">https://www.usenix.org/conference/atc15/technical-session/presentation/wu</a></p><p><a href="https://zhuanlan.zhihu.com/p/129355502">https://zhuanlan.zhihu.com/p/129355502</a></p><p><a href="https://www.youtube.com/watch?v=auI8BTws-f8">https://www.youtube.com/watch?v=auI8BTws-f8</a></p><p><a href="https://www.youtube.com/watch?v=_cGtupq0Ts4https://www.youtube.com/watch?v=_cGtupq0Ts4">https://www.youtube.com/watch?v=_cGtupq0Ts4https://www.youtube.com/watch?v=_cGtupq0Ts4</a></p><p><a href="https://www.youtube.com/watch?v=rnZmdmlR-2M">https://www.youtube.com/watch?v=rnZmdmlR-2M</a></p><p><a href="https://www.bilibili.com/video/BV16X4y1A7TV">https://www.bilibili.com/video/BV16X4y1A7TV</a></p><p><a href="https://arxiv.org/pdf/1812.07527.pdf">https://arxiv.org/pdf/1812.07527.pdf</a></p><ol><li><a href="https://hardcore.feishu.cn/docs/doccnKTUS5I0qkqYMg4mhfIVpOd#">LSM-论文导读与Leveldb源码解读</a></li><li><a href="https://riak.com/assets/bitcask-intro.pdf">Bitcask: A Log-Structured Hash Table for Fast Key/Value Data</a></li><li><a href="https://old-panda.com/2020/08/23/bitcask/">Bitcask 学习笔记</a></li></ol><p><a href="https://pingcap.com/blog-cn/titan-design-and-implementation">https://pingcap.com/blog-cn/titan-design-and-implementation</a></p><p><a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf">https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf</a></p><ol><li><a href="https://cloud.tencent.com/developer/article/1441835">深入理解什么是LSM-Tree</a></li></ol><p><a href="https://www.jianshu.com/p/8fb8f2458253">https://www.jianshu.com/p/8fb8f2458253</a></p>]]></content>
      
      
      <categories>
          
          <category> data-structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> data-structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 调度器</title>
      <link href="/golang-scheduler/"/>
      <url>/golang-scheduler/</url>
      
        <content type="html"><![CDATA[<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><h3 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="基于协作的抢占式调度"></a>基于协作的抢占式调度</h3><blockquote><p>Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="调度器启动"><a href="#调度器启动" class="headerlink" title="调度器启动"></a>调度器启动</h2><h2 id="创建Goroutine"><a href="#创建Goroutine" class="headerlink" title="创建Goroutine"></a>创建Goroutine</h2><h2 id="调度循环"><a href="#调度循环" class="headerlink" title="调度循环"></a>调度循环</h2><h2 id="为什么协程切换的代价比线程切换低"><a href="#为什么协程切换的代价比线程切换低" class="headerlink" title="为什么协程切换的代价比线程切换低?"></a>为什么协程切换的代价比线程切换低?</h2><blockquote><p>协程切换非常简单，就是把当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上就 ok 了。而且完全在用户态进行，一般来说一次协程上下文切换最多就是几十ns 这个量级。</p><p>线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换，也就是特权模式切换，然后需要操作系统调度模块完成线程调度（taskstruct），而且除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等，说白了就是上下文比协程多一些，其实简单比较下 task_strcut 和 任何一个协程库的 coroutine 的 struct 结构体大小就能明显区分出来。<br>恶化cache命中率，提升sys cpu的执行占比，导致侵占用户态的cpu利用率。</p></blockquote><h2 id="进程的开销比线程大在了哪里"><a href="#进程的开销比线程大在了哪里" class="headerlink" title="进程的开销比线程大在了哪里?"></a>进程的开销比线程大在了哪里?</h2><p>创建成本:</p><blockquote><p>Linux 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。创建线程则简单得多，只需要确定 PC 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。因此，创建进程比创建线程慢，而且进程的内存开销更大。</p></blockquote><p>切换成本:</p><blockquote><p>进程切换涉及虚拟地址空间的切换而线程不会。</p><p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.kancloud.cn/aceld/golang/1958305">刘丹冰Aceld-Golang的协程调度器原理及GMP设计思想？</a></li><li><a href="https://tonybai.com/2020/03/21/illustrated-tales-of-go-runtime-scheduler/">Tony Bai-图解Go运行时调度器</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/105447358?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162753851016780255226838%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162753851016780255226838&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-105447358.pc_v2_rank_blog_default&amp;utm_term=Goroutine&amp;spm=1018.2226.3001.4450">Golang 协程Goroutine到底是怎么回事？（一）</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/105447383?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162753851016780255226838%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162753851016780255226838&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-105447383.pc_v2_rank_blog_default&amp;utm_term=Goroutine&amp;spm=1018.2226.3001.4450">Golang 协程Goroutine到底是怎么回事？（二）</a></li><li><a href="https://talkgo.org/t/topic/31">go夜读-golang 中 goroutine 的调度</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/">Go 语言原本-并发调度</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">draveness-调度器</a></li><li><a href="https://learnku.com/articles/41728">[典藏版] Golang 调度器 GMP 原理与调度全分析</a></li><li>《Golang 源码剖析 1.5.1 雨痕》</li><li><a href="https://www.zhihu.com/question/308641794">为什么协程切换的代价比线程切换低?</a></li><li><a href="https://segmentfault.com/a/1190000021492983">Netty中的Reactor模型详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/79772089">进程/线程上下文切换会用掉你多少CPU？</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/17%20%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%A4%A7%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%9F.md">《重学操作系统》进程和线程：进程的开销比线程大在了哪里？</a></li><li><a href="https://www.jianshu.com/p/16b83e7facb9">为什么运行时程序要分成内核态和用户态</a></li><li><a href="https://blog.csdn.net/htxhtx123/article/details/104595175">什么是ring0-ring3</a></li><li><a href="https://zhuanlan.zhihu.com/p/69554144">怎样去理解Linux用户态和内核态？</a></li><li><a href="http://www.linfo.org/context_switch.html">Context Switch Definition</a></li><li><a href="https://blog.csdn.net/gatieme/article/details/50779184">Linux系统调用详解（实现机制分析）–linux内核剖析（六）</a></li><li><a href="https://www.zhihu.com/question/32264167">关于go语言协程调度的一个问题(具体请看问题描述)?</a></li><li><a href="https://juejin.cn/post/6844903930497859591">深度解密Go语言之 scheduler</a></li><li><a href="https://cloud.tencent.com/developer/article/1367908">Linux核心调度器之周期性调度器scheduler_tick–Linux进程的管理与调度(十八）</a></li><li><a href="https://segmentfault.com/a/1190000016038785">Golang - 调度剖析【第一部分】</a></li><li><a href="https://segmentfault.com/a/1190000016611742">Golang - 调度剖析【第二部分】</a></li><li><a href="https://segmentfault.com/a/1190000017333717">Golang - 调度剖析【第三部分】</a></li><li><a href="https://www.cnblogs.com/charlieroro/p/12133100.html">linux线程调度策略</a></li><li><a href="https://mp.weixin.qq.com/s/7bjefYPhI03t9HRny42zkA">为什么Go服务容器化之后延迟变高</a></li><li><a href="https://blog.csdn.net/qq_34417408/article/details/110393655">线程比进程更快，吞吐更强，本文从切换方面介绍</a></li></ol><p><a href="http://www.linfo.org/context_switch.html">http://www.linfo.org/context_switch.html</a></p><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=18c9f8f5d9fa76f11dbee46c48954835&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=18c9f8f5d9fa76f11dbee46c48954835&amp;type=note</a></p><p><a href="https://xargin.com/go-scheduler/">https://xargin.com/go-scheduler/</a></p><p><a href="https://www.bilibili.com/video/BV1RK4y187k4/?spm_id_from=333.788.recommend_more_video.4">https://www.bilibili.com/video/BV1RK4y187k4/?spm_id_from=333.788.recommend_more_video.4</a></p><p><a href="https://www.bilibili.com/video/BV1pb411v7nu?from=search&amp;seid=2638724496956885629">https://www.bilibili.com/video/BV1pb411v7nu?from=search&amp;seid=2638724496956885629</a></p><p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx?p=17">https://www.bilibili.com/video/BV19r4y1w7Nx?p=17</a></p><p><a href="https://www.bilibili.com/video/BV1MZ4y1V7SP/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1MZ4y1V7SP/?spm_id_from=333.788.recommend_more_video.-1</a></p><p><a href="https://www.bilibili.com/video/BV1Ky4y1r78H/?spm_id_from=333.788.recommend_more_video.1">https://www.bilibili.com/video/BV1Ky4y1r78H/?spm_id_from=333.788.recommend_more_video.1</a></p><p><a href="https://www.bilibili.com/video/BV1zT4y1F7XF?from=search&amp;seid=6090279844654181905">https://www.bilibili.com/video/BV1zT4y1F7XF?from=search&amp;seid=6090279844654181905</a></p><p><a href="https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86--golang-runtime.md">https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86--golang-runtime.md</a></p><p><a href="https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8D%8F%E7%A8%8B%E6%A0%88.md">https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8D%8F%E7%A8%8B%E6%A0%88.md</a></p><p><a href="https://www.luozhiyun.com/archives/448">https://www.luozhiyun.com/archives/448</a></p><p><a href="https://www.luozhiyun.com/archives/485">https://www.luozhiyun.com/archives/485</a></p><p><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit</a></p><p><a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a></p><p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.0.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.0.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/216118842">https://zhuanlan.zhihu.com/p/216118842</a></p><p><a href="https://segmentfault.com/a/1190000039052089">https://segmentfault.com/a/1190000039052089</a></p><p><a href="https://zhuanlan.zhihu.com/p/244054940">https://zhuanlan.zhihu.com/p/244054940</a></p><p><a href="https://www.infoq.cn/article/r6wzs7bvq2er9kuelbqb">https://www.infoq.cn/article/r6wzs7bvq2er9kuelbqb</a></p><p><a href="https://www.infoq.cn/article/NuvRPz1cPk9Cw0HP3bkY?utm_source=related_read&amp;utm_medium=article">https://www.infoq.cn/article/NuvRPz1cPk9Cw0HP3bkY?utm_source=related_read&amp;utm_medium=article</a></p><ol><li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.5.html">深入解析Go-抢占式调度</a></li></ol><p><a href="https://zhuanlan.zhihu.com/p/42057783">https://zhuanlan.zhihu.com/p/42057783</a></p><p><a href="http://xiaorui.cc/archives/6535">http://xiaorui.cc/archives/6535</a></p><p><a href="https://juejin.cn/post/6844903846825705485">https://juejin.cn/post/6844903846825705485</a></p><p><a href="https://zboya.github.io/post/go_scheduler/">https://zboya.github.io/post/go_scheduler/</a></p><p><a href="https://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">https://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a></p><p><a href="https://yizhi.ren/2019/06/03/goscheduler/">https://yizhi.ren/2019/06/03/goscheduler/</a></p><p><a href="https://jingwei.link/2019/05/26/golang-routine-scheduler.html">https://jingwei.link/2019/05/26/golang-routine-scheduler.html</a></p><p><a href="https://blog.haohtml.com/archives/18352">https://blog.haohtml.com/archives/18352</a></p><p><a href="http://austsxk.com/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/">http://austsxk.com/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/</a></p><p><a href="https://qcrao.com/2019/09/06/dive-into-go-scheduler-source-code/">https://qcrao.com/2019/09/06/dive-into-go-scheduler-source-code/</a></p><p><a href="https://qcrao.com/2020/04/03/talk-about-g0/">https://qcrao.com/2020/04/03/talk-about-g0/</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-a-goroutine-start-and-exit-2b3303890452">https://medium.com/a-journey-with-go/go-how-does-a-goroutine-start-and-exit-2b3303890452</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-go-recycle-goroutines-f047a79ab352">https://medium.com/a-journey-with-go/go-how-does-go-recycle-goroutines-f047a79ab352</a></p><p><a href="https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7">https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7</a></p><p><a href="https://medium.com/a-journey-with-go/go-work-stealing-in-go-scheduler-d439231be64d">https://medium.com/a-journey-with-go/go-work-stealing-in-go-scheduler-d439231be64d</a></p><p><a href="https://www.tyx.pub/archives/86">https://www.tyx.pub/archives/86</a></p><p><a href="https://www.pengrl.com/p/39569/">https://www.pengrl.com/p/39569/</a></p><p><a href="https://feiybox.com/2020/03/14/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/">https://feiybox.com/2020/03/14/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</a></p><p><a href="http://odin.show/2020/04/25/golang-GPM">http://odin.show/2020/04/25/golang-GPM</a></p><p><a href="https://www.huweihuang.com/golang-notes/principle/go-scheduler.html">https://www.huweihuang.com/golang-notes/principle/go-scheduler.html</a></p><p><a href="http://qinqiyao.com/2019/12/25/Golang%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">http://qinqiyao.com/2019/12/25/Golang%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</a></p><p><a href="https://blog.crazytaxii.com/posts/scheduling_in_go_part2/">https://blog.crazytaxii.com/posts/scheduling_in_go_part2/</a></p><p><a href="https://www.liuvv.com/p/c8d0853c.html">https://www.liuvv.com/p/c8d0853c.html</a></p><p><a href="https://www.iminho.me/wiki/blog-21.html">https://www.iminho.me/wiki/blog-21.html</a></p><p><a href="https://mdnice.com/writing/98e27d97c9fd43b3aed92f36d7566794">https://mdnice.com/writing/98e27d97c9fd43b3aed92f36d7566794</a></p><p><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#">https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBFT</title>
      <link href="/pbft/"/>
      <url>/pbft/</url>
      
        <content type="html"><![CDATA[<h2 id="两将军问题"><a href="#两将军问题" class="headerlink" title="两将军问题"></a>两将军问题</h2><blockquote><p>根据FLP不可能原理，两将军问题无通用解</p></blockquote><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><blockquote><p>拜占庭系统普遍采用的假设条件包括：</p><ol><li>拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；</li><li>节点之间的错误是不相关的；</li><li>节点之间通过异步网络连接，网络中的消息可能丢失、乱序并延时到达，但大部分协议假设消息在有限的时间里能传达到目的地；</li><li>服务器之间传递的信息，第三方可以嗅探到，但是不能篡改、伪造信息的内容和验证信息的完整性。</li></ol></blockquote><h2 id="BFT-拜占庭容错-简介"><a href="#BFT-拜占庭容错-简介" class="headerlink" title="BFT(拜占庭容错)简介"></a>BFT(拜占庭容错)简介</h2><h2 id="PBFT简介"><a href="#PBFT简介" class="headerlink" title="PBFT简介"></a>PBFT简介</h2><blockquote><p>PBFT算法可以在失效节点不超过总数1/3的情况下同时保证Safety和Liveness</p></blockquote><blockquote><p>PBFT 算法采用密码学相关技术(RSA 签名算法、消息验证编码和摘要)确保消息传递过程无法被篡改和破坏</p></blockquote><blockquote><p>PBFT是一种状态机副本复制算法</p></blockquote><h2 id="SBFT简介"><a href="#SBFT简介" class="headerlink" title="SBFT简介"></a>SBFT简介</h2><p>Hyperledger fabric v1.0对PBFT的改进</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote><p>PBFT算法具有高交易通量和吞吐量，高可用性，易于理解。</p></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote><ol><li>计算效率依赖于参与协议的节点数量，由于每个副本节点都需要和其它节点进行P2P的共识同步，因此随着节点的增多，性能会下降的很快，但在较少节点的情况下可以有不错的性能，并且分叉的几率很低，不适用于节点数量过大的区块链，扩展性差。</li><li>系统节点是固定的，无法应对公有链的开放环境，只适用于联盟链或私<br>有链环境。</li><li>PBFT算法要求总节点数n&gt;=3f+1(其中，f代表作恶节点数)。系统的失效节点数量不得超过全网节点的1/3，容错率相对较低。</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>PBFT算法由于每个副本节点都需要和其他节点进行P2P的共识同步，因此随着节点的增多，性能会下降的很快，但是在较少节点的情况下可以有不错的性能，并且分叉的几率很低。PBFT主要用于联盟链，但是如果能够结合类似DPOS这样的节点代表选举规则的话也可以应用于公联，并且可以在一个不可信的网络里解决拜占庭容错问题，TPS应该是远大于POW的。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/jfkidear/article/details/81275974">https://blog.csdn.net/jfkidear/article/details/81275974</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98</a></p><p><a href="https://zhuanlan.zhihu.com/p/43067427">https://zhuanlan.zhihu.com/p/43067427</a></p><p><a href="https://lrita.github.io/2018/10/28/time-sequence-in-blockchain-by-bft/">https://lrita.github.io/2018/10/28/time-sequence-in-blockchain-by-bft/</a></p><p><a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">http://pmg.csail.mit.edu/papers/osdi99.pdf</a></p><p><a href="https://www.jianshu.com/p/78e2b3d3af62">https://www.jianshu.com/p/78e2b3d3af62</a></p><p>《极客时间-分布式协议与算法实战》</p>]]></content>
      
      
      <categories>
          
          <category> distribute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consistency </tag>
            
            <tag> distribute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/kafka/"/>
      <url>/kafka/</url>
      
        <content type="html"><![CDATA[<h2 id="生产者-producer"><a href="#生产者-producer" class="headerlink" title="生产者(producer)"></a>生产者(producer)</h2><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/producer-arch.jpg" alt="生产者整体架构"></p><h3 id="元数据获取"><a href="#元数据获取" class="headerlink" title="元数据获取"></a>元数据获取</h3><p>元数据记录了集群中有哪些主题、主题的分区、每个分区的leader副本配在哪个节点上、follower副本分配在哪些节点上, 哪些副本在AR、ISR集合中、集群中有哪些几点、控制器节点又是哪一个等等。</p><h3 id="重要的生产者参数"><a href="#重要的生产者参数" class="headerlink" title="重要的生产者参数"></a>重要的生产者参数</h3><ol><li>acks</li><li>max.request.size</li><li>retries</li></ol><h2 id="消费者-consumer"><a href="#消费者-consumer" class="headerlink" title="消费者(consumer)"></a>消费者(consumer)</h2><p>一个分区只会被分配给一个消费者的一个线程</p><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-offset-save.jpg" alt="消费进度的保存和恢复"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consume-flow.jpg" alt="消费者客户端的消费消息流程"></p><p>左图: 一个消费者进程里开了3个线程。<br>右图: 三个消费者进程分别开了1个线程。<br>两种都是开了3线程消费, 只不过对zk来说看到的消费组成员列表是不同的。<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-threads-vs-procs.jpg" alt="消费者进程和线程"></p><h3 id="消费者连接器"><a href="#消费者连接器" class="headerlink" title="消费者连接器"></a>消费者连接器</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-connect-text.jpg"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-connect.jpg" alt="ConsumerConnect连接器各组件协调完成消息的消费"></p><h3 id="消费者客户端的线程模型"><a href="#消费者客户端的线程模型" class="headerlink" title="消费者客户端的线程模型"></a>消费者客户端的线程模型</h3><p>使用队列作为消息的缓存<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-threads-model.jpg" alt="消费者客户端线程模型"></p><h3 id="消费组重平衡"><a href="#消费组重平衡" class="headerlink" title="消费组重平衡"></a>消费组重平衡</h3><h4 id="重平衡的条件"><a href="#重平衡的条件" class="headerlink" title="重平衡的条件"></a>重平衡的条件</h4><ol><li>组成员数量发生变化。</li><li>订阅主题数量发生变化。</li><li>订阅主题的分区数发生变化。<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-rebalance.jpg" alt="触发消费者连接器执行再平衡操作的两种方式"></li></ol><h4 id="重平衡的过程"><a href="#重平衡的过程" class="headerlink" title="重平衡的过程"></a>重平衡的过程</h4><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-pull-thread-rebalance-flow.jpg" alt="拉取线程再平衡中的关闭和更新"></p><h4 id="通知机制-消费端着端的心跳线程-Heartbeat-Thread"><a href="#通知机制-消费端着端的心跳线程-Heartbeat-Thread" class="headerlink" title="通知机制, 消费端着端的心跳线程(Heartbeat Thread)"></a>通知机制, 消费端着端的心跳线程(Heartbeat Thread)</h4><p>重平衡过程是如何通知到其他消费者实例的？答案就是，靠消费者端的心跳线程（Heartbeat Thread）</p><p>重平衡的通知机制正是通过心跳线程来完成的。当协调者决定开启新一轮重平衡后，它会将“REBALANCE_IN_PROGRESS”封装进心跳请求的响应中，发还给消费者实例。当消费者实例发现心跳响应中包含了“REBALANCE_IN_PROGRESS”，就能立马知道重平衡又开始了，这就是重平衡的通知机制。</p><h3 id="消费者消费消息"><a href="#消费者消费消息" class="headerlink" title="消费者消费消息"></a>消费者消费消息</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-main-flow.jpg" alt="消费者消费消息的主流程"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/temp2.jpg"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-pull-consume-state.jpg" alt="拉取线程和消费线程分别更新分区信息的状态"></p><h3 id="位移的管理"><a href="#位移的管理" class="headerlink" title="位移的管理"></a>位移的管理</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/temp1.jpg"></p><h4 id="提交偏移量到ZK"><a href="#提交偏移量到ZK" class="headerlink" title="提交偏移量到ZK"></a>提交偏移量到ZK</h4><h4 id="提交偏移量到内部位移主题"><a href="#提交偏移量到内部位移主题" class="headerlink" title="提交偏移量到内部位移主题"></a>提交偏移量到内部位移主题</h4><p>__consumer_offsets 叫位移主题, 是kafka的内部主题。该主题的默认分区数是50, 副本数是3.</p><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><h2 id="Coordinator-协调者"><a href="#Coordinator-协调者" class="headerlink" title="Coordinator(协调者)"></a>Coordinator(协调者)</h2><p>专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等</p><p>Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。</p><p>所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件。也就是说，所有 Broker 都有各自的 Coordinator 组件。那么，Consumer Group 如何确定为它服务的 Coordinator 在哪台 Broker 上呢？</p><p>确定由位移主题的哪个分区来保存该 Group 数据, 然后找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator。</p><h3 id="StickyAssignor-有粘性的分区分配策略"><a href="#StickyAssignor-有粘性的分区分配策略" class="headerlink" title="StickyAssignor(有粘性的分区分配策略)"></a>StickyAssignor(有粘性的分区分配策略)</h3><h2 id="消息代理-broker"><a href="#消息代理-broker" class="headerlink" title="消息代理(broker)"></a>消息代理(broker)</h2><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><blockquote><p>Kafka 中的索引文件以稀疏索引（sparse index）的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引项。</p></blockquote><h4 id="zero-copy-零拷贝"><a href="#zero-copy-零拷贝" class="headerlink" title="zero-copy(零拷贝)"></a>zero-copy(零拷贝)</h4><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/zero-copy.jpg" alt="零拷贝"></p><h3 id="控制器-controller"><a href="#控制器-controller" class="headerlink" title="控制器(controller)"></a>控制器(controller)</h3><h3 id="分区、副本"><a href="#分区、副本" class="headerlink" title="分区、副本"></a>分区、副本</h3><h4 id="消息分区机制"><a href="#消息分区机制" class="headerlink" title="消息分区机制"></a>消息分区机制</h4><ul><li>轮循策略(未指定key的默认策略)</li><li>随机策略(老版本)</li><li>根据key计算hash(指定key时的默认策略)</li></ul><h4 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h4><blockquote><p>Producer和Broker都可以配置压缩算法。其实大部分情况下 Broker 从 Producer 端接收到消息后仅仅是原封不动地保存而不会对其进行任何修改.</p><p>有两种例外情况就可能让 Broker 重新压缩消息:</p><p>情况一：Broker 端指定了和 Producer 端不同的压缩算法。</p><p>情况二：Broker 端发生了消息格式转换(Kafka集群中同时保存了多种版本的消息格式, 为了兼容老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩。)</p></blockquote><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><h4 id="Kafka里的网络模型"><a href="#Kafka里的网络模型" class="headerlink" title="Kafka里的网络模型"></a>Kafka里的网络模型</h4><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/kafka-network-thread.jpg" alt="kafka网络模型"></p><h2 id="内部元数据"><a href="#内部元数据" class="headerlink" title="内部元数据"></a>内部元数据</h2><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>ZK存储了Kafka的内部元数据, 还记录了消费组的成员列表, 分区的消费进度, 分区的所有者。节点、主题、分区、消费者、偏移量(offset)、所有权(ownership)</p><h3 id="kraft"><a href="#kraft" class="headerlink" title="kraft"></a>kraft</h3><p>2.8开始kafka去掉了zookeeper, </p><h2 id="kafka-stream"><a href="#kafka-stream" class="headerlink" title="kafka stream"></a>kafka stream</h2><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><ol><li>Producer要使用带callback的函数, 这样可以处理失败。</li><li>不开启自动提交, 而是手动提交位移</li><li>设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li><li>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li><li>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li><li>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li><li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li><li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《极客时间-Kafka核心技术与实战》</li><li>《极客时间-Kafka核心源码解读》</li><li>《深入理解Kafka：核心设计与实践原理》</li><li>《Kafka技术内幕》</li><li><a href="https://blog.csdn.net/u4110122855/article/details/103616791">Kafka分区分配策略分析——重点：StickyAssignor</a></li><li><a href="https://blog.csdn.net/u013256816/article/details/81123625">Kafka分区分配策略（2）——RoundRobinAssignor和StickyAssignor</a></li><li><a href="https://www.cnblogs.com/huxi2b/">https://www.cnblogs.com/huxi2b/</a></li><li><a href="https://www.confluent.io/blog/">https://www.confluent.io/blog/</a></li><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Index">https://cwiki.apache.org/confluence/display/KAFKA/Index</a></li><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+papers+and+presentations">https://cwiki.apache.org/confluence/display/KAFKA/Kafka+papers+and+presentations</a></li><li><a href="https://blog.csdn.net/yjh314/article/details/78863875">https://blog.csdn.net/yjh314/article/details/78863875</a></li><li><a href="https://www.jianshu.com/p/afd5da6a92ab">https://www.jianshu.com/p/afd5da6a92ab</a></li><li><a href="https://blog.csdn.net/nazeniwaresakini/article/details/116085573">https://blog.csdn.net/nazeniwaresakini/article/details/116085573</a></li><li><a href="https://zhuanlan.zhihu.com/p/368600560">https://zhuanlan.zhihu.com/p/368600560</a></li><li><a href="https://zhenghe-md.github.io/blog/2020/03/15/Kafka-a-Distributed-Messaging-System-for-Log-Processing-2011/">Kafka: a Distributed Messaging System for Log Processing (2011)</a></li><li><a href="https://blog.csdn.net/csdnnews/article/details/99256826">拿来就能用！去哪儿网消息中间件 QMQ 详解 | 技术头条</a></li><li><a href="http://blog.chinaunix.net/uid-26111972-id-5845593.html">关于kafka消费者处理消息异常实验</a></li><li><a href="https://www.jianshu.com/p/2effb654e1f4">kafka之消费超时死循环</a></li><li><a href="https://jaskey.github.io/blog/2020/06/08/rocketmq-message-dedup/">消息幂等（去重）通用解决方案，RocketMQ</a></li><li><a href="https://support.huaweicloud.com/bestpractice-kafka/kafka-bp-190605002.html">如何提高消息处理效率</a></li></ol><p><a href="http://notes.stephenholiday.com/Kafka.pdf">http://notes.stephenholiday.com/Kafka.pdf</a></p><p><a href="https://medium.com/@andy.bryant/processing-guarantees-in-kafka-12dd2e30be0e">https://medium.com/@andy.bryant/processing-guarantees-in-kafka-12dd2e30be0e</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 垃圾回收</title>
      <link href="/golang-gc/"/>
      <url>/golang-gc/</url>
      
        <content type="html"><![CDATA[<h2 id="GC-roots"><a href="#GC-roots" class="headerlink" title="GC roots"></a>GC roots</h2><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><p>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。<br>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。<br>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</p><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><ul><li>白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；</li><li>黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li></ul><h3 id="三色不变性"><a href="#三色不变性" class="headerlink" title="三色不变性"></a>三色不变性</h3><blockquote><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p></blockquote><ul><li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li></ul><h3 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h3><blockquote><p>插入写屏障会将有存活可能的对象都标记成灰色以满足强三色不变性。</p></blockquote><blockquote><p>将指针指向的新值置为灰色</p></blockquote><h3 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h3><blockquote><p>在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p></blockquote><h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">Go语言设计与实现-垃圾收集器</a></li><li><a href="https://segmentfault.com/a/1190000022030353">[典藏版]Golang三色标记、混合写屏障GC模式图文全分析</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/">golang设计-垃圾回收</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/">legendtkl-Golang 垃圾回收剖析</a></li><li><a href="https://www.bilibili.com/video/BV1wz4y1y7Kd">Golang中GC回收机制三色标记与混合写屏障</a></li><li><a href="https://www.kancloud.cn/aceld/golang/1958308">Golang三色标记+混合写屏障GC模式全分析</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/107291523?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162753862316780366532920%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162753862316780366532920&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-107291523.pc_v2_rank_blog_default&amp;utm_term=golang+%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&amp;spm=1018.2226.3001.4450">golang 垃圾回收（四）删除写屏障</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/107622603">golang 垃圾回收（五）深入剖析混合写屏障</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/barrier/">Go 语言原本-写屏障技术</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/107738258?spm=1001.2014.3001.5501">深度剖析 Golang 的 GC 扫描对象实现</a></li><li><a href="https://blog.csdn.net/QcloudCommunity/article/details/119397102">自动的内存管理系统实操手册——Golang垃圾回收篇</a></li></ol><p><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/">https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/</a></p><p><a href="https://blog.csdn.net/weixin_34248849/article/details/88987666">https://blog.csdn.net/weixin_34248849/article/details/88987666</a></p><p><a href="http://www.52codes.net/develop/shell/56961.html">http://www.52codes.net/develop/shell/56961.html</a></p><p><a href="https://www.cnblogs.com/badcw/p/14192895.html">https://www.cnblogs.com/badcw/p/14192895.html</a></p><p><a href="https://weibo.com/ttarticle/p/show?id=2309404620360724382113#_loginLayer_1623600085589">https://weibo.com/ttarticle/p/show?id=2309404620360724382113#_loginLayer_1623600085589</a></p><p><a href="https://weibo.com/ttarticle/p/show?id=2309404620723120373979">https://weibo.com/ttarticle/p/show?id=2309404620723120373979</a></p><p><a href="http://www.360doc.com/content/21/0416/22/15690396_972688492.shtml">http://www.360doc.com/content/21/0416/22/15690396_972688492.shtml</a></p><p><a href="https://www.cnblogs.com/saryli/p/10105393.html">https://www.cnblogs.com/saryli/p/10105393.html</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a></p><p><a href="https://talks.golang.org/2015/go-gc.pdf">https://talks.golang.org/2015/go-gc.pdf</a></p><p><a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a></p><p><a href="https://www.oschina.net/translate/go-gc-solving-the-latency-problem-in-go-1-5?comments&amp;p=1">https://www.oschina.net/translate/go-gc-solving-the-latency-problem-in-go-1-5?comments&amp;p=1</a></p><p><a href="https://www.jianshu.com/p/bfc3c65c05d1?utm_source=wechat_session">https://www.jianshu.com/p/bfc3c65c05d1?utm_source=wechat_session</a></p><p><a href="https://www.bilibili.com/video/BV1Ui4y1F7n3/?spm_id_from=333.788.recommend_more_video.0">https://www.bilibili.com/video/BV1Ui4y1F7n3/?spm_id_from=333.788.recommend_more_video.0</a></p><p><a href="https://xie.infoq.cn/article/67cfd494e6e10cd0b40de95ab">https://xie.infoq.cn/article/67cfd494e6e10cd0b40de95ab</a></p><p><a href="https://zhuanlan.zhihu.com/p/297177002">https://zhuanlan.zhihu.com/p/297177002</a></p><p><a href="https://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/">https://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/</a></p><p><a href="https://learnku.com/docs/go-blog/ismmkeynote/6499">https://learnku.com/docs/go-blog/ismmkeynote/6499</a></p><p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html</a></p><p><a href="https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.2-garbage_collection.md">https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.2-garbage_collection.md</a></p><p><a href="https://docs.kilvn.com/go-internals/06.2.html">https://docs.kilvn.com/go-internals/06.2.html</a></p><p><a href="https://www.youtube.com/watch?v=q4HoWwdZUHs">Garbage Collection Semantics - GopherCon SG 2019</a></p><p><a href="https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05">https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35</a></p><p><a href="https://medium.com/a-journey-with-go/go-keeping-a-variable-alive-c28e3633673a">https://medium.com/a-journey-with-go/go-keeping-a-variable-alive-c28e3633673a</a></p><p><a href="https://www.tyx.pub/archives/148">https://www.tyx.pub/archives/148</a></p><p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a></p><p><a href="https://talks.golang.org/2015/go-gc.pdf">https://talks.golang.org/2015/go-gc.pdf</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/11970-decentralized-gc.md">https://github.com/golang/proposal/blob/master/design/11970-decentralized-gc.md</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md">https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md">https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> gc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gc </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC算法</title>
      <link href="/gc-algorithm/"/>
      <url>/gc-algorithm/</url>
      
        <content type="html"><![CDATA[<p>评价GC算法的性能时，我们采用以下4个标准。</p><ul><li>吞吐量</li><li>最大暂停时间</li><li>堆使用效率</li><li>访问的局部性</li></ul><p class="note note-primary">标签</p><h3 id="mutator"><a href="#mutator" class="headerlink" title="mutator"></a>mutator</h3><p>mutator是Dijkstra琢磨出来的词，有“改变某物”的意思。说到要改变什么，那就是GC对象间的引用关系。不过光这么说可能大家还是不能理解，其实用一句话概括的话，它的实体就是“应用程序”。这样说就容易理解了吧。GC就是在这个mutator内部精神饱满地工作着。<br>mutator实际进行的操作有以下2种：</p><ul><li>生成对象</li><li>更新指针</li></ul><p>mutator在进行这些操作时，会同时为应用程序的用户进行一些处理（数值计算、浏览网页、编辑文章等）。随着这些处理的逐步推进，对象间的引用关系也会“改变”。伴随这些变化会产生垃圾，而负责回收这些垃圾的机制就是GC。</p><h2 id="朴素的标记清除"><a href="#朴素的标记清除" class="headerlink" title="朴素的标记清除"></a>朴素的标记清除</h2><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>   mark_phase(){</span><br><span class="line"><span class="number">02</span>     <span class="keyword">for</span>(r : $roots)</span><br><span class="line"><span class="number">03</span>        mark(*r)</span><br><span class="line"><span class="number">04</span>   }</span><br><span class="line"><span class="number">05</span></span><br><span class="line"><span class="number">06</span></span><br><span class="line"><span class="number">07</span>   mark(obj){</span><br><span class="line">08     <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">09        obj.mark = TRUE</span><br><span class="line"><span class="number">10</span>        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line"><span class="number">11</span>          mark(*child)</span><br><span class="line"><span class="number">12</span>   }</span><br></pre></td></tr></tbody></table></figure><p>深搜？广搜？<br>两者性能差不多, 但是深搜比广搜更节省内存。</p><h3 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   sweep_phase(){</span><br><span class="line"><span class="number">2</span>     sweeping = $heap_start</span><br><span class="line"><span class="number">3</span>     <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line"><span class="number">4</span>        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line"><span class="number">5</span>          sweeping.mark = FALSE</span><br><span class="line"><span class="number">6</span>        <span class="keyword">else</span></span><br><span class="line"><span class="number">7</span>          sweeping.next = $free_list</span><br><span class="line"><span class="number">8</span>          $free_list = sweeping</span><br><span class="line"><span class="number">9</span>        sweeping += sweeping.size</span><br><span class="line"> <span class="number">10</span>   }</span><br></pre></td></tr></tbody></table></figure><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   new_obj(size){</span><br><span class="line"><span class="number">2</span>     chunk = pickup_chunk(size, $free_list)</span><br><span class="line"><span class="number">3</span>     <span class="keyword">if</span>(chunk ! = NULL)</span><br><span class="line"><span class="number">4</span>        <span class="keyword">return</span> chunk</span><br><span class="line"><span class="number">5</span>     <span class="keyword">else</span></span><br><span class="line"><span class="number">6</span>        allocation_fail()</span><br><span class="line"><span class="number">7</span>   }</span><br></pre></td></tr></tbody></table></figure><h4 id="First-fit、Best-fit、Worst-fit的不同"><a href="#First-fit、Best-fit、Worst-fit的不同" class="headerlink" title="First-fit、Best-fit、Worst-fit的不同"></a>First-fit、Best-fit、Worst-fit的不同</h4><p>之前我们讲的分配策略叫作First-fit。因为在pickup_chunk()函数中，最初发现大于等于size的分块时就会立即返回该分块。然而，分配策略不止这些。还有遍历空闲链表，返回大于等于size的最小分块，这种策略叫作Best-fit。还有一种策略叫作Worst-fit，即找出空闲链表中最大的分块，将其分割成mutator申请的大小和分割后剩余的大小，目的是将分割后剩余的分块最大化。但因为Worst-fit很容易生成大量小的分块，所以不推荐大家使用此方法。除去Worst-fit，剩下的还有Best-fit和First-fit这两种。当我们使用单纯的空闲链表时，考虑到分配所需的时间，选择使用First-fit更为明智。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>改造sweep_phase, 在清楚阶段进行合并</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>   sweep_phase(){</span><br><span class="line"><span class="number">02</span>     sweeping = $heap_start</span><br><span class="line"><span class="number">03</span>     <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line"><span class="number">04</span>        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line"><span class="number">05</span>          sweeping.mark = FALSE</span><br><span class="line"><span class="number">06</span>        <span class="keyword">else</span></span><br><span class="line"><span class="number">07</span>          <span class="keyword">if</span>(sweeping == $free_list + $free_list.size)</span><br><span class="line">08             $free_list.size += sweeping.size</span><br><span class="line">09          <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>             sweeping.next = $free_list</span><br><span class="line"><span class="number">11</span>             $free_list = sweeping</span><br><span class="line"><span class="number">12</span>        sweeping += sweeping.size</span><br><span class="line"><span class="number">13</span>   }</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>实现简单: 说到GC标记-清除算法的优点，那当然要数算法简单，实现容易了。打个比方，接下来我们将在第3章中提到引用计数法，在引用计数法中就很难切实管理计数器的增减，实现也很困难。另外，如果算法实现简单，那么它与其他算法的组合也就相应地简单。在第3章和第4章中，我们会为大家介绍把GC标记-清除算法与其他GC算法相结合的方法。</li><li>与保守式GC算法兼容：在第6章中介绍的保守式GC算法中，对象是不能被移动的。因此保守式GC算法跟把对象从现在的场所复制到其他场所的GC复制算法（第4章）与标记-压缩算法（第5章）不兼容。而GC标记-清除算法因为不会移动对象，所以非常适合搭配保守式GC算法。事实上，在很多采用保守式GC算法的处理程序中也用到了GC标记-清除算法。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>碎片化</li><li>分配速度慢</li><li>与写时复制技术不兼容</li></ul><h3 id="可以考虑使用多个空闲链表优化"><a href="#可以考虑使用多个空闲链表优化" class="headerlink" title="可以考虑使用多个空闲链表优化"></a>可以考虑使用多个空闲链表优化</h3><h3 id="BiBOP法"><a href="#BiBOP法" class="headerlink" title="BiBOP法"></a>BiBOP法</h3><h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><h3 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h3><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><h3 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h3><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><h3 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h3><h3 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h3><h3 id="1位引用计数法"><a href="#1位引用计数法" class="headerlink" title="1位引用计数法"></a>1位引用计数法</h3><h3 id="部分标记-清除法"><a href="#部分标记-清除法" class="headerlink" title="部分标记-清除法"></a>部分标记-清除法</h3><h4 id="四色"><a href="#四色" class="headerlink" title="四色"></a>四色</h4><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《垃圾回收的算法与实现-中村成洋》</li><li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Tracing garbage collection</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> gc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础知识</title>
      <link href="/redis/"/>
      <url>/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/xmind/redis.xmind.svg" alt="Redis思维导图"></p><h2 id="高性能IO模型"><a href="#高性能IO模型" class="headerlink" title="高性能IO模型"></a>高性能IO模型</h2><p>请参考我的另一篇文章:<a href="/high-performance-network-model/">高性能网络模型</a></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="AOF基本概念"><a href="#AOF基本概念" class="headerlink" title="AOF基本概念"></a>AOF基本概念</h4><p>相比于数据库的写前日志(Write Ahead Log, WAL), AOF是在执行完命令后, 写入的日志。</p><p>传统的数据库日志如redo log(重做日志), 记录的是修改后的数据, 而AOF里记录的是Redis服务器收到的每一条redis通信协议格式的命令。</p><p>为了避免开销, 写AOF之前并不会进行语法校验。所以先记日志再执行的话，可能会记录错误的指令。<br>而如果先执行命令, 成功后再记录AOF的话，就不会存在这样的问题。</p><h4 id="AOF三种写回策略"><a href="#AOF三种写回策略" class="headerlink" title="AOF三种写回策略"></a>AOF三种写回策略</h4><p>可以选择appendfsync配置的三个可选值, 来选择对应的写回策略</p><ul><li>always, 每个写命令都立即将日志写回磁盘</li><li>everysec, 每秒写回</li><li>no, redis不主动写回磁盘, 只是先把日志写到AOF文件的内存缓冲区中, 由操作系统决定何时写回磁盘。</li></ul><h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><p>在重写时, 创建一个新的AOF文件, 扫描当前数据库中的所有键值对, 并写入到这个新的AOF文件中。<br>这样就可以减少AOF文件里key的无用历史记录。</p><p>重写是由后台线程bgrewriteof来完成的，被主线程fork出来的时候会有主线程的一份内存拷贝, 这里就包含了数据库的最新数据。<br>bgrewriteof子进程就可以在不影响主线程的情况下, 写入重写日志。<br>如果redis在这期间内有新的写入, 在写入AOF缓冲的时候, 还会往AOF重写缓冲里写一份数据。等重写日志完成后, 这些新的操作记录也会写入到新的AOF文件中。<br>之后就可以用新的AOF文件替代旧文件了。</p><blockquote><p>fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。我的描述不太严谨了，非常感谢指出！</p></blockquote><blockquote><p>Kaito同学还提到了Huge page。这个特性大家在使用Redis也要注意。Huge page对提升TLB命中率比较友好，因为在相同的内存容量下，使用huge page可以减少页表项，TLB就可以缓存更多的页表项，能减少TLB miss的开销。</p></blockquote><blockquote><p>但是，这个机制对于Redis这种喜欢用fork的系统来说，的确不太友好，尤其是在Redis的写入请求比较多的情况下。因为fork后，父进程修改数据采用写时复制，复制的粒度为一个内存页。如果只是修改一个256B的数据，父进程需要读原来的内存页，然后再映射到新的物理地址写入。一读一写会造成读写放大。如果内存页越大（例如2MB的大页），那么读写放大也就越严重，对Redis性能造成影响。</p></blockquote><blockquote><p>Huge page在实际使用Redis时是建议关掉的。</p></blockquote><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>可以使用save命令让主进程执行全量快照备份, 也可以使用bgsave命令fork出子进程进行快照备份。<br>在快照过程中如果有写操作, 那么会触发fork的copy on write机制。</p><h3 id="混合快照"><a href="#混合快照" class="headerlink" title="混合快照"></a>混合快照</h3><p>混合RDB和AOF</p><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p>可以通过replicaof命令(Redis5.0之前是slaveof), 设置主从关系。<br>比如在B实例上执行如下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;A实例的IP地址&gt; &lt;A实例的Redis端口&gt;</span><br></pre></td></tr></tbody></table></figure><p>就可以让B作为A的从库, 并从A上复制数据。</p><h3 id="主从间同步数据"><a href="#主从间同步数据" class="headerlink" title="主从间同步数据"></a>主从间同步数据</h3><h4 id="第一阶段-建立连接-协商同步"><a href="#第一阶段-建立连接-协商同步" class="headerlink" title="第一阶段: 建立连接, 协商同步"></a>第一阶段: 建立连接, 协商同步</h4><p>从实例会给主实例发送 psync {runID} {offset} 。<br>第一次建立主从关系的话, 从实例是不知道主实例的runID的, 所以runID部分会是’?’。<br>之前没有同步过数据, 所以offset部分是-1。</p><p>主实例收到建立的请求后, 会向从实例发送<code>FULLRESYNC</code> {runID} {offset}。<br><code>FULLRESYNC</code> 表示第一次复制采用的全量复制, 也就是说, 主库会把当前所有的数据都复制给从库。</p><h4 id="第二阶段-主库同步数据给从库"><a href="#第二阶段-主库同步数据给从库" class="headerlink" title="第二阶段: 主库同步数据给从库"></a>第二阶段: 主库同步数据给从库</h4><p>主库执行bgsave命令, 生成RDB文件传输给从库。<br>从库收到RDB文件后, 会先清空当前数据库, 在本地完成RDB加载。<br>在同步期间如果有新的数据产生, 主库会在内存中用专门的replication buffer 记录RDB文件生成后收到的所有写操作。</p><h4 id="第三阶段-主库发送新写命令给从库"><a href="#第三阶段-主库发送新写命令给从库" class="headerlink" title="第三阶段: 主库发送新写命令给从库"></a>第三阶段: 主库发送新写命令给从库</h4><p>主库把replication buffer发送给从库。</p><h4 id="主从级联模式"><a href="#主从级联模式" class="headerlink" title="主从级联模式"></a>主从级联模式</h4><p><code>主-从</code>模式下, 如果从库数量很多, 那么会给主库带来压力。所以可以考虑<code>主-从-从</code>模式。</p><h3 id="主从库间网络断了怎么办？"><a href="#主从库间网络断了怎么办？" class="headerlink" title="主从库间网络断了怎么办？"></a>主从库间网络断了怎么办？</h3><p>在Redis2.8之前, 在网络断了后, 主从会重新进行一次全量复制。</p><p>在Redis2.8开始, 网络断了后, 会先采用增量复制的方式继续同步。</p><p>repl_backlog_buffer是一个环形缓冲区, 主库会记录自己写到的位置, 从库则会记录自己已经读到的位置。<br>大小一般设置为：<code>(主库写入命令速度*操作大小 - 主从库间网络传输命令速度*操作大小) * 2</code></p><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>哨兵主要负责三个任务: 监控、选主、通知。</p><ul><li>监控: 哨兵进程在运行时, 周期性地给所有的主从库发送PING命令, 检测他们是否仍然在线运行。<br>如果再规定的时间内没有响应PING命令, 那么会标记为”下线状态”。如果主库下线的话, 就会开始自动切换主库的流程。</li><li>选主: 主库挂了后, 哨兵就需要从很多歌从库里, 选择一个新主库。选主的过程, 又分为 <code>筛选</code> 和 <code>打分</code>两个阶段。<ul><li>筛选。不在线的从库需要筛选出去。网络总是段连的从库需要筛选出去。(根据配置项down-after-milliseconds * 10判定。<br>down-after-milliseconds是主从库锻炼的最大连接超时时间。如果断连次数超过10次, 那么说明这个从库的网络状况不好)</li><li>打分。打分会经过多轮, 如果某一轮出现了得分最高的从库, 那么那么它就是主库了, 选主过程到此结束。否则继续下一轮选举。<ul><li>第一轮: 优先级最高的从库的最高分。</li><li>第二轮: 和旧主库同步程度最接近的从库得最高分。</li><li>第三轮: ID号小的从库得高分。</li></ul></li></ul></li><li>通知: 选好新的主库后, 哨兵会把新主库的链接信息发送给其他从库, 让他们执行eplicaof命令,<br>和新主库建立连接, 并进行数据复制。同时, 哨兵会把新主库的链接信息通知给客户端, 让他们把请求操作发送到新主库上。</li></ul><p>在redis哨兵集群中, 有N/2 + 1 个哨兵认为主库下线了(这个值由redis管理员设定), 才能最终判定为”客观下线”, 进行新主库的选举。</p><p>在redis主库中, 有一个名为”<strong>sentinel</strong>:hello”的<code>pub/sub</code>频道, 哨兵把自己的IP和端口发布到<br>“<strong>sentinel</strong>:hello”频道上, 其他哨兵订阅了这个频道后就可以获取到该哨兵的IP和端口, 以此来建立连接, 组成哨兵集群。</p><p>哨兵除了彼此之间建立连接形成集群意外, 还需要和从库建立连接, 对主从库都进行心跳判断。</p><p>哨兵通过给主库发送INFO命令来获取从库的信息。</p><p>本质上说, 哨兵就是一个运行在特定模式下的Redis实例, 只不过它并不服务其他请求操作, 只是完成监控、选主和通知的任务。<br>每个哨兵实例也提供pub/sub机制, 客户端可以从哨兵订阅消息。哨兵提供的消息大致有一下几个：</p><table><thead><tr><th>事件</th><th>相关频道</th></tr></thead><tbody><tr><td>实例进入”主观下线”装填</td><td>+sdown</td></tr><tr><td>实例退出”主观下线”装填</td><td>-sdown</td></tr><tr><td>实例进入”客观下线”装填</td><td>+odown</td></tr><tr><td>实例退出”客观下线”装填</td><td>-0down</td></tr><tr><td>哨兵发送SLAVEOF命令重新配置从库</td><td>+slave-reconf-sent</td></tr><tr><td>从库配置了新主库, 但尚未进行同步</td><td>+slave-reconf-inprog</td></tr><tr><td>从库配置了新主库, 且和新主库完成同步</td><td>+slave-reconf-done</td></tr><tr><td>新主库切换</td><td>+switch-master</td></tr></tbody></table><p>客户端可以订阅这些消息来获取相信的信息。比如订阅所有所实例的客观下线状态的事件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE +odown</span><br></pre></td></tr></tbody></table></figure><p>或者订阅所有的事件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE *</span><br></pre></td></tr></tbody></table></figure><p>当哨兵把新主库选择出来后, 客户端就会看到下面的switch-master事件, 这样就会知道新主库的地址和端口了。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</span><br></pre></td></tr></tbody></table></figure><p>leader哨兵才可以执行主从切换的过程。哨兵leader选举需要满足2个条件：<br>    1. 拿到半数以上的票<br>    1. 拿到的票数大于等于哨兵配置文件中的quorum值</p><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><h3 id="横向扩容？纵向扩容？"><a href="#横向扩容？纵向扩容？" class="headerlink" title="横向扩容？纵向扩容？"></a>横向扩容？纵向扩容？</h3><p>纵向机器成本高, 也会导致单实例存储的数据过多, RDB有压力</p><h3 id="Redis-Cluster是什么"><a href="#Redis-Cluster是什么" class="headerlink" title="Redis Cluster是什么"></a>Redis Cluster是什么</h3><p>采用哈希槽(Hash Slot)来处理数据和实例之间的映射关系。<br>在Redis Cluster方案中, 一个切片集群共有16384个哈希槽，<br>这些哈希槽类似于数据分区, 每个键值对都会根据key映射到一个哈希槽中。</p><h3 id="槽是怎么计算的"><a href="#槽是怎么计算的" class="headerlink" title="槽是怎么计算的"></a>槽是怎么计算的</h3><p>按照CRC16算法计算一个16bit的值, 然后再由这个16bit值对16384取模, 得到哈希槽的编号。</p><p>如果集群中有N个实例, 那么实例上的槽的个数为16384/N个。</p><p>也可以使用<code>cluster addslots</code>命令指定每个实例上的哈希槽个数。如果总共设置了5个槽, 那么槽的编号就是<code>CRC16(key)%5</code>。</p><h3 id="客户端怎么知道哪个key在哪个实例上？"><a href="#客户端怎么知道哪个key在哪个实例上？" class="headerlink" title="客户端怎么知道哪个key在哪个实例上？"></a>客户端怎么知道哪个key在哪个实例上？</h3><p>Redis会把自己的槽信息发送给和它相连的其他信息, 这样每个实例就有所有的槽信息了。</p><p>当客户端访问任意一个实例时, 便可以把槽的信息缓存在本地, 这样就知道对应的key应该发给哪个实例了。</p><h3 id="在集群中-实例和哈希槽的对应关系发生变化了怎么办？"><a href="#在集群中-实例和哈希槽的对应关系发生变化了怎么办？" class="headerlink" title="在集群中, 实例和哈希槽的对应关系发生变化了怎么办？"></a>在集群中, 实例和哈希槽的对应关系发生变化了怎么办？</h3><p>Redis Cluster提供了一种重定向机制: 当客户端给一个Redis实例发送数据读写操作时, 如果这个实力上并没有对应的数据,<br>这个实例就会给客户端返回MOVED重定向命令, 其中就带着对应实例的IP和端口</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) MOVED 13320 172.16.19.5:5379</span><br></pre></td></tr></tbody></table></figure><p>如果slot正好再迁移中, 那么可能会返回ASK命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) ASK 13320 172.16.19.5:5379</span><br></pre></td></tr></tbody></table></figure><h3 id="为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？"><a href="#为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？" class="headerlink" title="为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？"></a>为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？</h3><p>不行。</p><ol><li>表的量会随着key增加而增大</li><li>这个表只存一份的话会有单点问题, 如果部署多份的话会有一致性问题, 提高了系统复杂度。</li><li>CRC类似于hash, 可以使哈希结果更加分散</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>极客时间, 《Redis核心技术与实战》</li><li>《Redis 5 设计与源码分析》</li><li>《Redis设计与实现》</li><li><a href="https://blog.csdn.net/qingyangcc123/article/details/107644885">解析Redis网络模型的源码</a></li><li><a href="https://www.cnblogs.com/lizhimin123/p/10197431.html">Redis源码剖析（十一）–AOF持久化</a></li><li><a href="https://blog.csdn.net/bruce128/article/details/104579288">redis aof持久化源码分析</a></li><li><a href="https://blog.csdn.net/hangbo216/article/details/68925644">redis aof持久化的源码分析</a></li><li><a href="https://blog.csdn.net/Namcodream521/article/details/83032615">kqueue的用法</a></li><li><a href="https://my.oschina.net/xilidou/blog/4381183">Redis 中的事件驱动模型</a></li><li><a href="https://blog.csdn.net/qq_35181209/article/details/80353299">Redis时间事件源码解析</a></li><li><a href="https://redisbook.readthedocs.io/en/latest/internal/ae.html">Redis事件</a></li><li><a href="https://www.dazhuanlan.com/2019/12/16/5df6dec38a0fa/">Redis 客户端与服务器连接流程实例</a></li><li><a href="https://blog.csdn.net/fishmai/article/details/78515355">深入浅出 Redis client/server交互流程</a></li><li><a href="https://blog.csdn.net/qq_32095699/article/details/99689830">Linux – fork() 写时拷贝（copy-on-write）</a></li><li><a href="https://vlambda.com/wz_5hpcZyGM8O2.html">Redis的RDB持久化</a></li><li><a href="https://zhuanlan.zhihu.com/p/27441342">Java NIO(7): Epoll版的Selector</a></li><li><a href="https://juejin.cn/post/6916042914837561351">石杉的架构笔记一杯茶的功夫，上手Redis持久化机制</a></li><li><a href="https://jiekun.dev/posts/redis-tio-implementation/">https://jiekun.dev/posts/redis-tio-implementation/</a></li><li><a href="https://jiekun.dev/posts/2020-03-14-redis-6-0-acl%E5%9F%BA%E4%BA%8Ebitmap%E5%AE%9E%E7%8E%B0/">https://jiekun.dev/posts/2020-03-14-redis-6-0-acl%E5%9F%BA%E4%BA%8Ebitmap%E5%AE%9E%E7%8E%B0/</a></li><li><a href="https://jiekun.dev/posts/2020-01-31-redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/">https://jiekun.dev/posts/2020-01-31-redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/</a></li><li><a href="https://blog.csdn.net/cywosp/article/details/8767327">https://blog.csdn.net/cywosp/article/details/8767327</a></li><li><a href="https://blog.csdn.net/xinghuah/article/details/80487525">https://blog.csdn.net/xinghuah/article/details/80487525</a></li><li><a href="https://www.iocoder.cn/Redis/good-collection/">https://www.iocoder.cn/Redis/good-collection/</a></li><li><a href="https://draveness.me/whys-the-design-redis-single-thread/">https://draveness.me/whys-the-design-redis-single-thread/</a></li><li><a href="https://draveness.me/whys-the-design-redis-bgsave-fork/">https://draveness.me/whys-the-design-redis-bgsave-fork/</a></li><li><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li><a href="https://segmentfault.com/a/1190000038398292">一个基于运气的数据结构, zset</a></li><li><a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></li><li><a href="https://zhenghe-md.github.io/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/">https://zhenghe-md.github.io/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C">300分钟吃透分布式缓存</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98">Redis 核心原理与实战</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9137897.html">深入学习Redis（2）：持久化</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html">深入学习Redis（3）：主从复制</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9609938.html">深入学习Redis（4）：哨兵</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9853040.html">深入学习Redis（5）：集群</a></li><li><a href="https://www.cnblogs.com/javastack/p/12848446.html">Redis 到底是单线程还是多线程？我要吊打面试官！</a></li><li><a href="https://blog.csdn.net/weixin_45583158/article/details/100143587">正式支持多线程！Redis 6.0与老版性能对比评测</a></li><li><a href="https://zhuanlan.zhihu.com/p/80335611">为什么Redis集群有16384个槽</a></li><li><a href="https://zhuanlan.zhihu.com/p/145186839">你了解 Redis 的三种集群模式吗？</a></li><li><a href="https://juejin.cn/post/6844903663362637832">深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</a></li><li><a href="https://blog.csdn.net/u013378306/article/details/109707279">redis 主从同步过程原理 以及 RDB/AOF/混合模式 持久化日志</a></li><li><a href="https://zhuanlan.zhihu.com/p/41228196">P2P 网络核心技术：Gossip 协议</a></li><li><a href="https://www.kancloud.cn/digest/redis-code">Redis源码分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> redis </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go内存管理</title>
      <link href="/golang-memory-allocator/"/>
      <url>/golang-memory-allocator/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h2><h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><blockquote><p>runtime.mspan 是 Go 语言内存管理的基本单元</p></blockquote><blockquote><p>每个 runtime.mspan 都管理 npages 个大小为 8KB 的页</p></blockquote><blockquote><p>runtime.spanClass 是 runtime.mspan 的跨度类，它决定了内存管理单元中存储的对象大小和个数</p></blockquote><h3 id="线程缓存-mcache"><a href="#线程缓存-mcache" class="headerlink" title="线程缓存(mcache)"></a>线程缓存(mcache)</h3><blockquote><p>runtime.mcache 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 68 * 2 个 runtime.mspan，这些内存管理单元都存储在结构体的 alloc 字段中。其中68个scan, 另外68个noscan</p></blockquote><h3 id="中心缓存-mcentral"><a href="#中心缓存-mcentral" class="headerlink" title="中心缓存(mcentral)"></a>中心缓存(mcentral)</h3><blockquote><p>runtime.mcentral 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁</p></blockquote><blockquote><p>每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p></blockquote><h3 id="页堆-mheap"><a href="#页堆-mheap" class="headerlink" title="页堆(mheap)"></a>页堆(mheap)</h3><blockquote><p>runtime.mheap 是内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 central，另一个是管理堆区内存区域的 arenas 以及相关字段。</p></blockquote><blockquote><p>页堆中包含一个长度为 136 的 runtime.mcentral 数组，其中 68 个为跨度类需要 scan 的中心缓存，另外的 68 个是 noscan 的中心缓存</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">内存分配器</a></li><li><a href="https://www.bilibili.com/video/BV1Ja4y1i7AF/?spm_id_from=333.788.recommend_more_video.7">【Golang】这个内存对齐呀！？</a></li><li><a href="https://studygolang.com/articles/22652?fr=sidebar">从源码讲解 golang 内存分配</a></li><li><a href="https://www.luozhiyun.com/archives/434">详解Go中内存分配源码实现</a></li><li><a href="https://deepu.tech/memory-management-in-golang/">🚀 Visualizing memory management in Golang</a></li><li><a href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a></li><li><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc : Thread-Caching Malloc</a></li><li><a href="http://legendtkl.com/2017/04/02/golang-alloc/">Golang 内存管理</a></li><li><a href="https://zhuanlan.zhihu.com/p/93838586">带你领略Go源码的魅力—-Go内存原理详解</a></li><li><a href="https://golang.org/ref/mem">The Go Memory Model</a></li><li><a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">Go: Memory Management and Allocation</a></li><li><a href="https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/">可视化Go内存管理</a></li><li><a href="https://tonybai.com/2020/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/">图解Go内存分配器</a></li><li><a href="https://qiankunli.github.io/2020/11/22/go_mm.html">go 内存管理</a></li><li><a href="https://zhuanlan.zhihu.com/p/323915446">Go runtime剖析系列（一）：内存管理</a></li><li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.0.html">内存管理</a></li><li><a href="https://github.com/LeoYang90/Golang-Internal-Notes/blob/master/Go%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md">Go 内存管理</a></li><li><a href="https://talkgo.org/t/topic/103">go夜读-图解 Go 之内存对齐</a></li><li><a href="https://bbs.huaweicloud.com/blogs/254749">栈的运行速度比堆快？ 栈堆详解</a></li></ol><p><a href="https://xie.infoq.cn/article/ee1d2416d884b229dfe57bbcc">https://xie.infoq.cn/article/ee1d2416d884b229dfe57bbcc</a></p><p><a href="https://juejin.cn/post/6844904005215207432">https://juejin.cn/post/6844904005215207432</a></p><p><a href="https://juejin.cn/post/6844903795739082760">https://juejin.cn/post/6844903795739082760</a></p><p><a href="https://cloud.tencent.com/developer/article/1771373">https://cloud.tencent.com/developer/article/1771373</a></p><p><a href="https://www.jianshu.com/p/1f0a0ec2d661">https://www.jianshu.com/p/1f0a0ec2d661</a></p><p><a href="https://www.techug.com/post/manual-memory-management-in-go.html">https://www.techug.com/post/manual-memory-management-in-go.html</a></p><p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/">https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/</a></p><p><a href="https://wudaijun.com/2019/09/go-performance-optimization/">https://wudaijun.com/2019/09/go-performance-optimization/</a></p><p><a href="https://gfw.go101.org/article/memory-block.html">https://gfw.go101.org/article/memory-block.html</a></p><p><a href="http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html">http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html</a></p><p><a href="https://ilifes.com/golang/memory-alloc/">https://ilifes.com/golang/memory-alloc/</a></p><p><a href="https://www.diglog.com/story/1035817.html">https://www.diglog.com/story/1035817.html</a></p><p><a href="https://gohalo.me/post/golang-concept-memory-management-module-introduce.html">https://gohalo.me/post/golang-concept-memory-management-module-introduce.html</a></p><p><a href="http://www.djaigo.com/golang/golang-nei-cun-guan-li.html">http://www.djaigo.com/golang/golang-nei-cun-guan-li.html</a></p><p><a href="https://omen.ltd/archives/12/">https://omen.ltd/archives/12/</a></p><p><a href="https://www.happyxhw.cn/memory/">https://www.happyxhw.cn/memory/</a></p><p><a href="http://www.zhangfuguan.top/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">http://www.zhangfuguan.top/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html</a></p><p><a href="https://mp.weixin.qq.com/s/rydO2JK-r8JjG9v_Uy7gXg">https://mp.weixin.qq.com/s/rydO2JK-r8JjG9v_Uy7gXg</a></p><p><a href="https://andblog.cn/?p=2887">https://andblog.cn/?p=2887</a></p><p><a href="https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.1-memory_alloc.md">https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.1-memory_alloc.md</a></p><p><a href="https://www.youtube.com/watch?v=ZMZpH4yT7M0">Understanding Allocations: the Stack and the Heap - GopherCon SG 2019</a><br><a href="youtube.com/watch?v=3CR4UNMK_Is">GopherCon UK 2018: Andre Carvalho - Understanding Go’s Memory Allocator</a><br><a href="https://www.youtube.com/watch?v=NzhH0p32fMY">The Go Memory Model: GoSF Meetup, 1/23/19</a></p><p><a href="https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/">https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/</a></p><p><a href="https://tonybai.com/2020/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/">https://tonybai.com/2020/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md">https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md</a></p><p><a href="https://docs.google.com/document/d/1un-Jn47yByHL7I0aVIP_uVCMxjdM5mpelJhiKlIqxkE/edit#heading=h.bvezjdnoi4no">https://docs.google.com/document/d/1un-Jn47yByHL7I0aVIP_uVCMxjdM5mpelJhiKlIqxkE/edit#heading=h.bvezjdnoi4no</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5">https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5</a></p><p><a href="https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub">https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang栈空间管理</title>
      <link href="/golang-stack/"/>
      <url>/golang-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h2><p>不同架构下, 默认线程栈的大小不同。在x86_64架构下, 默认栈大小为2MB</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 悬挂指针示例</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">dangling_pointer</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>当 dangling_pointer 函数返回后，它的本地变量会被编译器回收，调用方获取的是危险的悬挂指针，我们不确定当前指针指向的值是否合法时，这种问题在大型项目中是比较难以发现和定位的。</p></blockquote><blockquote><p>Go 语言的逃逸分析遵循以下两个不变性：</p><ol><li>指向栈对象的指针不能存在于堆中 (一旦函数返回后函数栈会被回收，该指针指向的值就不再合法)</li><li>指向栈对象的指针不能在栈对象回收后存活(栈底部有一个指针指向了栈顶, 那么当栈顶的函数释放后, 栈底的指针不再合法)</li></ol></blockquote><h2 id="栈内存空间"><a href="#栈内存空间" class="headerlink" title="栈内存空间"></a>栈内存空间</h2><blockquote><p>Goroutine 的栈内存空间和栈结构也在早期几个版本中发生过一些变化：</p><ol><li>v1.0 ~ v1.1 — 最小栈内存空间为 4KB</li><li>v1.2 — 将最小栈内存提升到了 8KB(其目的是为了减轻分段栈中的栈分裂对程序的性能影响)</li><li>v1.3 — 使用连续栈替换之前版本的分段栈</li><li>v1.4 — 将最小栈内存降低到了 2KB</li></ol></blockquote><h2 id="分段栈"><a href="#分段栈" class="headerlink" title="分段栈"></a>分段栈</h2><blockquote><p>当 Goroutine 调用的函数层级或者局部变量需要的越来越多时，运行时会调用 runtime.morestack:go1.2 和 runtime.newstack:go1.2 创建一个新的栈空间，这些栈空间虽然不连续，但是当前 Goroutine 的多个栈空间会以链表的形式串联起来，运行时会通过指针找到连续的栈片段</p></blockquote><blockquote><p>分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：</p><ol><li>如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）；</li><li>一旦 Goroutine 使用的内存越过了分段栈的扩缩容阈值，运行时会触发栈的扩容和缩容，带来额外的工作量；</li></ol></blockquote><h2 id="连续栈"><a href="#连续栈" class="headerlink" title="连续栈"></a>连续栈</h2><blockquote><p>分段栈的扩张操作是在另一个栈上进行的，这两个栈彼此没有连续。这种设计的缺陷很容易破坏缓存的局部性原理，从而降低程序的运行时性能</p></blockquote><blockquote><p>使用连续栈而不是分段栈的目的是，利用局部性优势提升执行速度，原理是CPU读取地址时会将相邻的内存读取到访问速度比内存快的多级cache中，地址连续性越好，L1、L2、L3 cache命中率越高，速度也就越快</p></blockquote><blockquote><p>栈的收缩是垃圾回收的过程中实现的．当检测到栈只使用了不到1/4时，栈缩小为原来的1/2</p></blockquote><h2 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h2><ol><li><a href="https://tonybai.com/2014/11/05/how-stacks-are-handled-in-go/">Go语言是如何处理栈的</a></li><li><a href="http://www.huamo.online/2019/06/25/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6goroutine%E6%A0%88/">深入研究goroutine栈</a></li><li><a href="https://segmentfault.com/a/1190000023340324">函数——go世界中的一等公民</a></li><li><a href="https://www.jianshu.com/p/7ec9acca6480">深入理解golang 的栈</a></li></ol><p><a href="https://kirk91.github.io/posts/2d571d09/">https://kirk91.github.io/posts/2d571d09/</a></p><p><a href="https://www.luozhiyun.com/archives/513">https://www.luozhiyun.com/archives/513</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/</a></p><p><a href="https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.3-escape_analysis.md">https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.3-escape_analysis.md</a></p><ol><li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html">深入解析go-连续栈</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-innodb</title>
      <link href="/mysql-innodb/"/>
      <url>/mysql-innodb/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><ol><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>缓冲组件</li><li>插件式存储引擎</li><li>物理文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/mysql-arch.jpg" alt="mysql体系结构"></p><h3 id="InnoDB特点概述"><a href="#InnoDB特点概述" class="headerlink" title="InnoDB特点概述"></a>InnoDB特点概述</h3><ol><li>主要面向<code>OLTP</code></li><li>通过使用<code>MVCC</code>来获得高并发性, 提供一致性非锁定读, 并实现了<code>SQL</code>标准的4中隔离级别</li><li>支持行锁</li><li>使用<code>next-key locking</code>的策略来避免幻读(<code>phantom</code>)现象</li><li>提供了插入缓冲(<code>insert buffer</code>)、二次写(<code>double write</code>)、自适应哈希索引(<code>adptive hash index</code>)、预读(<code>read ahead</code>)等高性能和高可用功能</li></ol><h2 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h2><p>InnoDB线程:<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/innodb-arch.jpg" alt="InnoDB体系结构"><br>InnoDB内存:<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/innodb-mem.jpg" alt="InnoDB内存数据对象"></p><h3 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h3><h3 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h3><p>主要负责IO请求的回调处理, 有4类<code>IO Thread</code>:</p><ul><li><code>write</code>: 默认<code>innodb_write_io_threads = 4</code>, 即默认是4线程</li><li><code>read</code>: 默认<code>innodb_read_io_threads = 4</code></li><li><code>insert buffer thread</code></li><li><code>log IO thread</code></li></ul><h3 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h3><p>从<code>InnoDB 1.1 版本</code>开始, <code>purge</code>操作可以独立到单独的线程中进行。用于回收<code>undo</code>页。</p><h3 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h3><p>在<code>InnoDB 1.2版本</code>中引入的(之前在<code>Master Thread</code>中)。用于脏页的刷新操作。</p><h3 id="缓冲池-Buffer-Pool"><a href="#缓冲池-Buffer-Pool" class="headerlink" title="缓冲池(Buffer Pool)"></a>缓冲池(Buffer Pool)</h3><p>缓冲池的设计目的是为了协调CPU速度与磁盘速度的鸿沟。 </p><p>把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</p><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><ol><li>Buffer Pool中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是16KB</li><li>为了管理Pool中的缓存页，Innodb为每一个缓存页创建了一些所谓的控制信息。–控制信息也是写在页上面的。</li><li>控制信息包括该页所属的表空间编号、页号、缓存页在Buffer Pool中的地址、链表节点信息、一些锁信息以及LSN信息。</li><li>因为每个缓存页对应的控制信息占用的内存大小是相同的，因此从buffer pool中分配一块内存专门记录控制信息–控制块</li><li>控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边</li><li>控制块和缓存页之间是有碎片的–当然如果大小分配合理也有可能没有碎片。</li><li>每个控制块大约占用缓存页大小的5%,innodb_buffer_pool_size设置的大小并不包含控制块的大小，也就是说InnoDB在为Buffer Pool向操作系统申请连续的内存空间时，这片连续的内存空间一般会比innodb_buffer_pool_size的值大5%左右</li></ol><p><a href="https://gist.github.com/jboner/2841832">时延参考数据</a> :</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Latency Comparison Numbers (~2012)</span><br><span class="line">----------------------------------</span><br><span class="line">L1 cache reference                           0.5 ns</span><br><span class="line">Branch mispredict                            5   ns</span><br><span class="line">L2 cache reference                           7   ns                      14x L1 cache</span><br><span class="line">Mutex lock/unlock                           25   ns</span><br><span class="line">Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache</span><br><span class="line">Compress 1K bytes with Zippy             3,000   ns        3 us</span><br><span class="line">Send 1K bytes over 1 Gbps network       10,000   ns       10 us</span><br><span class="line">Read 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD</span><br><span class="line">Read 1 MB sequentially from memory     250,000   ns      250 us</span><br><span class="line">Round trip within same datacenter      500,000   ns      500 us</span><br><span class="line">Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory</span><br><span class="line">Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip</span><br><span class="line">Read 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">1 ns = 10^-9 seconds</span><br><span class="line">1 us = 10^-6 seconds = 1,000 ns</span><br><span class="line">1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</span><br></pre></td></tr></tbody></table></figure><h4 id="缓冲池对读写操作的关系"><a href="#缓冲池对读写操作的关系" class="headerlink" title="缓冲池对读写操作的关系"></a>缓冲池对读写操作的关系</h4><ul><li>读: 判断要读取的页是否在缓冲池中, 如果不在则会将页加载到缓冲池中, 然后再从缓冲池中读取。</li><li>写: 对于数据库中页的修改操作, 首先修改在缓冲池中的页, 然后再通过<code>CheckPoint</code>机制刷新回磁盘上。</li></ul><h4 id="缓冲池中的数据页类型"><a href="#缓冲池中的数据页类型" class="headerlink" title="缓冲池中的数据页类型"></a>缓冲池中的数据页类型</h4><ul><li>索引页</li><li>数据页</li><li>undo页</li><li>插入缓冲(<code>insert buffer</code>)</li><li>自适应哈希索引(<code>adaptive hash index</code>)</li><li>InnoDB存储的锁信息</li><li>数据字典信息(<code>data dictionary</code>)</li></ul><h4 id="LRU-List"><a href="#LRU-List" class="headerlink" title="LRU List"></a>LRU List</h4><p>InnoDB存储引擎中, 缓冲池中页的大小默认为16KB, 是通过使用LRU算法来进行管理的。</p><p>InnoDB存储引擎对传统的LRU算法做了<code>midpoint insertion strategy</code>优化, 不会直接插入到列表的头部, 而是会插入到<code>midpoint</code>位置。默认情况下该位置在LRU列表的5/8处(63%)。</p><p><code>midpoint insertion strategy</code> 可以防止热点数据被移出LRU列表。比如全表扫描的时候, 很可能新的页并不会频繁使用, 显然这些页替换调LRU的热点数据是不明智的。</p><h4 id="Free-List"><a href="#Free-List" class="headerlink" title="Free List"></a>Free List</h4><p><code>LRU List</code>新增节点的时候, 会先从<code>Free list</code>申请, 如果<code>Free list</code>里没有可用的空闲页, 那么<code>LRU list</code>将淘汰末尾的页, 然后将该也空间分配给新的页。</p><h4 id="Flush-List"><a href="#Flush-List" class="headerlink" title="Flush List"></a>Flush List</h4><p><code>LRU list</code>列表中的页被修改后, 这些脏页就会被维护到<code>Flush list</code>中, 数据库会根据<code>CheckPoint</code>机制将脏页刷新回磁盘。</p><h3 id="重做日志缓冲-redo-log-buffer"><a href="#重做日志缓冲-redo-log-buffer" class="headerlink" title="重做日志缓冲(redo log buffer)"></a>重做日志缓冲(redo log buffer)</h3><p>默认大小为<code>innodb_log_buffer_size = 838869</code>, 即 8MB。</p><p>通常情况下, 8MB足以满足大部分的应用。因为重做日志在下列三种情况会刷到外部磁盘的重做日志文件中:</p><ul><li>Master Thread每秒会将<code>redo log buffer</code>刷到 <code>redo log file</code>中</li><li>每个事物提交时会将<code>redo log buffer</code>刷到 <code>redo log file</code>中</li><li>当重做日志缓冲池剩余空间小于1/2时会将<code>redo log buffer</code>刷到 <code>redo log file</code>中</li></ul><h3 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h3><p>对一些数据结构本身的内存进行分配时, 需要重额外的内存池进行申请。例如缓冲池中的帧缓冲(<code>frame buffer</code>)还有缓冲控制对象(<code>buffer control block</code>)等。</p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p>InnoDB存储引擎内部, 有两种<code>Checkpoint</code>, 分别是<code>Sharp Checkpoint</code>, <code>Fuzzy Checkpoint</code>。<code>Checkpoint</code>技术的目的是解决一下几个问题:</p><ol><li>缩短数据库的恢复时间: 当数据库发生宕机时, 数据库不需要重做所有的日志, 只需对<code>Checkpoint</code>之后的重做日志进行恢复, 这样就大大缩短了恢复的时间。</li><li>缓冲池不够时, 将脏页刷新到磁盘: 当缓冲池不够用时, 根据LRU算法会淘汰掉一些页, 若淘汰的页为脏页, 那么需要强制执行<code>CheckPoint</code>, 将脏页刷回磁盘。</li><li>重做日志不可用时, 刷新脏页: 重做日志的空间是有限的, 是循环使用的。当被覆盖的时候, 需要强制执行<code>Checkpoint</code>将脏页刷新到磁盘。</li></ol><h4 id="Sharp-Checkpoint"><a href="#Sharp-Checkpoint" class="headerlink" title="Sharp Checkpoint"></a>Sharp Checkpoint</h4><p><code>Sharp Checkpoint</code>会将所有的脏页刷新回磁盘。发生在数据库关闭的时候。</p><h4 id="Fuzzy-Checkpoint"><a href="#Fuzzy-Checkpoint" class="headerlink" title="Fuzzy Checkpoint"></a>Fuzzy Checkpoint</h4><p>InnoDB存储引擎内部使用<code>Fuzzy Checkpoint</code>进行页的刷新, 即只刷新一部分脏页。分为以下几种情况:</p><ol><li>Master Thread Checkpoint: 在 <code>Master Thread</code> 的 <code>flush loop</code> 中, 每秒或每十秒触发。</li><li>FLUSH_LRU_LIST checkpoint: <code>Page Cleaner</code>线程会检查LRU列表中是否有足够的可用空闲页, 默认为<code>innodb_lru_scan_depth = 1024</code>。倘若如果没有1024个可用空闲页, 那么会将LRU列表尾端的页移除, 如果这些页中有脏页, 那么需要进行<code>Checkpoint</code></li><li>Async/Sync Flush Checkpoint: 当重做日志文件不可用的时候, 会触发。主要是为了保证重做日志的循环使用。</li><li>Dirty Page too much Checkpoint: 当脏页数太多的时候, 会导致InnoDB存储引擎强制进行<code>Checkpoint</code>. 默认是当超过<code>innodb_max_dirty_pages_pct = 75</code>的时候, 即脏页数量占据75%的时候, 会强制进行<code>Checkpoint</code></li></ol><h2 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h2><h3 id="插入缓冲-Insert-Buffer"><a href="#插入缓冲-Insert-Buffer" class="headerlink" title="插入缓冲(Insert Buffer)"></a>插入缓冲(Insert Buffer)</h3><p>目的: 为了提升辅助索引的插入性能</p><h4 id="插入缓冲的作用"><a href="#插入缓冲的作用" class="headerlink" title="插入缓冲的作用"></a>插入缓冲的作用</h4><p>辅助索引的插入是较为离散的, 为了避免更新辅助索引的时候要频繁地离散读取数据,<br>所以InnoDB存储引擎设计了<code>Insert Buffer</code>, 对于非聚集索引的插入或更新操作, 不是每次都直接插入到索引页中,<br>而是先判断插入的非聚集索引页是否在缓冲池中, 若存在, 则直接插入;<br>若不存在, 那么先放入到一个<code>Insert Buffer</code>对象中, 假装已经插入到叶子节点, 再以一定的频率合并(merge)到辅助索引叶子节点中。 </p><h4 id="插入缓冲的缺点"><a href="#插入缓冲的缺点" class="headerlink" title="插入缓冲的缺点"></a>插入缓冲的缺点</h4><ol><li>如果数据库发生了宕机, 有大量的<code>Insert Buffer</code>没有合并到实际的非聚集索引中去, 那么此时恢复可能需要很长的时间, 极端情况下甚至要几个小时。</li><li>在写密集的情况下, 插入缓冲会占用过多的缓冲池内存(innodb_buffer_pool), 默认最大可以占用到1/2的缓冲池内存。</li></ol><h4 id="使用插入缓冲需要满足的条件"><a href="#使用插入缓冲需要满足的条件" class="headerlink" title="使用插入缓冲需要满足的条件"></a>使用插入缓冲需要满足的条件</h4><p><code>Insert Buffer</code>的使用需要同时满足一下两个条件:</p><ul><li>索引是辅助索引(secondary index)</li><li>索引不是唯一(unique)的</li></ul><h4 id="唯一索引为什么不能使用插入缓冲"><a href="#唯一索引为什么不能使用插入缓冲" class="headerlink" title="唯一索引为什么不能使用插入缓冲"></a>唯一索引为什么不能使用插入缓冲</h4><p>为什么不能是唯一的? 如果要校验唯一性, 那么就还是需要进行读取加载对应的数据页才能进行判断。</p><h4 id="变更缓冲-Change-buffer"><a href="#变更缓冲-Change-buffer" class="headerlink" title="变更缓冲(Change buffer)"></a>变更缓冲(Change buffer)</h4><p>InnoDB从1.0.x版本开始引入了<code>Change Buffer</code>, 可以看做是<code>Insert Buffer</code>的升级版, 支持<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>。</p><p>InnoDB1.2.x版本开始可以通过参数<code>innodb_change_buffer_max_size</code>来控制<code>Change Buffer</code>最大使用内存的数量, 默认值为25, 表示最多使用1/4的缓冲池内存空间。</p><h4 id="Insert-Change-Buffer的实现"><a href="#Insert-Change-Buffer的实现" class="headerlink" title="Insert/Change Buffer的实现"></a>Insert/Change Buffer的实现</h4><p><code>Insert/Change Buffer</code>的数据结构是一颗<code>B+树</code>, 且全局只有一颗<code>Insert/Change Buffer B+树</code>。</p><h4 id="什么时候合并-Merge-Insert-Buffer"><a href="#什么时候合并-Merge-Insert-Buffer" class="headerlink" title="什么时候合并(Merge) Insert Buffer"></a>什么时候合并(Merge) Insert Buffer</h4><ul><li>辅助索引页被读取到缓冲池时: 例如在执行SELECT查询时, 此时需要将辅助索引页读取到缓冲池中, 此时需要检查<code>Insert Buffer Bitmap</code>页, 确认该索引是否有记录存放于<code>Insert Buffer B+树</code>中。如果有, 则将<code>Insert Buffer B+树</code>中的记录插入到该辅助索引页中。</li><li><code>Insert Buffer Bitmap</code> 页追踪到该辅助索引页已无可用空间时: <code>Insert Buffer Bitmap</code>里会记录可用空间, 若检测到插入记录后不够1/32页的剩余空间, 则会强制进行一次合并操作。</li><li><code>Master Thread</code>: 每秒或每10秒进行一次<code>Merge Insert Buffer</code>的操作。会随机地选择<code>Insert Buffer B+树</code>中连续的几页, 进行merge。</li></ul><h3 id="两次写-double-write"><a href="#两次写-double-write" class="headerlink" title="两次写(double write)"></a>两次写(double write)</h3><p>目的: 提供数据页的可靠性</p><p>可能某个16KB的页只写了前4KB时, 数据库发生了宕机, 这种情况被称为部分写失效(<code>partial page write</code>)。</p><h3 id="自适应哈希索引-Adaptive-Hash-Index-AHI"><a href="#自适应哈希索引-Adaptive-Hash-Index-AHI" class="headerlink" title="自适应哈希索引(Adaptive Hash Index, AHI)"></a>自适应哈希索引(Adaptive Hash Index, AHI)</h3><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><h3 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h3><h2 id="Mysql数据库的文件"><a href="#Mysql数据库的文件" class="headerlink" title="Mysql数据库的文件"></a>Mysql数据库的文件</h2><h2 id="InnoDB存储引擎表的文件"><a href="#InnoDB存储引擎表的文件" class="headerlink" title="InnoDB存储引擎表的文件"></a>InnoDB存储引擎表的文件</h2><h2 id="InnoDB存储引擎表的逻辑存储及实现"><a href="#InnoDB存储引擎表的逻辑存储及实现" class="headerlink" title="InnoDB存储引擎表的逻辑存储及实现"></a>InnoDB存储引擎表的逻辑存储及实现</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h3><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="MySQL表级锁"><a href="#MySQL表级锁" class="headerlink" title="MySQL表级锁"></a>MySQL表级锁</h3><p><code>MySQL</code>里面表级别的锁有两种:</p><ol><li>表锁: InnoDB支持行锁, 所以一般不使用<code>lock tables</code>命令来控制并发。</li><li>元数据锁(meta data lock, MDL): 公平的读写锁。 不需要显示使用, 在访问一个表的时候会被自动加上。MDL的作用是保证读写的正确性, 防止查询的过程中表结构发生变更。</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="主从复制的步骤"><a href="#主从复制的步骤" class="headerlink" title="主从复制的步骤"></a>主从复制的步骤</h3><ol><li><code>master</code>把数据更改记录到<code>binlog</code>中</li><li><code>slave</code>把主服务器的<code>binlog</code>复制到自己的中继日志(<code>relay log</code>)中</li><li><code>slave</code>重做中继日志中的日志, 把更改应用到自己的数据库上, 以达到最终一致性。</li></ol><h3 id="主从复制工作原理"><a href="#主从复制工作原理" class="headerlink" title="主从复制工作原理"></a>主从复制工作原理</h3><ol><li><code>slave</code>的I/O线程负责读取<code>master</code>的<code>binlog</code>, 并将其保存为<code>relay log</code></li><li><code>slave</code>的SQL线程负责执行中继日志</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/mysql-slave-binlog.jpg" alt="mysql主从复制"></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h3><ol><li>大量请求阻塞: 在高并发场景下，大量请求都需要操作数据库，导致连接数不够了，请求处于阻塞状态。</li><li>存储出现问题: 业务量剧增，单库数据量越来越大，给存储造成巨大压力。</li></ol><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>分表：是为了解决由于单张表数据量多大，而导致查询慢的问题。大致三、四千万行数据就得拆分，不过具体还是得看每一行的数据量大小，有些字段都很小的可能支持更多行数，有些字段大的可能一千万就顶不住了。</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>分库：是为了解决服务器资源受单机限制，顶不住高并发访问的问题，把请求分配到多台服务器上，降低服务器压力。</p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><h3 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h3><p>大众点评订单</p><p>通过UserId后四位mod 32分到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表</p><p>按2^n拆分(类比HashMap里的2^n。对比一下一致性哈希。)</p><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/sharding-hash-table.jpg" alt="查询切分-分库"><br>将ID和库的Mapping关系记录在一个单独的库中。</p><p>优点：ID和库的Mapping算法可以随意更改。<br>缺点：引入额外的单点。</p><h3 id="范围路由"><a href="#范围路由" class="headerlink" title="范围路由"></a>范围路由</h3><p>比如按照时间区间或ID区间来切分。</p><p>优点：单表大小可控，天然水平扩展。不需要做数据迁移<br>缺点：有热点问题, 一段时间的数据会集中到一张表上。无法解决集中写入瓶颈的问题。</p><h3 id="range-hash"><a href="#range-hash" class="headerlink" title="range+hash"></a>range+hash</h3><p>微信红包场景可用</p><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/sharding-range-hash.jpg" alt="range+hash分库分表"></p><p>snowflake模式下要注意, 每毫秒第一个id要随机生成, 例如leaf, 否则hash分库会不均匀。</p><h3 id="分库分表带来的复杂性"><a href="#分库分表带来的复杂性" class="headerlink" title="分库分表带来的复杂性"></a>分库分表带来的复杂性</h3><h4 id="跨库关联查询"><a href="#跨库关联查询" class="headerlink" title="跨库关联查询"></a>跨库关联查询</h4><p>在单库未拆分表之前，我们可以很方便使用 join 操作关联多张表查询数据，但是经过分库分表后两张表可能都不在一个数据库中，如何使用 join 呢？</p><p>有几种方案可以解决：</p><ol><li>字段冗余：把需要关联的字段放入主表中，避免 join 操作；</li><li>数据抽象：通过ETL等将数据汇合聚集，生成新的表；</li><li>全局表：比如一些基础表可以在每个数据库中都放一份；</li><li>应用层组装：将基础数据查出来，通过应用程序计算组装；</li></ol><h4 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>单数据库可以用本地事务搞定，使用多数据库就只能通过分布式事务解决了。<br>常用解决方案有：基于可靠消息（MQ）的解决方案、两阶段事务提交、柔性事务等。</p><h4 id="排序、分页、函数计算问题"><a href="#排序、分页、函数计算问题" class="headerlink" title="排序、分页、函数计算问题"></a>排序、分页、函数计算问题</h4><p>在使用 SQL 时 order by， limit 等关键字需要特殊处理，一般来说采用分片的思路：</p><p>先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终得到结果。</p><h4 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h4><p>如果使用 Mysql 数据库在单库单表可以使用 id 自增作为主键，分库分表了之后就不行了，会出现id 重复。<br>常用的分布式 ID 解决方案有：</p><ol><li>UUID</li><li>基于数据库自增单独维护一张 ID表</li><li>号段模式</li><li>Redis</li><li>雪花算法（Snowflake）</li><li>百度uid-generator</li><li>美团Leaf</li><li>滴滴Tinyid</li></ol><h4 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h4><p>分库分表之后可能会面临从多个数据库或多个子表中获取数据，一般的解决思路有：客户端适配和代理层适配。<br>业界常用的中间件有：</p><ol><li>shardingsphere（前身 sharding-jdbc）</li><li>Mycat</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.youtube.com/watch?v=x5tqzyf0zrk&amp;list=PLSE8ODhjZXjbohkNBWQs_otTrBTrjyohi&amp;index=9">cmu讲lock/latch 例子比较详细</a></li><li><a href="https://www.zhihu.com/question/30272728">数据库事务原子性、一致性是怎样实现的？</a></li><li>《Mysql技术内幕 InnoDB存储引擎》</li><li><a href="https://www.cnblogs.com/geaozhang/p/7241744.html">InnoDB关键特性之double write</a></li><li><a href="https://juejin.cn/post/6890830002162499598">InnoDB 重要特性 Double Write 实现原理</a></li><li><a href="https://blog.csdn.net/synchronizing/article/details/109025093">mysql 为何需要Double Write？有redo log还不够吗？</a></li><li><a href="https://www.zhihu.com/question/59729819/answer/284180647">MySQL：数据库宕机以后恢复的过程？如何保证事务的ACID特性？</a></li><li><a href="https://blog.jcole.us/innodb/">On learning InnoDB: A journey to the core</a></li><li><a href="http://blog.itpub.net/15498/viewspace-2153760/">innodb_support_xa的作用</a></li><li><a href="https://www.cnblogs.com/AlmostWasteTime/p/10330151.html">MySQL学习（二）索引与锁</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL 8.0 Reference Manual-InnoDB Locking</a></li><li><a href="https://www.cnblogs.com/cchust/p/4255499.html">Innodb行锁源码学习(一)</a></li><li><a href="https://zhuanlan.zhihu.com/p/139489272">MySQL Innodb行锁剖析</a></li><li><a href="https://github.com/hedengcheng/tech/blob/master/database/MySQL/MySQL%20%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90.pdf">MySQL 加锁处理分析</a></li><li><a href="https://cloud.tencent.com/developer/article/1441250">分库分表？如何做到永不迁移数据和避免热点？</a></li><li><a href="http://mysql.taobao.org/monthly/2018/03/01/">MySQL · 源码分析 · InnoDB的read view，回滚段和purge过程简介</a></li><li><a href="https://blog.csdn.net/huangzhilin2015/article/details/115195777">MySQL总结–MVCC（read view和undo log）</a></li><li><a href="https://blog.csdn.net/qq_42651904/article/details/110622818">从ReadView深入理解MySql MVCC原理</a></li><li><a href="https://www.jianshu.com/p/8845ddca3b23">MVCC多版本并发控制</a></li><li><a href="https://blog.csdn.net/h2604396739/article/details/100280126">mysql Innodb_buffer_pool的原理</a></li><li><a href="https://www.jianshu.com/p/c53c8ab650b5">MySQL幻读</a></li><li><a href="https://mp.weixin.qq.com/s/850S0HZ5SlwSFuJK9BLgrw">InnoDB MVCC何时创建read view</a></li><li><a href="https://tech.meituan.com/2018/12/06/binlog-dw.html">美团DB数据同步到数据仓库的架构与实践</a></li><li><a href="https://www.jianshu.com/p/a053abfd52c4">面试题：我们为什么要分库分表？</a></li><li><a href="https://www.cnblogs.com/lizo/p/8035036.html">数据库分库分表事务解决方案</a></li><li><a href="https://tech.meituan.com/2016/12/19/mtddl.html">MTDDL——美团点评分布式数据访问层中间件</a></li><li><a href="https://zhuanlan.zhihu.com/p/24036067">大众点评订单系统分库分表实践</a></li><li><a href="http://blog.51yip.com/mysql/949.html">mysql分表的3种方法</a></li><li><a href="https://zhuanlan.zhihu.com/p/84224499">MySQL分库分表方案</a></li><li><a href="https://www.zhihu.com/question/459955079">在面试时被问到，为什么MySQL数据库数据量大了要进行分库分表？</a></li><li><a href="https://segmentfault.com/a/1190000023914691">数据库分库分表解决方案汇总</a></li><li><a href="https://zhuanlan.zhihu.com/p/355302417">MYSQL单表数据达2000万性能严重下降，为什么？</a></li><li><a href="https://crossoverjie.top/2019/04/16/framework-design/sharding-db/">一次分表踩坑实践的探讨</a></li><li><a href="https://crossoverjie.top/2019/06/13/framework-design/sharding-db-02/">分表后需要注意的二三事</a></li><li><a href="https://crossoverjie.top/2019/07/24/framework-design/sharding-db-03/">一次难得的分库分表实践</a></li><li><a href="https://www.infoq.cn/article/zmlcbpihothwjeqmzd4i">数据库分库分表基础和实践</a></li><li><a href="https://www.jianshu.com/p/7d8e2c02b07b">数据库分库分表思路 （1）（数据库分区、分表、分库、分片）</a></li><li><a href="https://www.kancloud.cn/digest/innodb-zerok">innodb源码分析</a></li><li><a href="https://www.kancloud.cn/digest/mysqlsummary/132848">Mysql数据库常用分库和分表方式</a></li><li><a href="https://mp.weixin.qq.com/s/1ZWOLPV4fCqi2EebU_C9YA">MySQL索引前世今生</a></li><li><a href="https://segmentfault.com/a/1190000014810628">MySQL 2PC &amp; Group Commit</a></li><li><a href="https://www.cnblogs.com/kismetv/p/10331633.html">深入学习MySQL事务：ACID特性的实现原理</a></li><li><a href="http://mysql.taobao.org/monthly/2015/05/01/">MySQL · 引擎特性 · InnoDB redo log漫游</a></li><li><a href="http://mysql.taobao.org/monthly/2015/04/01/">MySQL · 引擎特性 · InnoDB undo log 漫游</a></li><li><a href="http://mysql.taobao.org/monthly/2015/06/01/">MySQL · 引擎特性 · InnoDB 崩溃恢复过程</a></li></ol><p><a href="https://zhuanlan.zhihu.com/p/341317422">https://zhuanlan.zhihu.com/p/341317422</a></p><p><a href="https://zhuanlan.zhihu.com/p/343226202">https://zhuanlan.zhihu.com/p/343226202</a></p><p><a href="http://kernelmaker.github.io/InnoDB_redo_log">http://kernelmaker.github.io/InnoDB_redo_log</a></p><p><a href="http://mysql.taobao.org/monthly/">http://mysql.taobao.org/monthly/</a></p><p><a href="https://toutiao.io/posts/2cvy58/preview">https://toutiao.io/posts/2cvy58/preview</a></p><p><a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html">https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
            <tag> innodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go sysmon</title>
      <link href="/go-sysmon/"/>
      <url>/go-sysmon/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote><p>系统监控是 Go 语言运行时的重要组成部分，它会每隔一段时间检查 Go 语言运行时，确保程序没有进入异常状态</p></blockquote><blockquote><p>系统监控的触发时间就会稳定在 10ms</p></blockquote><h2 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h2><h2 id="运行计时器"><a href="#运行计时器" class="headerlink" title="运行计时器"></a>运行计时器</h2><p>获取下一个需要被触发的计时器</p><blockquote><p>当前调度器需要执行垃圾回收或者所有处理器都处于闲置状态时，如果没有需要触发的计时器，那么系统监控可以暂时陷入休眠</p></blockquote><h2 id="轮循网络"><a href="#轮循网络" class="headerlink" title="轮循网络"></a>轮循网络</h2><p>获取需要处理的到期文件描述符</p><blockquote><p>如果上一次轮询网络已经过去了 10ms，那么系统监控还会在循环中轮询网络，检查是否有待执行的文件描述符</p></blockquote><h2 id="抢占处理器"><a href="#抢占处理器" class="headerlink" title="抢占处理器"></a>抢占处理器</h2><p>抢占运行时间较长的或者处于系统调用的 Goroutine</p><blockquote><ol><li>当处理器处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，我们会通过 runtime.preemptone 抢占当前处理器；</li><li>当处理器处于 _Psyscall 状态时，在满足以下两种情况下会调用 runtime.handoffp 让出处理器的使用权：</li><li>当处理器的运行队列不为空或者不存在空闲处理器时2；</li><li>当系统调用时间超过了 10ms 时3；</li></ol></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>在满足条件时触发垃圾收集回收内存</p><blockquote><p>如果需要触发垃圾回收，我们会将用于垃圾回收的 Goroutine 加入全局队列，让调度器选择合适的处理器去执行。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/sysmon/">https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/sysmon/</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</a></p><p><a href="https://gocn.vip/topics/9884">https://gocn.vip/topics/9884</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang channel</title>
      <link href="/golang-channel/"/>
      <url>/golang-channel/</url>
      
        <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 循环列表元素个数. chan 中已经接收但还没被取走的元素的个数，函数 len 可以返回这个字段的值</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 循环队列的大小, cap函数可以返回这个字段的值</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 循环队列的指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// chan中元素的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 是否已close</span></span><br><span class="line">    elemtype *_type         <span class="comment">// chan中元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// send在buffer中的索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>           <span class="comment">// recv在buffer中的索引</span></span><br><span class="line">    recvq    waitq          <span class="comment">// receiver的等待队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// sender的等待队列 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 互拆锁</span></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>sendq和recvq的类型是waitq的结构体：</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> {</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>waitq里面连接的是一个sudog双向链表，保存的是等待的goroutine 。整个chan的图例大概是这样：<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/golang-channel/golang-chan-sudog.png" alt="channel内部结构-整体"></p><p>我们通过汇编结果也可以查看到make(chan int)这句代码会调用到runtime的makechan函数中：</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxAlign是8，那么maxAlign-1的二进制就是111，然后和int(unsafe.Sizeof(hchan{}))取与就是取它的低三位，hchanSize就得到的是8的整数倍，做对齐使用。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    maxAlign  = <span class="number">8</span></span><br><span class="line">    hchanSize = unsafe.Sizeof(hchan{}) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan{}))&amp;(maxAlign<span class="number">-1</span>)) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan {</span><br><span class="line">    elem := t.elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略去检查代码</span></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//计算需要分配的buf空间</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> {</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> {</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>: <span class="comment">// 缓冲区所需大小为 0，那么在为 hchan 分配内存时，只需要分配 sizeof(hchan) 大小的内存</span></span><br><span class="line">        <span class="comment">// chan的size或者元素的size是0，不必创建buf</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// Race detector </span></span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>: <span class="comment">// 缓冲区所需大小不为 0，而且数据类型不是指针，那么就分配连续的内存</span></span><br><span class="line">        <span class="comment">// 元素不是指针，分配一块连续的内存给hchan数据结构和buf</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// 表示hchan后面在内存里紧跟着就是buf</span></span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 缓冲区所需大小不为 0，而且数据类型包含指针，那么就不使用add的方式让hchan和buf放在一起了，而是单独的为buf申请一块内存</span></span><br><span class="line">        <span class="comment">// 元素包含指针，那么单独分配buf</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素大小、类型、容量都记录下来</span></span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>chansend 函数是在编译器解析到 c &lt;- x 这样的代码的时候插入的，本质上就是把一个用户元素投递到 hchan 的 ringbuffer 中。chansend 调用的时候，一般用户会遇到两种情况：</p><p>投递成功，非常顺利，正常返回<br>投递受阻，该函数阻塞，goroutine 切走</p><p>接下来，我们看下 chansend 究竟是做了什么。</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line">    <span class="comment">// channel 的所有操作，都在互斥锁下；</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 如果投递的目标是已经关闭的 channel，那么直接 panic；</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> {</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 场景一：性能最好的场景，我投递的元素刚好有人在等着（那我直接给他就完了）;</span></span><br><span class="line">    <span class="comment">// 调用的是 send 函数，这个函数后面详细阐述，其实非常简单，递增 sendx, recvx 的索引，然后直接把元素给到等他的人，并且唤醒他；</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> {</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { unlock(&amp;c.lock) }, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 场景二：ringbuffer 还有空间，那么把元素放好，递增索引，就可以返回了；</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz {</span><br><span class="line">        <span class="comment">// 复制，赋值好元素；</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 递增索引</span></span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="comment">// 回环空间</span></span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz {</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 递增元素个数</span></span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断是否需要阻塞？如果是非阻塞的，那么就直接解锁返回了，如果是阻塞的场景，那么就会走到下面的逻辑哦；</span></span><br><span class="line">    <span class="comment">// chan &lt;- 和 &lt;-chan 的场景，都是 true，但是会有其他场景这里是 false，可以提前想下？</span></span><br><span class="line">    <span class="keyword">if</span> !block {</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 代码走到这里，说明都是因为条件不满足，要阻塞当前 goroutine，所以做的事情本质上就是保留好通知路径，等待条件满足，会在这个地方唤醒；</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 把 goroutine 相关的线索结构入队，等待条件满足的唤醒；</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// goroutine 切走，让出 cpu 执行权限；</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这就是某些人唤醒该 goroutine 了。</span></span><br><span class="line">    <span class="comment">// 下面就是唤醒之后的逻辑了；</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting {</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 做一些资源的释放和环境的清理。</span></span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> {</span><br><span class="line">        <span class="comment">// 做一些校验</span></span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> {</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    }</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译器在遇到 &lt;-c 和 v, ok := &lt;-c  的语句的时候，会换成对应的 chanrecv1 ，chanrecv2 函数，这两个函数本质上都是一个简单的封装，元素出队的实现函数是 chanrecv ，我们详细分析下这个函数。block 都等于 true（同样的，只有 select 的时候，block 才会是 false ）</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) {</span><br><span class="line"><span class="comment">// 特殊场景：非阻塞模式，并且没有元素的场景直接就可以返回了，这个分支是快速分支，下面的代码都是在锁内的；</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下所有的逻辑都在锁内；</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">if</span> raceenabled {</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">}</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> {</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：如果发现有个人（sender）正在等着别人接收，那么刚刚好，直接把它的元素给到我们这里就好了；</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> {</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { unlock(&amp;c.lock) }, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：ringbuffer 还有空间存元素，那么下面就可以把元素放到 ringbuffer 放好，递增索引，就可以返回了；</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> {</span><br><span class="line"><span class="comment">// 存元素</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> {</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">}</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line"><span class="comment">// 递增索引</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz {</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">}</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码到这说明 ringbuffer 空间是不够的，后面学会要做两个事情，是否需要阻塞？</span></span><br><span class="line"><span class="comment">// 如果 block 为 false ，那么直接就退出了，返回对应的返回值；</span></span><br><span class="line"><span class="keyword">if</span> !block {</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这就说明要阻塞等待了，下面唯一要做的就是给阻塞做准备（准备好唤醒的条件）</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// goroutine 作为一个 waiter 入队列，等待条件满足之后，从这个队列里取出来唤醒；</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line"><span class="comment">// goroutine 切走，交出 cpu 执行权限</span></span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是被唤醒的开始的地方；</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting {</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 下面做一些资源的清理</span></span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《极客时间-Go并发编程实战》</li><li><a href="https://www.luozhiyun.com/archives/427">多图详解Go中的Channel源码</a></li><li><a href="https://talkgo.org/t/topic/75">channel &amp; select 源码分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/101063277">Go语言的有缓冲channel和无缓冲channel</a></li><li><a href="https://speakerdeck.com/kavya719/understanding-channels">https://speakerdeck.com/kavya719/understanding-channels</a></li><li><a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8">https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8</a></li><li><a href="https://blog.csdn.net/weixin_30257433/article/details/101833959">https://blog.csdn.net/weixin_30257433/article/details/101833959</a></li><li><a href="https://segmentfault.com/a/1190000017958702">https://segmentfault.com/a/1190000017958702</a></li><li><a href="https://juejin.cn/post/6895738899348324359">https://juejin.cn/post/6895738899348324359</a></li></ol><p><a href="http://legendtkl.com/2017/08/06/golang-channel-implement/">http://legendtkl.com/2017/08/06/golang-channel-implement/</a></p><p><a href="https://www.pengrl.com/p/21027/">https://www.pengrl.com/p/21027/</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 并发</title>
      <link href="/golang-concurrency/"/>
      <url>/golang-concurrency/</url>
      
        <content type="html"><![CDATA[<h2 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h2><h3 id="示例-用mutex解决并发计数问题"><a href="#示例-用mutex解决并发计数问题" class="headerlink" title="示例: 用mutex解决并发计数问题"></a>示例: 用mutex解决并发计数问题</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> {</span><br><span class="line">sync.Mutex</span><br><span class="line">Count <span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() {</span><br><span class="line">c.Lock()</span><br><span class="line">c.Count++</span><br><span class="line">c.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Incr10k = <span class="function"><span class="keyword">func</span><span class="params">(counter *Counter, wg *sync.WaitGroup)</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ {</span><br><span class="line">counter.Incr()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> counter Counter</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Incr10k(&amp;counter, &amp;wg)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(counter.Count)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Mutex实现"><a href="#Mutex实现" class="headerlink" title="Mutex实现"></a>Mutex实现</h3><h4 id="go最早期的Mutex实现-最简单的实现"><a href="#go最早期的Mutex实现-最简单的实现" class="headerlink" title="go最早期的Mutex实现: 最简单的实现"></a>go最早期的Mutex实现: 最简单的实现</h4><p>key: 0表示锁未被持有。1表示锁被持有, 没有等待者。值为n表示锁被持有, 还有n-1个等待着。<br>sema: 等待着队列使用的信号量。当锁被占用的时候, 抢锁失败的线程会调用semacquire(), 使用信号量将自己休眠。等锁释放的时候, 信号量将会唤醒队列的头部等待着。</p><ol><li>公平: 排队等待</li><li>不可重入</li><li>其他协程可以释放锁</li></ol><h4 id="go-0-x版本-新增乐观抢锁"><a href="#go-0-x版本-新增乐观抢锁" class="headerlink" title="go 0.x版本: 新增乐观抢锁"></a>go 0.x版本: 新增乐观抢锁</h4><p>非公平: 新协程可能会抢, 而不是每次都在FIFO的队列头部获取</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema <span class="type">uint32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>state这一个字段包含多个意义:</p><ul><li>最高30位表示阻塞等待的waiter数量</li><li>接下来的1位表示是否有唤醒的goroutine. (这个标识有什么作用? 因为被唤醒的goroutine没抢到锁后, 不需要使waiter++, 所以需要区分是否是被唤醒的。)</li><li>最低1位表示这个锁是否被持有</li></ul><p>获取锁的过程:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// Fast path: 幸运case，能够直接获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        old := m.state</span><br><span class="line">        <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态加锁</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift <span class="comment">//等待者数量加一</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> awoke {</span><br><span class="line">            <span class="comment">// goroutine是被唤醒的，</span></span><br><span class="line">            <span class="comment">// 新状态清除唤醒标志</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {<span class="comment">//设置新状态</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> { <span class="comment">// 锁原状态未加锁</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            }</span><br><span class="line">            runtime.Semacquire(&amp;m.sema) <span class="comment">// 请求信号量</span></span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>释放锁的过程:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() {</span><br><span class="line">    <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) <span class="comment">//去掉锁标志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> { <span class="comment">//本来就没有加锁</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    old := <span class="built_in">new</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> { <span class="comment">// 没有等待者，或者有唤醒的waiter，或者锁原来已加锁</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken <span class="comment">// 新状态，准备唤醒goroutine，并设置唤醒标志</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">            runtime.Semrelease(&amp;m.sema)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        old = m.state</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="go-1-5版本-新增自旋抢锁"><a href="#go-1-5版本-新增自旋抢锁" class="headerlink" title="go 1.5版本: 新增自旋抢锁"></a>go 1.5版本: 新增自旋抢锁</h4><p>非公平: 新协程可能会抢, 而不是每次都在FIFO的队列头部获取。而且相比于之前的版本, 对比新来请求锁的goroutine和被唤醒的goroutine, 都会自旋地多尝试几次</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// Fast path: 幸运之路，正好获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    iter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> { <span class="comment">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁</span></span><br><span class="line">        old := m.state <span class="comment">// 先保存当前锁的状态</span></span><br><span class="line">        <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态设置加锁标志</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> { <span class="comment">// 锁还没被释放</span></span><br><span class="line">            <span class="keyword">if</span> runtime_canSpin(iter) { <span class="comment">// 还可以自旋</span></span><br><span class="line">                <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {</span><br><span class="line">                    <span class="comment">// 将锁的唤醒标记置为1，表示已经有醒着的线程正在获取锁，Unlock的时候便无需唤醒新的线程                    </span></span><br><span class="line">                    awoke = <span class="literal">true</span></span><br><span class="line">                }</span><br><span class="line">                runtime_doSpin()</span><br><span class="line">                iter++</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// 自旋，再次尝试请求锁</span></span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> awoke { <span class="comment">// 唤醒状态</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> {</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> { <span class="comment">// 旧状态锁已释放，新状态成功持有了锁，直接返回</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            }</span><br><span class="line">            runtime_Semacquire(&amp;m.sema) <span class="comment">// 阻塞等待</span></span><br><span class="line">            awoke = <span class="literal">true</span> <span class="comment">// 被唤醒</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="go-1-9版本-新增饥饿模式"><a href="#go-1-9版本-新增饥饿模式" class="headerlink" title="go 1.9版本: 新增饥饿模式"></a>go 1.9版本: 新增饥饿模式</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema <span class="type">uint32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>state这一个字段包含多个意义:</p><ul><li>最高29位表示阻塞等待的waiter数量</li><li>接下来的1位表示饥饿标记(此版本新增)</li><li>再接下来的1位表示是否有唤醒的goroutine</li><li>最低1位表示这个锁是否被持有</li></ul><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// Fast path: 幸运之路，一下就获取到了锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争</span></span><br><span class="line">    m.lockSlow()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() {</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">    starving := <span class="literal">false</span> <span class="comment">// 此goroutine的饥饿标记</span></span><br><span class="line">    awoke := <span class="literal">false</span> <span class="comment">// 唤醒标记</span></span><br><span class="line">    iter := <span class="number">0</span> <span class="comment">// 自旋次数</span></span><br><span class="line">    old := m.state <span class="comment">// 当前的锁的状态</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="comment">// 锁是非饥饿状态，锁还没被释放，尝试自旋</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {</span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state <span class="comment">// 再次获取锁的状态，之后会检查是否锁被释放了</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked <span class="comment">// 非饥饿状态，加锁</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">// waiter数量加1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving <span class="comment">// 设置饥饿状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不管是获得了锁还是进入休眠，我们都需要清除 mutexWoken 标记</span></span><br><span class="line">        <span class="keyword">if</span> awoke {</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> {</span><br><span class="line">                throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 成功设置新状态</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">            <span class="comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> {</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 处理饥饿状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果以前就在队列里面，加入到队列头</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> {</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 唤醒之后检查锁是否应该处于饥饿状态</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> {</span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> {</span><br><span class="line">                    throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 加锁并且将waiter数减1（加mutexLocked是加锁，减1&lt;&lt;mutexWaiterShift是减少waiter）</span></span><br><span class="line">                delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> { <span class="comment">// 当前goroutine等待还没超过1毫秒, 且没有其他的waiter </span></span><br><span class="line">                    delta -= mutexStarving <span class="comment">// 最后一个waiter或者已经不饥饿了，清除饥饿标记</span></span><br><span class="line">                    <span class="comment">// （同理，减mutexStarving是清楚饥饿标记）</span></span><br><span class="line">                }</span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            }</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            old = m.state</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() {</span><br><span class="line">    <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> {</span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> {</span><br><span class="line">        throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> {</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> {</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">            old = m.state</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="读写锁RWMutex"><a href="#读写锁RWMutex" class="headerlink" title="读写锁RWMutex"></a>读写锁RWMutex</h2><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> {</span><br><span class="line">  w           Mutex   <span class="comment">// 互斥锁解决多个writer的竞争。为 writer 的竞争锁而设计。</span></span><br><span class="line">  writerSem   <span class="type">uint32</span>  <span class="comment">// writer信号量</span></span><br><span class="line">  readerSem   <span class="type">uint32</span>  <span class="comment">// reader信号量</span></span><br><span class="line">  readerCount <span class="type">int32</span>   <span class="comment">// reader的数量。记录当前 reader 的数量（以及是否有 writer 竞争锁）, rw.readerCount是负值的时候，意味着此时有writer等待请求锁</span></span><br><span class="line">  readerWait  <span class="type">int32</span>   <span class="comment">// writer等待完成的reader的数量。记录 writer 请求锁时需要等待 read 完成的 reader 的数量；</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span> <span class="comment">// 最大的 reader 数量</span></span><br></pre></td></tr></tbody></table></figure><p>读读相关操作</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() {</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() {</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> {</span><br><span class="line">        rw.rUnlockSlow(r) <span class="comment">// 有等待的writer</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) {</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// 最后一个reader了，writer终于有机会获得锁了</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>写锁相关操作</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// 首先解决其他writer竞争问题</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    <span class="comment">// 反转readerCount，告诉reader有writer竞争锁</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    <span class="comment">// 如果当前有reader持有锁，那么需要等待</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> {</span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() {</span><br><span class="line">    <span class="comment">// 告诉reader没有活跃的writer了</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒阻塞的reader们</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ {</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 释放内部的互斥锁</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>结构体定义:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span></span><br><span class="line">    noCopy noCopy</span><br><span class="line">    <span class="comment">// 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数</span></span><br><span class="line">    <span class="comment">// 另外32bit是用作信号量的</span></span><br><span class="line">    <span class="comment">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法</span></span><br><span class="line">    <span class="comment">// 总之，会找到对齐的那64bit作为state，其余的32bit做信号量</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> state() (statep *<span class="type">uint64</span>, semap *<span class="type">uint32</span>) {</span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><p>Add操作:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) {</span><br><span class="line">  <span class="comment">// statep表示wait数和计数值</span></span><br><span class="line">  <span class="comment">// 低32位表示wait数，高32位表示计数值</span></span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="comment">// uint64(delta)&lt;&lt;32 将delta左移32位</span></span><br><span class="line">    <span class="comment">// 因为高32位表示计数值，所以将delta左移32，增加到技术上</span></span><br><span class="line">   state := atomic.AddUint64(statep, <span class="type">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 当前计数值</span></span><br><span class="line">   v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 阻塞在检查点的wait数</span></span><br><span class="line">   w := <span class="type">uint32</span>(state)</span><br><span class="line">   <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> {</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量</span></span><br><span class="line">    <span class="comment">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter</span></span><br><span class="line">   *statep = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- {</span><br><span class="line">      runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Done操作:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done方法实际就是计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() { </span><br><span class="line">  wg.Add(<span class="number">-1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Wait操作:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() {</span><br><span class="line">   <span class="comment">// statep表示wait数和计数值</span></span><br><span class="line">   <span class="comment">// 低32位表示wait数，高32位表示计数值</span></span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="keyword">for</span> {</span><br><span class="line">      state := atomic.LoadUint64(statep)</span><br><span class="line">      <span class="comment">// 将state右移32位，表示当前计数值</span></span><br><span class="line">      v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">      <span class="comment">// w表示waiter等待值</span></span><br><span class="line">      w := <span class="type">uint32</span>(state)</span><br><span class="line">      <span class="keyword">if</span> v == <span class="number">0</span> {</span><br><span class="line">         <span class="comment">// 如果当前计数值为零，表示当前子goroutine已全部执行完毕，则直接返回</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 否则使用原子操作将state值加一。</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) {</span><br><span class="line">         <span class="comment">// 阻塞休眠等待</span></span><br><span class="line">         runtime_Semacquire(semap)</span><br><span class="line">         <span class="comment">// 被唤醒，不再阻塞，返回</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《极客时间-Go并发编程实战课》</li><li><a href="https://colobu.com/2018/12/18/dive-into-sync-mutex/">sync.mutex 源代码分析</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#mutex">draveness-同步原语与锁</a></li><li><a href="https://www.cnblogs.com/luozhiyun/p/14157542.html">多图详解Go的互斥锁Mutex</a></li><li><a href="https://www.wangt.cc/2021/01/go%e4%b8%ad%e7%94%b1waitgroup%e5%bc%95%e5%8f%91%e5%af%b9%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90%e6%80%9d%e8%80%83/">Go中由WaitGroup引发对内存对齐思考</a></li></ol><p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/">https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/</a></p><p><a href="https://draveness.me/whys-the-design-communication-shared-memory/">https://draveness.me/whys-the-design-communication-shared-memory/</a></p><p><a href="https://blog.csdn.net/fwhezfwhez/article/details/82900498">https://blog.csdn.net/fwhezfwhez/article/details/82900498</a></p><p><a href="https://studygolang.com/articles/29935?fr=sidebar">https://studygolang.com/articles/29935?fr=sidebar</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http</title>
      <link href="/http/"/>
      <url>/http/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI网络分层模型"><a href="#OSI网络分层模型" class="headerlink" title="OSI网络分层模型"></a>OSI网络分层模型</h2><p>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；<br>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；<br>第三层：网络层，相当于 TCP/IP 里的网际层；<br>第四层：传输层，相当于 TCP/IP 里的传输层；<br>第五层：会话层，维护网络中的连接状态，即保持会话和同步；<br>第六层：表示层，把数据转换为合适、可理解的语法和语义；<br>第七层：应用层，面向具体的应用传输数据。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；<br>2××：成功，报文已经收到并被正确处理；<br>3××：重定向，资源位置发生变动，需要客户端重新发送请求；<br>4××：客户端错误，请求报文有误，服务器无法处理；<br>5××：服务器错误，服务器在处理请求时内部发生了错误。</p><h2 id="http0-9"><a href="#http0-9" class="headerlink" title="http0.9"></a>http0.9</h2><blockquote><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p></blockquote><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><blockquote><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。</p></blockquote><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></tbody></table></figure><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><blockquote><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>服务器发送完毕，就关闭TCP连接。</p></blockquote><h2 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h2><blockquote><p>引入了POST命令和HEAD命令</p></blockquote><h3 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h3><p>每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></tbody></table></figure><h3 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h3><ol><li>响应第一行是”协议版本 + 状态码（status code） + 状态描述”。</li><li>接下来是”头信息 + 以一个空行结尾表示”头信息部分结束”（\r\n）</li><li>最后是”数据”部分</li></ol><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p></blockquote><blockquote><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。</p></blockquote><blockquote><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p></blockquote><h2 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h2><h3 id="新增命令"><a href="#新增命令" class="headerlink" title="新增命令"></a>新增命令</h3><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><blockquote><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p></blockquote><blockquote><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p></blockquote><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br></pre></td></tr></tbody></table></figure><blockquote><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p></blockquote><h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><blockquote><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p></blockquote><blockquote><p>管道机制: 在同一个tcp连接中, 在等待上一个请求响应的同时，发送下一个请求。但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p></blockquote><h3 id="Content-Length字段"><a href="#Content-Length字段" class="headerlink" title="Content-Length字段"></a>Content-Length字段</h3><blockquote><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p></blockquote><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>3495</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p></blockquote><blockquote><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p></blockquote><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br></pre></td></tr></tbody></table></figure><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p></blockquote><blockquote><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p></blockquote><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><blockquote><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><ol><li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>篡改风险（tampering）：第三方可以修改通信内容。</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ol></blockquote><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><blockquote><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p></blockquote><h4 id="如何保证公钥不被篡改？"><a href="#如何保证公钥不被篡改？" class="headerlink" title="如何保证公钥不被篡改？"></a>如何保证公钥不被篡改？</h4><blockquote><p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></blockquote><h4 id="公钥加密计算量太大，如何减少耗用的时间？"><a href="#公钥加密计算量太大，如何减少耗用的时间？" class="headerlink" title="公钥加密计算量太大，如何减少耗用的时间？"></a>公钥加密计算量太大，如何减少耗用的时间？</h4><p>解决方法: 用非对称加密来传输对称加密的秘钥</p><h4 id="SSL-TLS基本过程"><a href="#SSL-TLS基本过程" class="headerlink" title="SSL/TLS基本过程"></a>SSL/TLS基本过程</h4><ol><li>客户端向服务器端索要并验证公钥。</li><li>双方协商生成”对话密钥”。</li><li>双方采用”对话密钥”进行加密通信。</li></ol><h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><h3 id="二进制化协议"><a href="#二进制化协议" class="headerlink" title="二进制化协议"></a>二进制化协议</h3><blockquote><p>HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p></blockquote><blockquote><p>二进制协议的一个好处是，可以定义额外的帧。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p></blockquote><h3 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h3><blockquote><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p></blockquote><blockquote><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p></blockquote><h3 id="取消数据流"><a href="#取消数据流" class="headerlink" title="取消数据流"></a>取消数据流</h3><blockquote><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p></blockquote><h3 id="定义优先级"><a href="#定义优先级" class="headerlink" title="定义优先级"></a>定义优先级</h3><blockquote><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p></blockquote><h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><blockquote><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p></blockquote><blockquote><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p></blockquote><h4 id="HPACK"><a href="#HPACK" class="headerlink" title="HPACK"></a>HPACK</h4><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><blockquote><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p></blockquote><blockquote><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p></blockquote><h2 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《极客时间-透视HTTP协议》</li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%85%A8%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">全解网络协议</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a></li><li><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li><li><a href="https://coolshell.cn/articles/19840.html">HTTP的前世今生</a></li><li><a href="https://draveness.me/whys-the-design-https-latency/">为什么 HTTPS 需要 7 次握手以及 9 倍时延</a></li><li><a href="https://my.oschina.net/u/4482993/blog/4631144">小林coding-20 张图解，为什么 HTTP3.0 使用 UDP 协议？</a></li></ol><p><a href="https://imququ.com/post/series.html">https://imququ.com/post/series.html</a></p><p><a href="https://coolshell.cn/articles/19840.html">https://coolshell.cn/articles/19840.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/68024390">https://zhuanlan.zhihu.com/p/68024390</a></p><p><a href="https://zhuanlan.zhihu.com/p/89471776">https://zhuanlan.zhihu.com/p/89471776</a></p><p><a href="https://imququ.com/post/series.html">https://imququ.com/post/series.html</a></p><p><a href="https://httpwg.org/specs/rfc7541.html">https://httpwg.org/specs/rfc7541.html</a></p><p><a href="https://httpwg.org/specs/rfc7540.html">https://httpwg.org/specs/rfc7540.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/143464334">https://zhuanlan.zhihu.com/p/143464334</a></p><p><a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html">https://quicwg.org/base-drafts/draft-ietf-quic-http.html</a></p><p><a href="https://www.chromium.org/quic">https://www.chromium.org/quic</a></p><p><a href="https://zhuanlan.zhihu.com/p/40595473">https://zhuanlan.zhihu.com/p/40595473</a></p><p><a href="https://tools.ietf.org/html/rfc5246">https://tools.ietf.org/html/rfc5246</a></p>]]></content>
      
      
      <categories>
          
          <category> internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
            <tag> http </tag>
            
            <tag> ssl/tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp</title>
      <link href="/tcp/"/>
      <url>/tcp/</url>
      
        <content type="html"><![CDATA[<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-con.jpg" alt="三次握手"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-close-con.jpg" alt="四次挥手"></p><h2 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><blockquote><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。</p></blockquote><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><blockquote><p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p></blockquote><blockquote><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。</p></blockquote><h3 id="SACK重传机制-Selective-Acknowledgment-选择性确认"><a href="#SACK重传机制-Selective-Acknowledgment-选择性确认" class="headerlink" title="SACK重传机制(Selective Acknowledgment 选择性确认)"></a>SACK重传机制(Selective Acknowledgment 选择性确认)</h3><blockquote><p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p></blockquote><h3 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h3><blockquote><p>D-SACK 有这么几个好处： </p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol></blockquote><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote><p>拥塞窗口 cwnd 变化的规则：</p><ol><li>只要网络中没有出现拥塞，cwnd 就会增大；</li><li>但网络中出现了拥塞，cwnd 就减少；</li></ol></blockquote><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><blockquote><p>为什么需要慢启动?</p><p>发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件而动态改变速度。此时，根据交换数据来估算客户端与服务器之间的可用带宽是唯一的方法，而且这也是慢启动算法的设计思路。</p></blockquote><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。<br>一般来说 ssthresh 的大小是 65535 字节。</p><h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：tcp</p><ul><li>ssthresh 设为 cwnd/2</li><li>cwnd 重置为 1</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-hp01.jpg" alt="拥塞发生"></p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><blockquote><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p></blockquote><p>进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p><ul><li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li><li>ssthresh = cwnd;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-hp02.jpg" alt="快速恢复"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%85%A8%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">全解网络协议</a></li><li><a href="https://blog.csdn.net/qq_34827674/article/details/105606205">小林coding-30 张图解： 面试必问的 TCP 重传、滑动窗口、流量控制、拥塞控制</a></li><li><a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a></li><li><a href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/34%20%20UDP%20%E5%8D%8F%E8%AE%AE%EF%BC%9AUDP%20%E5%92%8C%20TCP%20%E7%9B%B8%E6%AF%94%E5%BF%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F.md">UDP 协议：UDP 和 TCP 相比快在哪里？</a></li><li><a href="https://www.zhihu.com/question/24853633/answer/573627478">TCP 为什么是三次握手，而不是两次或四次？</a></li><li><a href="https://www.huaweicloud.com/articles/8357193.html">Linux系列：TCP慢启动原理（拥塞控制机制）</a></li><li><a href="https://zhuanlan.zhihu.com/p/53374516">“三次握手，四次挥手”你真的懂吗？</a></li><li><a href="https://chenxfeng.github.io/2017/05/10/computer_network/computer_network_3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82(Transport%20Layer)/">传输层(Transport Layer)</a></li></ol><p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html">http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html">http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html</a></p><p><a href="https://datatracker.ietf.org/doc/rfc1644/">https://datatracker.ietf.org/doc/rfc1644/</a></p><p><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm</a></p><p><a href="https://www.youtube.com/playlist?list=PLoCMsyE1cvdWKsLVyf6cPwCLDIZnOj0NS">https://www.youtube.com/playlist?list=PLoCMsyE1cvdWKsLVyf6cPwCLDIZnOj0NS</a></p><p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">https://draveness.me/whys-the-design-tcp-three-way-handshake/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-performance/">https://draveness.me/whys-the-design-tcp-performance/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">https://draveness.me/whys-the-design-tcp-segment-ip-packet/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-message-frame/">https://draveness.me/whys-the-design-tcp-message-frame/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-time-wait/">https://draveness.me/whys-the-design-tcp-time-wait/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-message-frame/">https://draveness.me/whys-the-design-tcp-message-frame/</a></p>]]></content>
      
      
      <categories>
          
          <category> internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据面试问题</title>
      <link href="/big-data-questions/"/>
      <url>/big-data-questions/</url>
      
        <content type="html"><![CDATA[<h2 id="一、黑名单网页过滤"><a href="#一、黑名单网页过滤" class="headerlink" title="一、黑名单网页过滤"></a>一、黑名单网页过滤</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实通过判断网页url是否在黑名单里, 现一个黑名单网页过滤系统。<br>每个网页的url最多占用64B。</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ol><li>允许有万分之一以下的判断失误率。</li><li>使用的额外空间不要超过30GB</li></ol><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h4 id="思路1-哈希表-不可行"><a href="#思路1-哈希表-不可行" class="headerlink" title="思路1: 哈希表(不可行)"></a>思路1: 哈希表(不可行)</h4><p>如果通过哈希表保存, 那么64B * 100亿 &gt; 640GB, 显然不符合要求。</p><h4 id="思路2-布隆过滤器"><a href="#思路2-布隆过滤器" class="headerlink" title="思路2: 布隆过滤器"></a>思路2: 布隆过滤器</h4><p>可以使用布隆过滤器。</p><h2 id="二、在20亿个整数中找到出现次数最多的数"><a href="#二、在20亿个整数中找到出现次数最多的数" class="headerlink" title="二、在20亿个整数中找到出现次数最多的数"></a>二、在20亿个整数中找到出现次数最多的数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一个包含20亿个全是32位整数的大文件, 在其中找到出现次数最多的数。</p><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ol><li>内存限制为2GB</li></ol><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><h4 id="思路1-直接使用哈希表-不可行"><a href="#思路1-直接使用哈希表-不可行" class="headerlink" title="思路1: 直接使用哈希表(不可行)"></a>思路1: 直接使用哈希表(不可行)</h4><p>如果用哈希表做词频统计, key需要占用4B, value需要占用4B,  那么可能最多需要的空间是: (4B+4B) * 20亿 &gt; 16GB, 显然这种方法不满足要求</p><h4 id="思路2-分片后使用哈希表"><a href="#思路2-分片后使用哈希表" class="headerlink" title="思路2: 分片后使用哈希表"></a>思路2: 分片后使用哈希表</h4><p>可以通过哈希函数, 将20亿个数分成16个小文件。每个小文件对应的数不会大于2亿种, 用哈希表计算2亿种数的词频大约需要1.6GB内存。<br>接下来只需要选出这16个小文件各自的最高词频即可。</p><h2 id="三、40亿个非负整数中找到未出现的数"><a href="#三、40亿个非负整数中找到未出现的数" class="headerlink" title="三、40亿个非负整数中找到未出现的数"></a>三、40亿个非负整数中找到未出现的数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 请在一个有40亿个无符号整数的文件中, 找出未出现过的数。</p><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用1GB内存</li></ol><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><h4 id="思路1-直接使用哈希表-不可行-1"><a href="#思路1-直接使用哈希表-不可行-1" class="headerlink" title="思路1: 直接使用哈希表(不可行)"></a>思路1: 直接使用哈希表(不可行)</h4><p>如果直接使用哈希表, 那么需要使用内存: 4B * 40亿 ≈ 16GB, 显然是不满足条件的。</p><h4 id="思路2-bitmap"><a href="#思路2-bitmap" class="headerlink" title="思路2: bitmap"></a>思路2: bitmap</h4><p>4294967295个bit数组占用500MB空间, 可以解决这个问题。</p><h2 id="四、在40亿个非负整数中找出1个未出现过的数"><a href="#四、在40亿个非负整数中找出1个未出现过的数" class="headerlink" title="四、在40亿个非负整数中找出1个未出现过的数"></a>四、在40亿个非负整数中找出1个未出现过的数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 请在一个有40亿个无符号整数的文件中, 找出1个未出现过的数</p><h3 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用10MB内存</li></ol><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><h4 id="思路-分片统计-然后用bitmap"><a href="#思路-分片统计-然后用bitmap" class="headerlink" title="思路: 分片统计, 然后用bitmap"></a>思路: 分片统计, 然后用bitmap</h4><p>将0 ~ 4294967295划分为64个区间, 统计每个区间的数字种类。如果哪个区间的总数不到 (4294967296/64)个, 那么说明在这个区间可以找出未出现过的数。<br>在对应的区间内使用bitset寻找未出现的数, 4294967296/64 = 67108864 bit ≈ 8MB</p><h2 id="五、40亿个非负整数中找到出现两次的数"><a href="#五、40亿个非负整数中找到出现两次的数" class="headerlink" title="五、40亿个非负整数中找到出现两次的数"></a>五、40亿个非负整数中找到出现两次的数</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 现在有40亿个无符号整数, 找出所有出现了2次的数。 </p><h3 id="要求-4"><a href="#要求-4" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用1GB的内存</li></ol><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><h4 id="思路-bitmap变种"><a href="#思路-bitmap变种" class="headerlink" title="思路: bitmap变种"></a>思路: bitmap变种</h4><p>普通的bitmap值只有0和1, 在这道题下, 我们让bitmap的值支持0~3。所以申请的空间是4294967295 * 2bit = 1GB。<br>遍历所有文件, bitmap值为0表示未出现过, 1表示出现过1次, 2表示出现过2次, 3表示出现次数多于2次。</p><h2 id="六、40亿个非负整数中找到中位数"><a href="#六、40亿个非负整数中找到中位数" class="headerlink" title="六、40亿个非负整数中找到中位数"></a>六、40亿个非负整数中找到中位数</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 现在有40亿个无符号整数, 找出中位数。</p><h3 id="要求-5"><a href="#要求-5" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用10MB的内存</li></ol><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><h4 id="思路-文件分流"><a href="#思路-文件分流" class="headerlink" title="思路: 文件分流"></a>思路: 文件分流</h4><p>(2 * 1000 * 1000) * 32bit ≈ 8MB , 所以我们将每 2000000 个数字划为一个区间。<br>4294967296/ 2000000 向上取整为2148个区间。<br>遍历一遍文件, 统计每个区间的总词频。<br>之后可以定位到中位数在具体的一个区间内, 再次遍历文件, 不在这个区间的数字忽略不计, 统计这个区间的每个数的词频, 找出中位数。</p><p><a href="https://www.sohu.com/a/138204769_236714">大数据求职必看：经典的大数据面试问题 )</a><br><a href="">程序员代码面试指南 第6章</a></p><p><a href="http://duanple.com/?p=289">http://duanple.com/?p=289</a></p>]]></content>
      
      
      <categories>
          
          <category> big data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> big data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java memory model(java内存模型)</title>
      <link href="/java-memory-model/"/>
      <url>/java-memory-model/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在并发编程中, 我们需要处理两个关键问题: </p><ul><li>线程之间如何通信。通信是指线程之间交换信息。(由JMM控制)</li><li>线程之间如何同步。同步是指程序操作发生的相对顺序。(由并发工具支持, synchronized同步锁、CyclicBarrier等)</li></ul><p>在命令式编程中, 线程之间的通信机制有两种: </p><ul><li>共享内存(Java)</li><li>消息传递(Go)</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>Java源代码到最终实际执行的指令序列, 会经理下面三种重排序：</p><ol><li>源代码 -&gt; 编译器优化重排序</li><li>-&gt; 指令级并行重排序</li><li>-&gt; 内存系统重排序 -&gt; 最终执行的指令序列</li></ol><p>禁止编译器重排序: JMM的编译器重排序规则会禁止特定类型的编译器重排序<br>禁止处理器重排序: JMM通过插入内存屏障</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>JMM属于语言级的内存模型, 它确保在不同的编译器和处理器上 为程序员员提供一致的内存可见性(通过禁止特定类型的编译器重排序和处理器重排序)。</p><ul><li>程序顺序规则: 一个线程中的每个操作, happens-before于该线程中的任意操作</li><li>监视器锁规则: 对一个监视器的解锁, happens-before于随后对这个监视器的加锁</li></ul><h2 id="cpu写缓冲区"><a href="#cpu写缓冲区" class="headerlink" title="cpu写缓冲区"></a>cpu写缓冲区</h2><p>现代的cpu使用写缓冲区来临时保存向内存写入的数据。</p><h3 id="写缓冲区的优点"><a href="#写缓冲区的优点" class="headerlink" title="写缓冲区的优点"></a>写缓冲区的优点</h3><ol><li>cpu不必停顿下来等待向内存写入数据, 这种停顿等待会打断流水线的持续运行。</li><li>通过以批处理的方式刷新写缓冲区, 以及合并写缓冲区对同一内存地址的多次写, 减少对内存总线的占用</li></ol><h3 id="写缓冲区带来的问题"><a href="#写缓冲区带来的问题" class="headerlink" title="写缓冲区带来的问题"></a>写缓冲区带来的问题</h3><p>处理器对内存的读/写操作的执行顺序, 不一定与内存实际发生的读/写操作顺序一致</p><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>常见的缓存一致性协议有：MESI，MESIF（MESIF是缓存行的状态标识，M:Modified, E: Exclusive, S:Shared, I:Invalid, F: Forwad），通过标记缓存行的状态和处理器间的通讯来实现。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://ifeve.com/tag/happens-before/">happens-before</a></li><li><a href="https://www.cnblogs.com/duanxz/archive/2013/01/15/2861606.html">指令重排、内存屏障概念解析</a></li><li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel文档</a></li><li><a href="https://www.felixcloutier.com/x86/cmpxchg">cmpxchg指令</a></li><li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86寄存器</a></li><li><a href="https://en.wikipedia.org/wiki/Zero_flag">ZF标志</a></li><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a></li><li><a href="https://segmentfault.com/a/1190000039091865">Java并发编程常识</a></li><li><a href="https://zhuanlan.zhihu.com/p/25042028">[资料合集] RednaxelaFX写的文章/回答的导航帖（work in progress）</a></li><li><a href="https://segmentfault.com/a/1190000020673082">讲真，我发现这本书有个地方写错了! 溢出 or 逸出?</a></li><li><a href="https://albk.tech/%E8%81%8A%E8%81%8AJMM.html">聊聊JMM</a></li><li><a href="https://mp.weixin.qq.com/s/_zmhLhEDgLggejUdF1c9gw">面试官告诉你什么是JMM和常考面试题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
