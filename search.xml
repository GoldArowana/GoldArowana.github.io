<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GC algorithm</title>
      <link href="/gc-algorithm/"/>
      <url>/gc-algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h2><h3 id="朴素的标记清除"><a href="#朴素的标记清除" class="headerlink" title="朴素的标记清除"></a>朴素的标记清除</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h3 id="可以考虑使用多个空闲链表优化"><a href="#可以考虑使用多个空闲链表优化" class="headerlink" title="可以考虑使用多个空闲链表优化"></a>可以考虑使用多个空闲链表优化</h3><h3 id="BiBOP法"><a href="#BiBOP法" class="headerlink" title="BiBOP法"></a>BiBOP法</h3><h3 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h3><h3 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h3><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><h3 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h3><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><h3 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h3><h3 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h3><h3 id="1位引用计数法"><a href="#1位引用计数法" class="headerlink" title="1位引用计数法"></a>1位引用计数法</h3><h3 id="部分标记-清除法"><a href="#部分标记-清除法" class="headerlink" title="部分标记-清除法"></a>部分标记-清除法</h3><h4 id="四色"><a href="#四色" class="headerlink" title="四色"></a>四色</h4><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《垃圾回收的算法与实现-中村成洋》</li><li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Tracing garbage collection</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> gc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能网络模型</title>
      <link href="/high-performance-network-model/"/>
      <url>/high-performance-network-model/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><blockquote><p>我们可以把标准输入、套接字等都看做 I/O 的一路，多路复用的意思，就是在任何一路 I/O 有“事件”发生的情况下，通知应用程序去处理相应的 I/O 事件，这样我们的程序就变成了“多面手”，在同一时刻仿佛可以处理多个 I/O 事件。</p></blockquote><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><blockquote><p>仅知道有I/O事件发生，却不知是哪几个流，只会无差异轮询所有流，找出能读数据或写数据的流进行操作。同时处理的流越多，无差别轮询时间越长 - O(n)。</p></blockquote><blockquote><p>当socket较多时，每次select都要通过遍历FD_SETSIZE个socket，不管是否活跃，这会浪费很多CPU时间。如果能给 socket 注册某个回调函数，当他们活跃时，自动完成相关操作，即可避免轮询，这就是epoll与kqueue。</p></blockquote><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><blockquote><p>poll没有最大文件描述符数量的限制</p></blockquote><h2 id="iocp-Windows"><a href="#iocp-Windows" class="headerlink" title="iocp(Windows)"></a>iocp(Windows)</h2><h2 id="epoll-Linux"><a href="#epoll-Linux" class="headerlink" title="epoll(Linux)"></a>epoll(Linux)</h2><blockquote><p>在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p></blockquote><blockquote><p>epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。</p></blockquote><h3 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h3><blockquote><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p></blockquote><h3 id="LT-默认"><a href="#LT-默认" class="headerlink" title="LT(默认)"></a>LT(默认)</h3><blockquote><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p></blockquote><h2 id="kqueue-FreeBsd"><a href="#kqueue-FreeBsd" class="headerlink" title="kqueue(FreeBsd)"></a>kqueue(FreeBsd)</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《极客时间-网络编程实战》</li><li><a href="http://gityuan.com/2019/01/05/linux-poll-select/">源码解读poll/select内核机制</a></li><li><a href="https://cloud.tencent.com/developer/article/1517892">何兴鹏: select函数源码简析</a></li><li><a href="https://www.jianshu.com/p/95b50b026895">Linux select源码分析</a></li><li><a href="http://www.pandademo.com/2016/11/linux-kernel-select-source-dissect/">Linux内核select源码剖析</a></li><li><a href="https://en.wikipedia.org/wiki/Select_(Unix)">select</a></li><li><a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">Polling</a></li><li><a href="https://en.wikipedia.org/wiki/Epoll">epoll</a></li><li><a href="https://en.wikipedia.org/wiki/Kqueue">kqueue</a></li><li><a href="https://learnku.com/articles/41814">流？I/O 操作？阻塞？epoll?</a></li><li><a href="https://learnku.com/articles/37534">—慢更-基于 go 的 IM 聊天</a></li><li><a href="https://zhuanlan.zhihu.com/p/87843750">深入理解IO复用之epoll</a></li><li><a href="https://zhuanlan.zhihu.com/p/63179839">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （1）</a></li><li><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java (Doug Lea)</a></li><li><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select、poll、epoll之间的区别(搜狗面试)</a></li><li><a href="https://www.zhihu.com/question/30262027/answer/53206495">Linux服务端编程。关于IO复用，在epoll出现多年的情况下，select和poll还有使用场景吗？</a></li><li><a href="https://www.cnblogs.com/zl1991/p/12098272.html">高性能跨平台网络IO（Reactor、epoll、iocp）总结</a></li><li><a href="https://www.cnblogs.com/dafanjoy/p/11217708.html">《Scalable IO in Java》译文</a></li><li><a href="https://blog.csdn.net/Mr_H9527/article/details/99745659">epoll底层红黑树使用部分源码剖析：为什么使用红黑树以及如何使用红黑树</a></li><li><a href="https://blog.csdn.net/eyucham/article/details/86502117">Linux下的I/O复用与epoll详解(ET与LT)</a></li><li><a href="https://blog.csdn.net/Eunice_fan1207/article/details/99641348">Linux内核剖析—–IO复用函数poll内核源码剖析</a></li><li><a href="https://blog.csdn.net/Eunice_fan1207/article/details/99674021">Linux内核剖析—–IO复用函数epoll内核源码剖析</a></li><li><a href="http://blog.chinaunix.net/uid-28541347-id-4273856.html">彻底学会使用epoll(一)——ET模式实现分析</a></li></ol><p><a href="https://www.zhihu.com/question/20122137/answer/146866418">https://www.zhihu.com/question/20122137/answer/146866418</a></p><p><a href="https://www.jianshu.com/p/e4d1c485c32a">https://www.jianshu.com/p/e4d1c485c32a</a></p><p><a href="https://www.cnblogs.com/jukan/p/5272257.html">https://www.cnblogs.com/jukan/p/5272257.html</a></p>]]></content>
      
      
      <categories>
          
          <category> design patterns </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
            <tag> design patterns </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年学习规划</title>
      <link href="/leaning-plan-for-2022/"/>
      <url>/leaning-plan-for-2022/</url>
      
        <content type="html"><![CDATA[<p>技能的提升更多还是需要在平时进行积累, 虽然已经过去十天了, 但还是爬起来规划了今年的学习规划, 立个Flag。<br>(2021年的计划完成了70%, 其实已经超出我的预料了)</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>最近又用回了Java, 需要恶补一下基础：</p><ol><li>JVM调优</li><li>JDK18</li></ol><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>虽然短期内用go的机会少一些, 但是毕竟是我用的时间最长的一门语言, 还是不能抛弃的, 需要继续跟进时代的发展。</p><ol><li>看一看go1.18。跟进一下最新动态。</li><li>课余时间用go写个直播, 最好再结合python写个ai人脸替换。</li></ol><h2 id="框架-中间件"><a href="#框架-中间件" class="headerlink" title="框架/中间件"></a>框架/中间件</h2><p>语言转为Java后, 很多框架也没使用过, 需要恶补一下原理：</p><ol><li>HSF</li><li>Dubbo</li><li>WebFlux</li><li>Reactor3</li><li>RocketMQ</li><li>Diamond</li><li>Sentinel</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络一直是我的弱项, 不能放弃：</p><ol><li>高性能网络模型</li><li>MQTT</li></ol><h2 id="数据库-分布式"><a href="#数据库-分布式" class="headerlink" title="数据库/分布式"></a>数据库/分布式</h2><p>数据库和分布式是我去年重点学习的方向, 越学越喜欢。<br>而且发现分布式领域的论文都还挺不错的, 挑了两篇貌似还不错的, 计划在今年攻克一下。</p><ol><li>Lindorm</li><li>HBase</li><li>Spanner</li><li>《PacificA: Replication in Log-Based Distributed Storage Systems》</li><li>《Making reliable distributed systems in the presence of sodware errors》</li></ol><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol><li>面向对象</li><li>架构设计</li><li>《微服务架构设计模式》</li><li>《领域驱动设计》</li><li>《架构整洁之道》</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>刷20道leetcode, 不是很多。不图快速肝完20道, 而是一两周来一道, 保持手感。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>软硬技能结合, 都要重视。</p><ol><li>技术: 读4个极客时间专栏</li><li>总结: 完成7篇博客/笔记/视频, 题材不限、形式不限。</li><li>美工: 读1本排版设计相关的书</li><li>思考: 读1本思考相关的书</li><li>扩展: 读1本科普兴趣类读物</li><li>沟通: 读1本沟通相关的书</li><li>影响: 在知乎答疑10个计算机相关问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
            <tag> 2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go sysmon</title>
      <link href="/go-sysmon/"/>
      <url>/go-sysmon/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote><p>系统监控是 Go 语言运行时的重要组成部分，它会每隔一段时间检查 Go 语言运行时，确保程序没有进入异常状态</p></blockquote><blockquote><p>系统监控的触发时间就会稳定在 10ms</p></blockquote><h2 id="检查死锁"><a href="#检查死锁" class="headerlink" title="检查死锁"></a>检查死锁</h2><h2 id="运行计时器"><a href="#运行计时器" class="headerlink" title="运行计时器"></a>运行计时器</h2><p>获取下一个需要被触发的计时器</p><blockquote><p>当前调度器需要执行垃圾回收或者所有处理器都处于闲置状态时，如果没有需要触发的计时器，那么系统监控可以暂时陷入休眠</p></blockquote><h2 id="轮循网络"><a href="#轮循网络" class="headerlink" title="轮循网络"></a>轮循网络</h2><p>获取需要处理的到期文件描述符</p><blockquote><p>如果上一次轮询网络已经过去了 10ms，那么系统监控还会在循环中轮询网络，检查是否有待执行的文件描述符</p></blockquote><h2 id="抢占处理器"><a href="#抢占处理器" class="headerlink" title="抢占处理器"></a>抢占处理器</h2><p>抢占运行时间较长的或者处于系统调用的 Goroutine</p><blockquote><ol><li>当处理器处于 _Prunning 或者 _Psyscall 状态时，如果上一次触发调度的时间已经过去了 10ms，我们会通过 runtime.preemptone 抢占当前处理器；</li><li>当处理器处于 _Psyscall 状态时，在满足以下两种情况下会调用 runtime.handoffp 让出处理器的使用权：</li><li>当处理器的运行队列不为空或者不存在空闲处理器时2；</li><li>当系统调用时间超过了 10ms 时3；</li></ol></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>在满足条件时触发垃圾收集回收内存</p><blockquote><p>如果需要触发垃圾回收，我们会将用于垃圾回收的 Goroutine 加入全局队列，让调度器选择合适的处理器去执行。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/sysmon/">https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/sysmon/</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</a></p><p><a href="https://gocn.vip/topics/9884">https://gocn.vip/topics/9884</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang atomic cas</title>
      <link href="/golang-atomic-cas/"/>
      <url>/golang-atomic-cas/</url>
      
        <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Go / src / runtime / internal / atomic / asm_amd.s文件中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime∕internal∕atomic·Cas64(SB), NOSPLIT, $0-25</span><br><span class="line"> MOVQ ptr+0(FP), BX</span><br><span class="line"> MOVQ old+8(FP), AX</span><br><span class="line"> MOVQ new+16(FP), CX</span><br><span class="line"> LOCK</span><br><span class="line"> CMPXCHGQ CX, 0(BX)</span><br><span class="line"> SETEQ ret+24(FP)</span><br><span class="line"> RET</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> atomic </tag>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java memory model(java内存模型)</title>
      <link href="/java-memory-model/"/>
      <url>/java-memory-model/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在并发编程中, 我们需要处理两个关键问题: </p><ul><li>线程之间如何通信。通信是指线程之间交换信息。(由JMM控制)</li><li>线程之间如何同步。同步是指程序操作发生的相对顺序。(由并发工具支持, synchronized同步锁、CyclicBarrier等)</li></ul><p>在命令式编程中, 线程之间的通信机制有两种: </p><ul><li>共享内存(Java)</li><li>消息传递(Go)</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>Java源代码到最终实际执行的指令序列, 会经理下面三种重排序：</p><ol><li>源代码 -&gt; 编译器优化重排序</li><li>-&gt; 指令级并行重排序</li><li>-&gt; 内存系统重排序 -&gt; 最终执行的指令序列</li></ol><p>禁止编译器重排序: JMM的编译器重排序规则会禁止特定类型的编译器重排序<br>禁止处理器重排序: JMM通过插入内存屏障</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>JMM属于语言级的内存模型, 它确保在不同的编译器和处理器上 为程序员员提供一致的内存可见性(通过禁止特定类型的编译器重排序和处理器重排序)。</p><ul><li>程序顺序规则: 一个线程中的每个操作, happens-before于该线程中的任意操作</li><li>监视器锁规则: 对一个监视器的解锁, happens-before于随后对这个监视器的加锁</li></ul><h2 id="cpu写缓冲区"><a href="#cpu写缓冲区" class="headerlink" title="cpu写缓冲区"></a>cpu写缓冲区</h2><p>现代的cpu使用写缓冲区来临时保存向内存写入的数据。</p><h3 id="写缓冲区的优点"><a href="#写缓冲区的优点" class="headerlink" title="写缓冲区的优点"></a>写缓冲区的优点</h3><ol><li>cpu不必停顿下来等待向内存写入数据, 这种停顿等待会打断流水线的持续运行。</li><li>通过以批处理的方式刷新写缓冲区, 以及合并写缓冲区对同一内存地址的多次写, 减少对内存总线的占用</li></ol><h3 id="写缓冲区带来的问题"><a href="#写缓冲区带来的问题" class="headerlink" title="写缓冲区带来的问题"></a>写缓冲区带来的问题</h3><p>处理器对内存的读/写操作的执行顺序, 不一定与内存实际发生的读/写操作顺序一致</p><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>常见的缓存一致性协议有：MESI，MESIF（MESIF是缓存行的状态标识，M:Modified, E: Exclusive, S:Shared, I:Invalid, F: Forwad），通过标记缓存行的状态和处理器间的通讯来实现。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://ifeve.com/tag/happens-before/">happens-before</a></li><li><a href="https://www.cnblogs.com/duanxz/archive/2013/01/15/2861606.html">指令重排、内存屏障概念解析</a></li><li><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel文档</a></li><li><a href="https://www.felixcloutier.com/x86/cmpxchg">cmpxchg指令</a></li><li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86寄存器</a></li><li><a href="https://en.wikipedia.org/wiki/Zero_flag">ZF标志</a></li><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">The JSR-133 Cookbook for Compiler Writers</a></li><li><a href="https://segmentfault.com/a/1190000039091865">Java并发编程常识</a></li><li><a href="https://zhuanlan.zhihu.com/p/25042028">[资料合集] RednaxelaFX写的文章/回答的导航帖（work in progress）</a></li><li><a href="https://segmentfault.com/a/1190000020673082">讲真，我发现这本书有个地方写错了! 溢出 or 逸出?</a></li><li><a href="https://albk.tech/%E8%81%8A%E8%81%8AJMM.html">聊聊JMM</a></li><li><a href="https://mp.weixin.qq.com/s/_zmhLhEDgLggejUdF1c9gw">面试官告诉你什么是JMM和常考面试题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSM-Tree</title>
      <link href="/lsm/"/>
      <url>/lsm/</url>
      
        <content type="html"><![CDATA[<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>适合写多读少</p><ol><li>日志系统</li><li>推荐系统</li><li>海量数据存储</li><li>数据分析</li></ol><h2 id="三大问题"><a href="#三大问题" class="headerlink" title="三大问题"></a>三大问题</h2><h3 id="读放大"><a href="#读放大" class="headerlink" title="读放大"></a>读放大</h3><p>读操作需要从新值到旧值依次读取, 在此过程中会涉及不止依次IO。尤其是范围查询时, 导致影响很明显 </p><h3 id="空间放大"><a href="#空间放大" class="headerlink" title="空间放大"></a>空间放大</h3><p>LSM通过append方式在末尾追击记录, 过期或者删除的数据不会立即清理, 所以会导致空间放大。</p><p>就是指存储引擎中的数据实际占用的磁盘空间比数据的真正大小偏多的情况。例如，数据的真正大小是10MB，但实际存储时耗掉了25MB空间，那么空间放大因子（space amplification factor）就是2.5</p><p>为什么会出现空间放大呢？很显然，LSM-based存储引擎中数据的增删改都不是in-place的，而是需要等待compaction执行到对应的key才算完。也就是说，一个key可能会同时对应多个value（删除标记算作特殊的value），而只有一个value是真正有效的，其余那些就算做空间放大。另外，在compaction过程中，原始数据在执行完成之前是不能删除的（防止出现意外无法恢复），所以同一份被compaction的数据最多可能膨胀成原来的两倍，这也算作空间放大的范畴。</p><h3 id="写放大"><a href="#写放大" class="headerlink" title="写放大"></a>写放大</h3><p>为了减少读放大和空间放大, 会进行压缩合并。压缩合并的过程中对一条数据会涉及多次写, 导致写放大。</p><h2 id="Tiering"><a href="#Tiering" class="headerlink" title="Tiering"></a>Tiering</h2><p>写优化, 空间放大。Cassandra。</p><h2 id="leveling"><a href="#leveling" class="headerlink" title="leveling"></a>leveling</h2><p>读优化, 写放大。RocksDB。</p><h2 id="Monkey-Optimal-Navigable-Key-Value-Store"><a href="#Monkey-Optimal-Navigable-Key-Value-Store" class="headerlink" title="Monkey: Optimal Navigable Key-Value Store"></a>Monkey: Optimal Navigable Key-Value Store</h2><p>调整布隆过滤器的容错率</p><h2 id="Dostoevsky"><a href="#Dostoevsky" class="headerlink" title="Dostoevsky"></a>Dostoevsky</h2><h3 id="Lazy-Leveling"><a href="#Lazy-Leveling" class="headerlink" title="Lazy Leveling"></a>Lazy Leveling</h3><p>写优化、点查优化。原理非常简单，也就是混合了 Tiered 以及 Leveled，在最大层使用 Leveled，而其它层使用 Tiered。</p><h3 id="Fluid-LSM-Tree"><a href="#Fluid-LSM-Tree" class="headerlink" title="Fluid LSM-Tree"></a>Fluid LSM-Tree</h3><p>Fluid 使用了一个可调解的方式，在最大层使用最多 Z runs，而其它层最多使用 K runs。</p><p>可以发现：</p><ol><li>Z = 1， K = 1，就是 Leveled Compaction</li><li>Z = T - 1， K = T - 1，就是 Tiered Compaction</li><li>Z = 1， K = T - 1，就是 Lazy Leveling</li></ol><h2 id="Wacky"><a href="#Wacky" class="headerlink" title="Wacky"></a>Wacky</h2><p>适合大量写入、点读。缺点是范围读</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="lsm-hash"><a href="#lsm-hash" class="headerlink" title="lsm hash"></a>lsm hash</h3><h4 id="bitcask-riak"><a href="#bitcask-riak" class="headerlink" title="bitcask(riak)"></a>bitcask(riak)</h4><h4 id="rosedb"><a href="#rosedb" class="headerlink" title="rosedb"></a>rosedb</h4><h4 id="nutsdb"><a href="#nutsdb" class="headerlink" title="nutsdb"></a>nutsdb</h4><h3 id="lsm-array"><a href="#lsm-array" class="headerlink" title="lsm array"></a>lsm array</h3><h4 id="moss"><a href="#moss" class="headerlink" title="moss"></a>moss</h4><h3 id="lsm-tree"><a href="#lsm-tree" class="headerlink" title="lsm tree"></a>lsm tree</h3><h4 id="pebble"><a href="#pebble" class="headerlink" title="pebble"></a>pebble</h4><h4 id="leveldb"><a href="#leveldb" class="headerlink" title="leveldb"></a>leveldb</h4><h4 id="rocksdb"><a href="#rocksdb" class="headerlink" title="rocksdb"></a>rocksdb</h4><h5 id="TTL实现"><a href="#TTL实现" class="headerlink" title="TTL实现"></a>TTL实现</h5><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><h5 id="TTL实现-1"><a href="#TTL实现-1" class="headerlink" title="TTL实现"></a>TTL实现</h5><h3 id="BigTable"><a href="#BigTable" class="headerlink" title="BigTable"></a>BigTable</h3><h3 id="DynamoDB"><a href="#DynamoDB" class="headerlink" title="DynamoDB"></a>DynamoDB</h3><h3 id="cassandra"><a href="#cassandra" class="headerlink" title="cassandra"></a>cassandra</h3><h5 id="TTL实现-2"><a href="#TTL实现-2" class="headerlink" title="TTL实现"></a>TTL实现</h5><h3 id="accumulo"><a href="#accumulo" class="headerlink" title="accumulo"></a>accumulo</h3><h3 id="couchbase"><a href="#couchbase" class="headerlink" title="couchbase"></a>couchbase</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/baichoufei90/article/details/84841289">论文阅读-The Log-Structured Merge-Tree (LSM-Tree)</a></li><li><a href="https://www.dazhuanlan.com/mongolzhang/topics/1102894">Monkey: Optimal Navigable Key-Value Store (中文翻译)</a></li><li><a href="https://www.jianshu.com/p/8fb8f2458253">Dostoevsky: 一种更好的平衡 LSM 空间和性能的方式</a></li><li><a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">Log-structured merge-tree</a></li><li><a href="https://www.scylladb.com/2018/01/17/compaction-series-space-amplification/">Scylla’s Compaction Strategies Series: Space Amplification in Size-Tiered Compaction</a></li><li><a href="https://blog.csdn.net/nazeniwaresakini/article/details/104220140">LSM Tree-Based存储引擎的compaction策略（feat. RocksDB）</a></li><li><a href="https://cloud.tencent.com/developer/article/1399365">深入 LevelDB 数据文件 SSTable 的结构</a></li><li><a href="https://zhuanlan.zhihu.com/p/141186118">深入探讨LSM Compaction机制</a></li><li><a href="https://www.toberoot.com/news/2020/12/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFLSM-Tree/">深入理解什么是LSM-Tree</a></li><li><a href="https://niceaz.com/2018/11/27/sstable">SSTable 原理</a></li><li><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">Log Structured Merge Trees</a></li><li><a href="https://nan01ab.github.io/2019/06/LSM-Bush.html">The Log-Structured Merge-Bush &amp; the Wacky Continuum 中文</a></li><li><a href="https://zhuanlan.zhihu.com/p/380013595">REMIX: Efficient Range Query for LSM-trees</a></li></ol><p><a href="https://blog.csdn.net/weixin_32496547/article/details/114098111">https://blog.csdn.net/weixin_32496547/article/details/114098111</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&amp;rep=rep1&amp;type=pdf</a></p><p><a href="http://blog.fatedier.com/2016/06/15/learn-lsm-tree/">http://blog.fatedier.com/2016/06/15/learn-lsm-tree/</a></p><p><a href="http://www.blogjava.net/DLevin/archive/2015/09/25/427481.html">http://www.blogjava.net/DLevin/archive/2015/09/25/427481.html</a></p><p><a href="https://izualzhy.cn/leveldb-sstable">https://izualzhy.cn/leveldb-sstable</a></p><p><a href="https://www.cnblogs.com/fxjwind/archive/2012/08/14/2638371.html">https://www.cnblogs.com/fxjwind/archive/2012/08/14/2638371.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/103968892">https://zhuanlan.zhihu.com/p/103968892</a></p><p><a href="https://zhuanlan.zhihu.com/p/103855686">https://zhuanlan.zhihu.com/p/103855686</a></p><p><a href="https://xiaozhuanlan.com/topic/7130689425">WiscKey —— SSD 介质下的 LSM-tree 优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/181498475">https://zhuanlan.zhihu.com/p/181498475</a></p><p><a href="https://rocksdb.org.cn/doc/Leveled-Compaction.html">https://rocksdb.org.cn/doc/Leveled-Compaction.html</a></p><p><a href="https://rocksdb.org.cn/doc/Universal-Compaction.html">https://rocksdb.org.cn/doc/Universal-Compaction.html</a></p><p><a href="https://www.open-open.com/lib/view/open1424916275249.html">https://www.open-open.com/lib/view/open1424916275249.html</a></p><p><a href="http://www.petermao.com/leveldb/leveldb-0-start.html">http://www.petermao.com/leveldb/leveldb-0-start.html</a></p><p><a href="https://github.com/google/leveldb/blob/master/doc/impl.md">https://github.com/google/leveldb/blob/master/doc/impl.md</a></p><p><a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html</a></p><p><a href="http://www.petermao.com/leveldb/leveldb-1-overview.html">http://www.petermao.com/leveldb/leveldb-1-overview.html</a></p><p><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">http://www.benstopford.com/2015/02/14/log-structured-merge-trees/</a></p><p><a href="http://www.benstopford.com/2015/02/14/log-structured-merge-trees/">http://www.benstopford.com/2015/02/14/log-structured-merge-trees/</a></p><p><a href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">https://github.com/facebook/rocksdb/wiki/Leveled-Compaction</a></p><p><a href="https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/">https://zhenghe-md.github.io/blog/2020/02/26/Log-Structured-Merge-LSM-Tree-Usages-in-KV-Stores/</a></p><p><a href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/">https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/</a></p><p><a href="http://daslab.seas.harvard.edu/classes/cs265/project.html">http://daslab.seas.harvard.edu/classes/cs265/project.html</a></p><p><a href="http://www.youtube.com/watch?v=b6SI8VbcT4w">http://www.youtube.com/watch?v=b6SI8VbcT4w</a></p><p><a href="http://www.youtube.com/watch?v=ttebJcN5bgQ">http://www.youtube.com/watch?v=ttebJcN5bgQ</a></p><p><a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/05/Scaling-Write-Intensive-Key-Value-Stores-slides.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2019/05/Scaling-Write-Intensive-Key-Value-Stores-slides.pdf</a></p><p><a href="https://speakerdeck.com/mschoch/value-store-in-go?slide=3">https://speakerdeck.com/mschoch/value-store-in-go?slide=3</a></p><p><a href="https://izualzhy.cn/leveldb-table">https://izualzhy.cn/leveldb-table</a></p><p><a href="https://izualzhy.cn/leveldb-sstable">https://izualzhy.cn/leveldb-sstable</a></p><p><a href="https://scholar.harvard.edu/files/stratos/files/dostoevskykv.pdf">https://scholar.harvard.edu/files/stratos/files/dostoevskykv.pdf</a></p><p><a href="https://www.jianshu.com/p/8fb8f2458253">https://www.jianshu.com/p/8fb8f2458253</a></p><p><a href="https://github.com/elithnever/paperreading/blob/master/lsm-tree-1.md">https://github.com/elithnever/paperreading/blob/master/lsm-tree-1.md</a></p><p><a href="https://github.com/elithnever/paperreading/blob/master/lsm-tree-2.md">https://github.com/elithnever/paperreading/blob/master/lsm-tree-2.md</a></p><p><a href="https://github.com/elithnever/paperreading/blob/master/lsm-tree-3.md">https://github.com/elithnever/paperreading/blob/master/lsm-tree-3.md</a></p><p><a href="https://www.jianshu.com/p/3fb899684392">https://www.jianshu.com/p/3fb899684392</a></p><p><a href="https://www.youtube.com/watch?v=oUNjDHYFES8">LSM trees (Log Structured Merge Trees) - Detailed video, 印度口音, 而且没字幕</a></p><p><a href="https://www.youtube.com/watch?v=ttebJcN5bgQ">GopherCon 2017: Marty Schoch - Building a High-Performance Key/Value Store in Go</a></p><p><a href="https://zhuanlan.zhihu.com/p/80523835">https://zhuanlan.zhihu.com/p/80523835</a></p><p><a href="https://www.iteblog.com/archives/2548.html">Apache Cassandra SSTable 存储格式详解</a></p><p><a href="https://blog.csdn.net/qq_21125183/article/details/103915326">https://blog.csdn.net/qq_21125183/article/details/103915326</a></p><p><a href="https://blog.csdn.net/SweeNeil/article/details/86482781">https://blog.csdn.net/SweeNeil/article/details/86482781</a></p><p><a href="https://www.cnblogs.com/qwj-sysu/p/5640256.html">https://www.cnblogs.com/qwj-sysu/p/5640256.html</a></p><p><a href="https://daemondshu.github.io/2019/03/21/Programming/Data%20Structure/LevelDB_RocksDB/">https://daemondshu.github.io/2019/03/21/Programming/Data%20Structure/LevelDB_RocksDB/</a></p><p><a href="https://www.shuzhiduo.com/A/amd0LMe1dg/">https://www.shuzhiduo.com/A/amd0LMe1dg/</a></p><p><a href="https://blog.csdn.net/zxpoiu/article/details/116190330">https://blog.csdn.net/zxpoiu/article/details/116190330</a></p><p><a href="https://zhuanlan.zhihu.com/p/65557081">https://zhuanlan.zhihu.com/p/65557081</a></p><p><a href="https://yetanotherdevblog.com/lsm/">https://yetanotherdevblog.com/lsm/</a></p><p><a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf">https://www.cs.umb.edu/~poneil/lsmtree.pdf</a></p><p><a href="https://tikv.org/deep-dive/key-value-engine/b-tree-vs-lsm/">https://tikv.org/deep-dive/key-value-engine/b-tree-vs-lsm/</a></p><p><a href="https://www.usenix.org/conference/atc15/technical-session/presentation/wu">https://www.usenix.org/conference/atc15/technical-session/presentation/wu</a></p><p><a href="https://zhuanlan.zhihu.com/p/129355502">https://zhuanlan.zhihu.com/p/129355502</a></p><p><a href="https://www.youtube.com/watch?v=auI8BTws-f8">https://www.youtube.com/watch?v=auI8BTws-f8</a></p><p><a href="https://www.youtube.com/watch?v=_cGtupq0Ts4https://www.youtube.com/watch?v=_cGtupq0Ts4">https://www.youtube.com/watch?v=_cGtupq0Ts4https://www.youtube.com/watch?v=_cGtupq0Ts4</a></p><p><a href="https://www.youtube.com/watch?v=rnZmdmlR-2M">https://www.youtube.com/watch?v=rnZmdmlR-2M</a></p><p><a href="https://www.bilibili.com/video/BV16X4y1A7TV">https://www.bilibili.com/video/BV16X4y1A7TV</a></p><p><a href="https://arxiv.org/pdf/1812.07527.pdf">https://arxiv.org/pdf/1812.07527.pdf</a></p><ol><li><a href="https://hardcore.feishu.cn/docs/doccnKTUS5I0qkqYMg4mhfIVpOd#">LSM-论文导读与Leveldb源码解读</a></li><li><a href="https://riak.com/assets/bitcask-intro.pdf">Bitcask: A Log-Structured Hash Table for Fast Key/Value Data</a></li><li><a href="https://old-panda.com/2020/08/23/bitcask/">Bitcask 学习笔记</a></li></ol><p><a href="https://pingcap.com/blog-cn/titan-design-and-implementation">https://pingcap.com/blog-cn/titan-design-and-implementation</a></p><p><a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf">https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf</a></p><ol><li><a href="https://cloud.tencent.com/developer/article/1441835">深入理解什么是LSM-Tree</a></li></ol><p><a href="https://www.jianshu.com/p/8fb8f2458253">https://www.jianshu.com/p/8fb8f2458253</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/os/"/>
      <url>/os/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul><li>运算单元</li><li>数据单元<ul><li>缓存</li><li>寄存器组</li></ul></li><li>控制单元<ul><li>指令起始地址寄存器</li><li>数据起始地址寄存器</li><li>指令指针寄存器</li><li>指令寄存器</li></ul></li></ul><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><blockquote><p>在主板上，有一个东西叫ROM（Read Only Memory，只读存储器）。这和咱们平常说的内存RAM（Random Access Memory，随机存取存储器）不同。</p><p>咱们平时买的内存条是可读可写的，这样才能保存计算结果。而 ROM 是只读的，上面早就固化了一些初始化的程序，也就是BIOS（Basic Input and Output System，基本输入输出系统）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/os/BIOS.png" alt="BIOS"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><h2 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态&amp;内核态"></a>用户态&amp;内核态</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.jianshu.com/p/16b83e7facb9">为什么运行时程序要分成内核态和用户态</a></li><li><a href="https://blog.csdn.net/htxhtx123/article/details/104595175">什么是ring0-ring3</a></li><li><a href="https://zhuanlan.zhihu.com/p/69554144">怎样去理解Linux用户态和内核态？</a></li><li><a href="http://www.linfo.org/context_switch.html">Context Switch Definition</a></li><li><a href="https://www.cnblogs.com/inception6-lxc/p/9073983.html">https://www.cnblogs.com/inception6-lxc/p/9073983.html</a></li><li>《深入理解 LINUX 内核》</li><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a></li><li>《从实模式到保护模式》</li><li>《一个64位操作系统的设计与实现》</li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C">重学操作系统</a></li><li><a href="https://blog.csdn.net/gatieme/article/details/50779184">Linux系统调用详解（实现机制分析）–linux内核剖析（六）</a></li><li><a href="https://cloud.tencent.com/developer/article/1690556">进程间8种通信方式详解</a></li><li><a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a></li><li><a href="https://blog.csdn.net/chengm8/article/details/22884875">slab内存分配——内存池mempool</a></li></ol><p><a href="https://draveness.me/whys-the-design-linux-swapping">https://draveness.me/whys-the-design-linux-swapping</a></p><p><a href="https://draveness.me/whys-the-design-os-virtual-memory/">https://draveness.me/whys-the-design-os-virtual-memory/</a></p><p><a href="https://draveness.me/whys-the-design-syscall-overhead/">https://draveness.me/whys-the-design-syscall-overhead/</a></p><p><a href="https://draveness.me/whys-the-design-linux-default-page/">https://draveness.me/whys-the-design-linux-default-page/</a></p><p><a href="https://draveness.me/whys-the-design-cpu-and-disk/">https://draveness.me/whys-the-design-cpu-and-disk/</a></p><p><a href="https://draveness.me/whys-the-design-numa-performance">https://draveness.me/whys-the-design-numa-performance</a></p><p><a href="https://draveness.me/whys-the-design-linux-hugepages">https://draveness.me/whys-the-design-linux-hugepages</a></p><p><a href="https://draveness.me/whys-the-design-windows-defragmentation/">https://draveness.me/whys-the-design-windows-defragmentation/</a></p><p><a href="https://draveness.me/whys-the-design-linux-macos-fragmentation">https://draveness.me/whys-the-design-linux-macos-fragmentation</a></p><p><a href="https://lrita.github.io/2018/11/20/debug-cpu-cacheline-false-sharing/#%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84">https://lrita.github.io/2018/11/20/debug-cpu-cacheline-false-sharing/#%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84</a></p><p><a href="https://software.intel.com/content/www/us/en/develop/blogs/all-about-64-bit-programming-in-one-place.html">https://software.intel.com/content/www/us/en/develop/blogs/all-about-64-bit-programming-in-one-place.html</a></p><p><a href="https://coolshell.cn/articles/20793.html">https://coolshell.cn/articles/20793.html</a></p><p><a href="https://coolshell.cn/articles/10249.html">https://coolshell.cn/articles/10249.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/kafka/"/>
      <url>/kafka/</url>
      
        <content type="html"><![CDATA[<h2 id="生产者-producer"><a href="#生产者-producer" class="headerlink" title="生产者(producer)"></a>生产者(producer)</h2><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/producer-arch.jpg" alt="生产者整体架构"></p><h3 id="元数据获取"><a href="#元数据获取" class="headerlink" title="元数据获取"></a>元数据获取</h3><p>元数据记录了集群中有哪些主题、主题的分区、每个分区的leader副本配在哪个节点上、follower副本分配在哪些节点上, 哪些副本在AR、ISR集合中、集群中有哪些几点、控制器节点又是哪一个等等。</p><h3 id="重要的生产者参数"><a href="#重要的生产者参数" class="headerlink" title="重要的生产者参数"></a>重要的生产者参数</h3><ol><li>acks</li><li>max.request.size</li><li>retries</li></ol><h2 id="消费者-consumer"><a href="#消费者-consumer" class="headerlink" title="消费者(consumer)"></a>消费者(consumer)</h2><p>一个分区只会被分配给一个消费者的一个线程</p><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-offset-save.jpg" alt="消费进度的保存和恢复"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consume-flow.jpg" alt="消费者客户端的消费消息流程"></p><p>左图: 一个消费者进程里开了3个线程。<br>右图: 三个消费者进程分别开了1个线程。<br>两种都是开了3线程消费, 只不过对zk来说看到的消费组成员列表是不同的。<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-threads-vs-procs.jpg" alt="消费者进程和线程"></p><h3 id="消费者连接器"><a href="#消费者连接器" class="headerlink" title="消费者连接器"></a>消费者连接器</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-connect-text.jpg"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-connect.jpg" alt="ConsumerConnect连接器各组件协调完成消息的消费"></p><h3 id="消费者客户端的线程模型"><a href="#消费者客户端的线程模型" class="headerlink" title="消费者客户端的线程模型"></a>消费者客户端的线程模型</h3><p>使用队列作为消息的缓存<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-threads-model.jpg" alt="消费者客户端线程模型"></p><h3 id="消费组重平衡"><a href="#消费组重平衡" class="headerlink" title="消费组重平衡"></a>消费组重平衡</h3><h4 id="重平衡的条件"><a href="#重平衡的条件" class="headerlink" title="重平衡的条件"></a>重平衡的条件</h4><ol><li>组成员数量发生变化。</li><li>订阅主题数量发生变化。</li><li>订阅主题的分区数发生变化。<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-rebalance.jpg" alt="触发消费者连接器执行再平衡操作的两种方式"></li></ol><h4 id="重平衡的过程"><a href="#重平衡的过程" class="headerlink" title="重平衡的过程"></a>重平衡的过程</h4><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-pull-thread-rebalance-flow.jpg" alt="拉取线程再平衡中的关闭和更新"></p><h4 id="通知机制-消费端着端的心跳线程-Heartbeat-Thread"><a href="#通知机制-消费端着端的心跳线程-Heartbeat-Thread" class="headerlink" title="通知机制, 消费端着端的心跳线程(Heartbeat Thread)"></a>通知机制, 消费端着端的心跳线程(Heartbeat Thread)</h4><p>重平衡过程是如何通知到其他消费者实例的？答案就是，靠消费者端的心跳线程（Heartbeat Thread）</p><p>重平衡的通知机制正是通过心跳线程来完成的。当协调者决定开启新一轮重平衡后，它会将“REBALANCE_IN_PROGRESS”封装进心跳请求的响应中，发还给消费者实例。当消费者实例发现心跳响应中包含了“REBALANCE_IN_PROGRESS”，就能立马知道重平衡又开始了，这就是重平衡的通知机制。</p><h3 id="消费者消费消息"><a href="#消费者消费消息" class="headerlink" title="消费者消费消息"></a>消费者消费消息</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-main-flow.jpg" alt="消费者消费消息的主流程"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/temp2.jpg"><br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/consumer-pull-consume-state.jpg" alt="拉取线程和消费线程分别更新分区信息的状态"></p><h3 id="位移的管理"><a href="#位移的管理" class="headerlink" title="位移的管理"></a>位移的管理</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/temp1.jpg"></p><h4 id="提交偏移量到ZK"><a href="#提交偏移量到ZK" class="headerlink" title="提交偏移量到ZK"></a>提交偏移量到ZK</h4><h4 id="提交偏移量到内部位移主题"><a href="#提交偏移量到内部位移主题" class="headerlink" title="提交偏移量到内部位移主题"></a>提交偏移量到内部位移主题</h4><p>__consumer_offsets 叫位移主题, 是kafka的内部主题。该主题的默认分区数是50, 副本数是3.</p><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><h2 id="Coordinator-协调者"><a href="#Coordinator-协调者" class="headerlink" title="Coordinator(协调者)"></a>Coordinator(协调者)</h2><p>专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等</p><p>Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。</p><p>所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件。也就是说，所有 Broker 都有各自的 Coordinator 组件。那么，Consumer Group 如何确定为它服务的 Coordinator 在哪台 Broker 上呢？</p><p>确定由位移主题的哪个分区来保存该 Group 数据, 然后找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator。</p><h3 id="StickyAssignor-有粘性的分区分配策略"><a href="#StickyAssignor-有粘性的分区分配策略" class="headerlink" title="StickyAssignor(有粘性的分区分配策略)"></a>StickyAssignor(有粘性的分区分配策略)</h3><h2 id="消息代理-broker"><a href="#消息代理-broker" class="headerlink" title="消息代理(broker)"></a>消息代理(broker)</h2><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><blockquote><p>Kafka 中的索引文件以稀疏索引（sparse index）的方式构造消息的索引，它并不保证每个消息在索引文件中都有对应的索引项。</p></blockquote><h4 id="zero-copy-零拷贝"><a href="#zero-copy-零拷贝" class="headerlink" title="zero-copy(零拷贝)"></a>zero-copy(零拷贝)</h4><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/zero-copy.jpg" alt="零拷贝"></p><h3 id="控制器-controller"><a href="#控制器-controller" class="headerlink" title="控制器(controller)"></a>控制器(controller)</h3><h3 id="分区、副本"><a href="#分区、副本" class="headerlink" title="分区、副本"></a>分区、副本</h3><h4 id="消息分区机制"><a href="#消息分区机制" class="headerlink" title="消息分区机制"></a>消息分区机制</h4><ul><li>轮循策略(未指定key的默认策略)</li><li>随机策略(老版本)</li><li>根据key计算hash(指定key时的默认策略)</li></ul><h4 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h4><blockquote><p>Producer和Broker都可以配置压缩算法。其实大部分情况下 Broker 从 Producer 端接收到消息后仅仅是原封不动地保存而不会对其进行任何修改.</p><p>有两种例外情况就可能让 Broker 重新压缩消息:</p><p>情况一：Broker 端指定了和 Producer 端不同的压缩算法。</p><p>情况二：Broker 端发生了消息格式转换(Kafka集群中同时保存了多种版本的消息格式, 为了兼容老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩。)</p></blockquote><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><h4 id="Kafka里的网络模型"><a href="#Kafka里的网络模型" class="headerlink" title="Kafka里的网络模型"></a>Kafka里的网络模型</h4><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/kafka/kafka-network-thread.jpg" alt="kafka网络模型"></p><h2 id="内部元数据"><a href="#内部元数据" class="headerlink" title="内部元数据"></a>内部元数据</h2><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>ZK存储了Kafka的内部元数据, 还记录了消费组的成员列表, 分区的消费进度, 分区的所有者。节点、主题、分区、消费者、偏移量(offset)、所有权(ownership)</p><h3 id="kraft"><a href="#kraft" class="headerlink" title="kraft"></a>kraft</h3><p>2.8开始kafka去掉了zookeeper, </p><h2 id="kafka-stream"><a href="#kafka-stream" class="headerlink" title="kafka stream"></a>kafka stream</h2><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><ol><li>Producer要使用带callback的函数, 这样可以处理失败。</li><li>不开启自动提交, 而是手动提交位移</li><li>设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li><li>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li><li>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li><li>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li><li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li><li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《极客时间-Kafka核心技术与实战》</li><li>《极客时间-Kafka核心源码解读》</li><li>《深入理解Kafka：核心设计与实践原理》</li><li>《Kafka技术内幕》</li><li><a href="https://blog.csdn.net/u4110122855/article/details/103616791">Kafka分区分配策略分析——重点：StickyAssignor</a></li><li><a href="https://blog.csdn.net/u013256816/article/details/81123625">Kafka分区分配策略（2）——RoundRobinAssignor和StickyAssignor</a></li><li><a href="https://www.cnblogs.com/huxi2b/">https://www.cnblogs.com/huxi2b/</a></li><li><a href="https://www.confluent.io/blog/">https://www.confluent.io/blog/</a></li><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Index">https://cwiki.apache.org/confluence/display/KAFKA/Index</a></li><li><a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+papers+and+presentations">https://cwiki.apache.org/confluence/display/KAFKA/Kafka+papers+and+presentations</a></li><li><a href="https://blog.csdn.net/yjh314/article/details/78863875">https://blog.csdn.net/yjh314/article/details/78863875</a></li><li><a href="https://www.jianshu.com/p/afd5da6a92ab">https://www.jianshu.com/p/afd5da6a92ab</a></li><li><a href="https://blog.csdn.net/nazeniwaresakini/article/details/116085573">https://blog.csdn.net/nazeniwaresakini/article/details/116085573</a></li><li><a href="https://zhuanlan.zhihu.com/p/368600560">https://zhuanlan.zhihu.com/p/368600560</a></li><li><a href="https://zhenghe-md.github.io/blog/2020/03/15/Kafka-a-Distributed-Messaging-System-for-Log-Processing-2011/">Kafka: a Distributed Messaging System for Log Processing (2011)</a></li><li><a href="https://blog.csdn.net/csdnnews/article/details/99256826">拿来就能用！去哪儿网消息中间件 QMQ 详解 | 技术头条</a></li><li><a href="http://blog.chinaunix.net/uid-26111972-id-5845593.html">关于kafka消费者处理消息异常实验</a></li><li><a href="https://www.jianshu.com/p/2effb654e1f4">kafka之消费超时死循环</a></li><li><a href="https://jaskey.github.io/blog/2020/06/08/rocketmq-message-dedup/">消息幂等（去重）通用解决方案，RocketMQ</a></li><li><a href="https://support.huaweicloud.com/bestpractice-kafka/kafka-bp-190605002.html">如何提高消息处理效率</a></li></ol><p><a href="http://notes.stephenholiday.com/Kafka.pdf">http://notes.stephenholiday.com/Kafka.pdf</a></p><p><a href="https://medium.com/@andy.bryant/processing-guarantees-in-kafka-12dd2e30be0e">https://medium.com/@andy.bryant/processing-guarantees-in-kafka-12dd2e30be0e</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang栈空间管理</title>
      <link href="/golang-stack/"/>
      <url>/golang-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h2><p>不同架构下, 默认线程栈的大小不同。在x86_64架构下, 默认栈大小为2MB</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 悬挂指针示例</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">dangling_pointer</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>当 dangling_pointer 函数返回后，它的本地变量会被编译器回收，调用方获取的是危险的悬挂指针，我们不确定当前指针指向的值是否合法时，这种问题在大型项目中是比较难以发现和定位的。</p></blockquote><blockquote><p>Go 语言的逃逸分析遵循以下两个不变性：</p><ol><li>指向栈对象的指针不能存在于堆中 (一旦函数返回后函数栈会被回收，该指针指向的值就不再合法)</li><li>指向栈对象的指针不能在栈对象回收后存活(栈底部有一个指针指向了栈顶, 那么当栈顶的函数释放后, 栈底的指针不再合法)</li></ol></blockquote><h2 id="栈内存空间"><a href="#栈内存空间" class="headerlink" title="栈内存空间"></a>栈内存空间</h2><blockquote><p>Goroutine 的栈内存空间和栈结构也在早期几个版本中发生过一些变化：</p><ol><li>v1.0 ~ v1.1 — 最小栈内存空间为 4KB</li><li>v1.2 — 将最小栈内存提升到了 8KB(其目的是为了减轻分段栈中的栈分裂对程序的性能影响)</li><li>v1.3 — 使用连续栈替换之前版本的分段栈</li><li>v1.4 — 将最小栈内存降低到了 2KB</li></ol></blockquote><h2 id="分段栈"><a href="#分段栈" class="headerlink" title="分段栈"></a>分段栈</h2><blockquote><p>当 Goroutine 调用的函数层级或者局部变量需要的越来越多时，运行时会调用 runtime.morestack:go1.2 和 runtime.newstack:go1.2 创建一个新的栈空间，这些栈空间虽然不连续，但是当前 Goroutine 的多个栈空间会以链表的形式串联起来，运行时会通过指针找到连续的栈片段</p></blockquote><blockquote><p>分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：</p><ol><li>如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）；</li><li>一旦 Goroutine 使用的内存越过了分段栈的扩缩容阈值，运行时会触发栈的扩容和缩容，带来额外的工作量；</li></ol></blockquote><h2 id="连续栈"><a href="#连续栈" class="headerlink" title="连续栈"></a>连续栈</h2><blockquote><p>分段栈的扩张操作是在另一个栈上进行的，这两个栈彼此没有连续。这种设计的缺陷很容易破坏缓存的局部性原理，从而降低程序的运行时性能</p></blockquote><blockquote><p>使用连续栈而不是分段栈的目的是，利用局部性优势提升执行速度，原理是CPU读取地址时会将相邻的内存读取到访问速度比内存快的多级cache中，地址连续性越好，L1、L2、L3 cache命中率越高，速度也就越快</p></blockquote><blockquote><p>栈的收缩是垃圾回收的过程中实现的．当检测到栈只使用了不到1/4时，栈缩小为原来的1/2</p></blockquote><h2 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h2><ol><li><a href="https://tonybai.com/2014/11/05/how-stacks-are-handled-in-go/">Go语言是如何处理栈的</a></li><li><a href="http://www.huamo.online/2019/06/25/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6goroutine%E6%A0%88/">深入研究goroutine栈</a></li><li><a href="https://segmentfault.com/a/1190000023340324">函数——go世界中的一等公民</a></li><li><a href="https://www.jianshu.com/p/7ec9acca6480">深入理解golang 的栈</a></li></ol><p><a href="https://kirk91.github.io/posts/2d571d09/">https://kirk91.github.io/posts/2d571d09/</a></p><p><a href="https://www.luozhiyun.com/archives/513">https://www.luozhiyun.com/archives/513</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/</a></p><p><a href="https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.3-escape_analysis.md">https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.3-escape_analysis.md</a></p><ol><li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html">深入解析go-连续栈</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web开发安全</title>
      <link href="/web-security/"/>
      <url>/web-security/</url>
      
        <content type="html"><![CDATA[<h2 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h2><h2 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h2><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>攻击者将恶意代码提交到目标网站的数据库中</p><h3 id="反射性"><a href="#反射性" class="headerlink" title="反射性"></a>反射性</h3><p>攻击者构造出特殊的 URL，其中包含恶意代码, 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</p><h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>攻击者构造出特殊的 URL，其中包含恶意代码。用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</p><h2 id="CSRF攻击-跨站请求伪造"><a href="#CSRF攻击-跨站请求伪造" class="headerlink" title="CSRF攻击(跨站请求伪造)"></a>CSRF攻击(跨站请求伪造)</h2><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><h3 id="堆查询注入"><a href="#堆查询注入" class="headerlink" title="堆查询注入"></a>堆查询注入</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html">前端安全系列（一）：如何防止XSS攻击？</a></li><li><a href="http://www.ttlsa.com/safe/xss-description/">反射型XSS漏洞详解</a></li><li><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">前端安全系列（二）：如何防止CSRF攻击？</a></li><li><a href="http://www.eggie5.com/45-hmac-timing-attacks">HMAC Timing Attacks</a></li><li><a href="https://coolshell.cn/articles/21003.html">HMAC Timing Attacks</a></li><li><a href="https://www.cnblogs.com/jazzka702/p/11875728.html">SQL注入漏洞详解</a></li><li><a href="https://www.kancloud.cn/digest/mysqlsummary/132837">Mysql分页负数sql攻击</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang channel</title>
      <link href="/golang-channel/"/>
      <url>/golang-channel/</url>
      
        <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> {</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 循环列表元素个数. chan 中已经接收但还没被取走的元素的个数，函数 len 可以返回这个字段的值</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 循环队列的大小, cap函数可以返回这个字段的值</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 循环队列的指针</span></span><br><span class="line">    elemsize <span class="type">uint16</span>         <span class="comment">// chan中元素的大小</span></span><br><span class="line">    closed   <span class="type">uint32</span>         <span class="comment">// 是否已close</span></span><br><span class="line">    elemtype *_type         <span class="comment">// chan中元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>           <span class="comment">// send在buffer中的索引</span></span><br><span class="line">    recvx    <span class="type">uint</span>           <span class="comment">// recv在buffer中的索引</span></span><br><span class="line">    recvq    waitq          <span class="comment">// receiver的等待队列</span></span><br><span class="line">    sendq    waitq          <span class="comment">// sender的等待队列 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 互拆锁</span></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>sendq和recvq的类型是waitq的结构体：</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> {</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>waitq里面连接的是一个sudog双向链表，保存的是等待的goroutine 。整个chan的图例大概是这样：<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/golang-channel/golang-chan-sudog.png" alt="channel内部结构-整体"></p><p>我们通过汇编结果也可以查看到make(chan int)这句代码会调用到runtime的makechan函数中：</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maxAlign是8，那么maxAlign-1的二进制就是111，然后和int(unsafe.Sizeof(hchan{}))取与就是取它的低三位，hchanSize就得到的是8的整数倍，做对齐使用。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    maxAlign  = <span class="number">8</span></span><br><span class="line">    hchanSize = unsafe.Sizeof(hchan{}) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan{}))&amp;(maxAlign<span class="number">-1</span>)) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan {</span><br><span class="line">    elem := t.elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略去检查代码</span></span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//计算需要分配的buf空间</span></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> {</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> {</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>: <span class="comment">// 缓冲区所需大小为 0，那么在为 hchan 分配内存时，只需要分配 sizeof(hchan) 大小的内存</span></span><br><span class="line">        <span class="comment">// chan的size或者元素的size是0，不必创建buf</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// Race detector </span></span><br><span class="line">        c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>: <span class="comment">// 缓冲区所需大小不为 0，而且数据类型不是指针，那么就分配连续的内存</span></span><br><span class="line">        <span class="comment">// 元素不是指针，分配一块连续的内存给hchan数据结构和buf</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">        <span class="comment">// 表示hchan后面在内存里紧跟着就是buf</span></span><br><span class="line">        c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 缓冲区所需大小不为 0，而且数据类型包含指针，那么就不使用add的方式让hchan和buf放在一起了，而是单独的为buf申请一块内存</span></span><br><span class="line">        <span class="comment">// 元素包含指针，那么单独分配buf</span></span><br><span class="line">        c = <span class="built_in">new</span>(hchan)</span><br><span class="line">        c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素大小、类型、容量都记录下来</span></span><br><span class="line">    c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>chansend 函数是在编译器解析到 c &lt;- x 这样的代码的时候插入的，本质上就是把一个用户元素投递到 hchan 的 ringbuffer 中。chansend 调用的时候，一般用户会遇到两种情况：</p><p>投递成功，非常顺利，正常返回<br>投递受阻，该函数阻塞，goroutine 切走</p><p>接下来，我们看下 chansend 究竟是做了什么。</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line">    <span class="comment">// channel 的所有操作，都在互斥锁下；</span></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 如果投递的目标是已经关闭的 channel，那么直接 panic；</span></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> {</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 场景一：性能最好的场景，我投递的元素刚好有人在等着（那我直接给他就完了）;</span></span><br><span class="line">    <span class="comment">// 调用的是 send 函数，这个函数后面详细阐述，其实非常简单，递增 sendx, recvx 的索引，然后直接把元素给到等他的人，并且唤醒他；</span></span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> {</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { unlock(&amp;c.lock) }, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 场景二：ringbuffer 还有空间，那么把元素放好，递增索引，就可以返回了；</span></span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz {</span><br><span class="line">        <span class="comment">// 复制，赋值好元素；</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 递增索引</span></span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="comment">// 回环空间</span></span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz {</span><br><span class="line">            c.sendx = <span class="number">0</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 递增元素个数</span></span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断是否需要阻塞？如果是非阻塞的，那么就直接解锁返回了，如果是阻塞的场景，那么就会走到下面的逻辑哦；</span></span><br><span class="line">    <span class="comment">// chan &lt;- 和 &lt;-chan 的场景，都是 true，但是会有其他场景这里是 false，可以提前想下？</span></span><br><span class="line">    <span class="keyword">if</span> !block {</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 代码走到这里，说明都是因为条件不满足，要阻塞当前 goroutine，所以做的事情本质上就是保留好通知路径，等待条件满足，会在这个地方唤醒；</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="number">0</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.isSelect = <span class="literal">false</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 把 goroutine 相关的线索结构入队，等待条件满足的唤醒；</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// goroutine 切走，让出 cpu 执行权限；</span></span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这就是某些人唤醒该 goroutine 了。</span></span><br><span class="line">    <span class="comment">// 下面就是唤醒之后的逻辑了；</span></span><br><span class="line">    <span class="keyword">if</span> mysg != gp.waiting {</span><br><span class="line">        throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 做一些资源的释放和环境的清理。</span></span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> gp.param == <span class="literal">nil</span> {</span><br><span class="line">        <span class="comment">// 做一些校验</span></span><br><span class="line">        <span class="keyword">if</span> c.closed == <span class="number">0</span> {</span><br><span class="line">            throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    }</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译器在遇到 &lt;-c 和 v, ok := &lt;-c  的语句的时候，会换成对应的 chanrecv1 ，chanrecv2 函数，这两个函数本质上都是一个简单的封装，元素出队的实现函数是 chanrecv ，我们详细分析下这个函数。block 都等于 true（同样的，只有 select 的时候，block 才会是 false ）</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) {</span><br><span class="line"><span class="comment">// 特殊场景：非阻塞模式，并且没有元素的场景直接就可以返回了，这个分支是快速分支，下面的代码都是在锁内的；</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下所有的逻辑都在锁内；</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">if</span> raceenabled {</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">}</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> {</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：如果发现有个人（sender）正在等着别人接收，那么刚刚好，直接把它的元素给到我们这里就好了；</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> {</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { unlock(&amp;c.lock) }, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：ringbuffer 还有空间存元素，那么下面就可以把元素放到 ringbuffer 放好，递增索引，就可以返回了；</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> {</span><br><span class="line"><span class="comment">// 存元素</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> {</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">}</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line"><span class="comment">// 递增索引</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz {</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">}</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码到这说明 ringbuffer 空间是不够的，后面学会要做两个事情，是否需要阻塞？</span></span><br><span class="line"><span class="comment">// 如果 block 为 false ，那么直接就退出了，返回对应的返回值；</span></span><br><span class="line"><span class="keyword">if</span> !block {</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这就说明要阻塞等待了，下面唯一要做的就是给阻塞做准备（准备好唤醒的条件）</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// goroutine 作为一个 waiter 入队列，等待条件满足之后，从这个队列里取出来唤醒；</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line"><span class="comment">// goroutine 切走，交出 cpu 执行权限</span></span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是被唤醒的开始的地方；</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting {</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 下面做一些资源的清理</span></span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《极客时间-Go并发编程实战》</li><li><a href="https://www.luozhiyun.com/archives/427">多图详解Go中的Channel源码</a></li><li><a href="https://talkgo.org/t/topic/75">channel &amp; select 源码分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/101063277">Go语言的有缓冲channel和无缓冲channel</a></li><li><a href="https://speakerdeck.com/kavya719/understanding-channels">https://speakerdeck.com/kavya719/understanding-channels</a></li><li><a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8">https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8</a></li><li><a href="https://blog.csdn.net/weixin_30257433/article/details/101833959">https://blog.csdn.net/weixin_30257433/article/details/101833959</a></li><li><a href="https://segmentfault.com/a/1190000017958702">https://segmentfault.com/a/1190000017958702</a></li><li><a href="https://juejin.cn/post/6895738899348324359">https://juejin.cn/post/6895738899348324359</a></li></ol><p><a href="http://legendtkl.com/2017/08/06/golang-channel-implement/">http://legendtkl.com/2017/08/06/golang-channel-implement/</a></p><p><a href="https://www.pengrl.com/p/21027/">https://www.pengrl.com/p/21027/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redlock</title>
      <link href="/redlock/"/>
      <url>/redlock/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。</p></blockquote><blockquote><p>客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</p></blockquote><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>相比于单机模式, 更加高可用</li><li>相比于主从模式, 不需要在故障时手动将从节点调整为主节点</li><li>哨兵模式在主节点挂掉时不需要手动调整节点, 如果Master数据没有同步到Slave, 会导致两个client同时占有锁</li><li>cluster模式下, 在Master挂掉时, 也有可能没有来得及同步数据给Slave, 导致同时占用两把锁。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>依赖本地时钟</li><li>当redis实例挂掉后, 可能会丢失持久化数据, 使得另一个client抢锁成功</li><li>当client占用锁超过租约期限后, 会有另一个client抢锁成功。这时会2个client同时占用锁。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html">https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html</a></p><p><a href="https://zhenghe-md.github.io/blog/2020/03/22/Distributed-Locking/">https://zhenghe-md.github.io/blog/2020/03/22/Distributed-Locking/</a></p><p><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p><p><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p><p><a href="http://courses.csail.mit.edu/6.852/08/papers/CT96-JACM.pdf">http://courses.csail.mit.edu/6.852/08/papers/CT96-JACM.pdf</a></p><p><a href="http://antirez.com/news/101">http://antirez.com/news/101</a></p><p><a href="https://studygolang.com/articles/3126">https://studygolang.com/articles/3126</a></p><p><a href="https://www.cnblogs.com/mkl34367803/p/14649897.html">https://www.cnblogs.com/mkl34367803/p/14649897.html</a></p><ol><li><a href="https://segmentfault.com/a/1190000022024288">【求锤得锤的故事】Redis锁从面试连环炮聊到神仙打架。</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang 垃圾回收</title>
      <link href="/golang-gc/"/>
      <url>/golang-gc/</url>
      
        <content type="html"><![CDATA[<h2 id="GC-roots"><a href="#GC-roots" class="headerlink" title="GC roots"></a>GC roots</h2><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><p>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。<br>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。<br>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</p><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><ul><li>白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；</li><li>黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li></ul><h3 id="三色不变性"><a href="#三色不变性" class="headerlink" title="三色不变性"></a>三色不变性</h3><blockquote><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p></blockquote><ul><li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li></ul><h3 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h3><blockquote><p>插入写屏障会将有存活可能的对象都标记成灰色以满足强三色不变性。</p></blockquote><blockquote><p>将指针指向的新值置为灰色</p></blockquote><h3 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h3><blockquote><p>在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p></blockquote><h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">Go语言设计与实现-垃圾收集器</a></li><li><a href="https://segmentfault.com/a/1190000022030353">[典藏版]Golang三色标记、混合写屏障GC模式图文全分析</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/">golang设计-垃圾回收</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/">legendtkl-Golang 垃圾回收剖析</a></li><li><a href="https://www.bilibili.com/video/BV1wz4y1y7Kd">Golang中GC回收机制三色标记与混合写屏障</a></li><li><a href="https://www.kancloud.cn/aceld/golang/1958308">Golang三色标记+混合写屏障GC模式全分析</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/107291523?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162753862316780366532920%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162753862316780366532920&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-107291523.pc_v2_rank_blog_default&amp;utm_term=golang+%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&amp;spm=1018.2226.3001.4450">golang 垃圾回收（四）删除写屏障</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/107622603">golang 垃圾回收（五）深入剖析混合写屏障</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/barrier/">Go 语言原本-写屏障技术</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/107738258?spm=1001.2014.3001.5501">深度剖析 Golang 的 GC 扫描对象实现</a></li><li><a href="https://blog.csdn.net/QcloudCommunity/article/details/119397102">自动的内存管理系统实操手册——Golang垃圾回收篇</a></li></ol><p><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/">https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/</a></p><p><a href="https://blog.csdn.net/weixin_34248849/article/details/88987666">https://blog.csdn.net/weixin_34248849/article/details/88987666</a></p><p><a href="http://www.52codes.net/develop/shell/56961.html">http://www.52codes.net/develop/shell/56961.html</a></p><p><a href="https://www.cnblogs.com/badcw/p/14192895.html">https://www.cnblogs.com/badcw/p/14192895.html</a></p><p><a href="https://weibo.com/ttarticle/p/show?id=2309404620360724382113#_loginLayer_1623600085589">https://weibo.com/ttarticle/p/show?id=2309404620360724382113#_loginLayer_1623600085589</a></p><p><a href="https://weibo.com/ttarticle/p/show?id=2309404620723120373979">https://weibo.com/ttarticle/p/show?id=2309404620723120373979</a></p><p><a href="http://www.360doc.com/content/21/0416/22/15690396_972688492.shtml">http://www.360doc.com/content/21/0416/22/15690396_972688492.shtml</a></p><p><a href="https://www.cnblogs.com/saryli/p/10105393.html">https://www.cnblogs.com/saryli/p/10105393.html</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a></p><p><a href="https://talks.golang.org/2015/go-gc.pdf">https://talks.golang.org/2015/go-gc.pdf</a></p><p><a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a></p><p><a href="https://www.oschina.net/translate/go-gc-solving-the-latency-problem-in-go-1-5?comments&amp;p=1">https://www.oschina.net/translate/go-gc-solving-the-latency-problem-in-go-1-5?comments&amp;p=1</a></p><p><a href="https://www.jianshu.com/p/bfc3c65c05d1?utm_source=wechat_session">https://www.jianshu.com/p/bfc3c65c05d1?utm_source=wechat_session</a></p><p><a href="https://www.bilibili.com/video/BV1Ui4y1F7n3/?spm_id_from=333.788.recommend_more_video.0">https://www.bilibili.com/video/BV1Ui4y1F7n3/?spm_id_from=333.788.recommend_more_video.0</a></p><p><a href="https://xie.infoq.cn/article/67cfd494e6e10cd0b40de95ab">https://xie.infoq.cn/article/67cfd494e6e10cd0b40de95ab</a></p><p><a href="https://zhuanlan.zhihu.com/p/297177002">https://zhuanlan.zhihu.com/p/297177002</a></p><p><a href="https://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/">https://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/</a></p><p><a href="https://learnku.com/docs/go-blog/ismmkeynote/6499">https://learnku.com/docs/go-blog/ismmkeynote/6499</a></p><p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html</a></p><p><a href="https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.2-garbage_collection.md">https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.2-garbage_collection.md</a></p><p><a href="https://docs.kilvn.com/go-internals/06.2.html">https://docs.kilvn.com/go-internals/06.2.html</a></p><p><a href="https://www.youtube.com/watch?v=q4HoWwdZUHs">Garbage Collection Semantics - GopherCon SG 2019</a></p><p><a href="https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05">https://medium.com/a-journey-with-go/go-memory-management-and-memory-sweep-cc71b484de05</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35">https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-watch-your-application-dbef99be2c35</a></p><p><a href="https://medium.com/a-journey-with-go/go-keeping-a-variable-alive-c28e3633673a">https://medium.com/a-journey-with-go/go-keeping-a-variable-alive-c28e3633673a</a></p><p><a href="https://www.tyx.pub/archives/148">https://www.tyx.pub/archives/148</a></p><p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a></p><p><a href="https://talks.golang.org/2015/go-gc.pdf">https://talks.golang.org/2015/go-gc.pdf</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/11970-decentralized-gc.md">https://github.com/golang/proposal/blob/master/design/11970-decentralized-gc.md</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md">https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md">https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> gc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gc </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go内存管理</title>
      <link href="/golang-memory-allocator/"/>
      <url>/golang-memory-allocator/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h2><h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><blockquote><p>runtime.mspan 是 Go 语言内存管理的基本单元</p></blockquote><blockquote><p>每个 runtime.mspan 都管理 npages 个大小为 8KB 的页</p></blockquote><blockquote><p>runtime.spanClass 是 runtime.mspan 的跨度类，它决定了内存管理单元中存储的对象大小和个数</p></blockquote><h3 id="线程缓存-mcache"><a href="#线程缓存-mcache" class="headerlink" title="线程缓存(mcache)"></a>线程缓存(mcache)</h3><blockquote><p>runtime.mcache 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 68 * 2 个 runtime.mspan，这些内存管理单元都存储在结构体的 alloc 字段中。其中68个scan, 另外68个noscan</p></blockquote><h3 id="中心缓存-mcentral"><a href="#中心缓存-mcentral" class="headerlink" title="中心缓存(mcentral)"></a>中心缓存(mcentral)</h3><blockquote><p>runtime.mcentral 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁</p></blockquote><blockquote><p>每个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 runtime.spanSet，分别存储包含空闲对象和不包含空闲对象的内存管理单元。</p></blockquote><h3 id="页堆-mheap"><a href="#页堆-mheap" class="headerlink" title="页堆(mheap)"></a>页堆(mheap)</h3><blockquote><p>runtime.mheap 是内存分配的核心结构体，Go 语言程序会将其作为全局变量存储，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 central，另一个是管理堆区内存区域的 arenas 以及相关字段。</p></blockquote><blockquote><p>页堆中包含一个长度为 136 的 runtime.mcentral 数组，其中 68 个为跨度类需要 scan 的中心缓存，另外的 68 个是 noscan 的中心缓存</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ol><li><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/">内存分配器</a></li><li><a href="https://www.bilibili.com/video/BV1Ja4y1i7AF/?spm_id_from=333.788.recommend_more_video.7">【Golang】这个内存对齐呀！？</a></li><li><a href="https://studygolang.com/articles/22652?fr=sidebar">从源码讲解 golang 内存分配</a></li><li><a href="https://www.luozhiyun.com/archives/434">详解Go中内存分配源码实现</a></li><li><a href="https://deepu.tech/memory-management-in-golang/">🚀 Visualizing memory management in Golang</a></li><li><a href="https://medium.com/@ankur_anand/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">A visual guide to Go Memory Allocator from scratch (Golang)</a></li><li><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc : Thread-Caching Malloc</a></li><li><a href="http://legendtkl.com/2017/04/02/golang-alloc/">Golang 内存管理</a></li><li><a href="https://zhuanlan.zhihu.com/p/93838586">带你领略Go源码的魅力—-Go内存原理详解</a></li><li><a href="https://golang.org/ref/mem">The Go Memory Model</a></li><li><a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">Go: Memory Management and Allocation</a></li><li><a href="https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/">可视化Go内存管理</a></li><li><a href="https://tonybai.com/2020/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/">图解Go内存分配器</a></li><li><a href="https://qiankunli.github.io/2020/11/22/go_mm.html">go 内存管理</a></li><li><a href="https://zhuanlan.zhihu.com/p/323915446">Go runtime剖析系列（一）：内存管理</a></li><li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.0.html">内存管理</a></li><li><a href="https://github.com/LeoYang90/Golang-Internal-Notes/blob/master/Go%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md">Go 内存管理</a></li><li><a href="https://talkgo.org/t/topic/103">go夜读-图解 Go 之内存对齐</a></li><li><a href="https://bbs.huaweicloud.com/blogs/254749">栈的运行速度比堆快？ 栈堆详解</a></li></ol><p><a href="https://xie.infoq.cn/article/ee1d2416d884b229dfe57bbcc">https://xie.infoq.cn/article/ee1d2416d884b229dfe57bbcc</a></p><p><a href="https://juejin.cn/post/6844904005215207432">https://juejin.cn/post/6844904005215207432</a></p><p><a href="https://juejin.cn/post/6844903795739082760">https://juejin.cn/post/6844903795739082760</a></p><p><a href="https://cloud.tencent.com/developer/article/1771373">https://cloud.tencent.com/developer/article/1771373</a></p><p><a href="https://www.jianshu.com/p/1f0a0ec2d661">https://www.jianshu.com/p/1f0a0ec2d661</a></p><p><a href="https://www.techug.com/post/manual-memory-management-in-go.html">https://www.techug.com/post/manual-memory-management-in-go.html</a></p><p><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/">https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/</a></p><p><a href="https://wudaijun.com/2019/09/go-performance-optimization/">https://wudaijun.com/2019/09/go-performance-optimization/</a></p><p><a href="https://gfw.go101.org/article/memory-block.html">https://gfw.go101.org/article/memory-block.html</a></p><p><a href="http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html">http://blog.newbmiao.com/2018/08/20/go-source-analysis-of-memory-alloc.html</a></p><p><a href="https://ilifes.com/golang/memory-alloc/">https://ilifes.com/golang/memory-alloc/</a></p><p><a href="https://www.diglog.com/story/1035817.html">https://www.diglog.com/story/1035817.html</a></p><p><a href="https://gohalo.me/post/golang-concept-memory-management-module-introduce.html">https://gohalo.me/post/golang-concept-memory-management-module-introduce.html</a></p><p><a href="http://www.djaigo.com/golang/golang-nei-cun-guan-li.html">http://www.djaigo.com/golang/golang-nei-cun-guan-li.html</a></p><p><a href="https://omen.ltd/archives/12/">https://omen.ltd/archives/12/</a></p><p><a href="https://www.happyxhw.cn/memory/">https://www.happyxhw.cn/memory/</a></p><p><a href="http://www.zhangfuguan.top/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">http://www.zhangfuguan.top/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html</a></p><p><a href="https://mp.weixin.qq.com/s/rydO2JK-r8JjG9v_Uy7gXg">https://mp.weixin.qq.com/s/rydO2JK-r8JjG9v_Uy7gXg</a></p><p><a href="https://andblog.cn/?p=2887">https://andblog.cn/?p=2887</a></p><p><a href="https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.1-memory_alloc.md">https://www.bookstack.cn/read/GoExpertProgramming/chapter04-4.1-memory_alloc.md</a></p><p><a href="https://www.youtube.com/watch?v=ZMZpH4yT7M0">Understanding Allocations: the Stack and the Heap - GopherCon SG 2019</a><br><a href="youtube.com/watch?v=3CR4UNMK_Is">GopherCon UK 2018: Andre Carvalho - Understanding Go’s Memory Allocator</a><br><a href="https://www.youtube.com/watch?v=NzhH0p32fMY">The Go Memory Model: GoSF Meetup, 1/23/19</a></p><p><a href="https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/">https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/</a></p><p><a href="https://tonybai.com/2020/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/">https://tonybai.com/2020/02/20/a-visual-guide-to-golang-memory-allocator-from-ground-up/</a></p><p><a href="https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md">https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md</a></p><p><a href="https://docs.google.com/document/d/1un-Jn47yByHL7I0aVIP_uVCMxjdM5mpelJhiKlIqxkE/edit#heading=h.bvezjdnoi4no">https://docs.google.com/document/d/1un-Jn47yByHL7I0aVIP_uVCMxjdM5mpelJhiKlIqxkE/edit#heading=h.bvezjdnoi4no</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5">https://medium.com/a-journey-with-go/go-how-does-the-goroutine-stack-size-evolve-447fc02085e5</a></p><p><a href="https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub">https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>b树</title>
      <link href="/b-tree/"/>
      <url>/b-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><blockquote><ol><li>由于 B 树的非叶结点也可以存储数据，所以查询一条数据所需要的平均随机 IO 次数会比 B+ 树少，使用 B 树的 MongoDB 在类似场景中的查询速度就会比 MySQL 快。</li><li>读多写少的场景下, B树 比 LSM-tree 更合适。</li></ol></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《Modern B-Tree Techniques》</li><li><a href="https://blog.csdn.net/weixin_32666923/article/details/113452107">为什么 MongoDB 使用 B 树</a></li><li><a href="https://blog.csdn.net/weixin_41987908/article/details/105255119">为什么MongoDB使用B树</a></li><li><a href="https://mongoing.com/topic/archives-35143">WiredTiger存储引擎之一：基础数据结构分析</a></li><li><a href="https://blog.csdn.net/u010916338/article/details/86134334">B树</a></li><li><a href="https://juejin.cn/post/6844904136576598029">为什么MongoDB使用B-Tree,Mysql使用B+Tree ?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> data structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> data structure </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT</title>
      <link href="/mqtt/"/>
      <url>/mqtt/</url>
      
        <content type="html"><![CDATA[<h2 id="QoS"><a href="#QoS" class="headerlink" title="QoS"></a>QoS</h2><h3 id="QoS0"><a href="#QoS0" class="headerlink" title="QoS0"></a>QoS0</h3><blockquote><p>最多一次送达。也就是发出去就fire掉，没有后面的事情了。</p></blockquote><h3 id="QoS1"><a href="#QoS1" class="headerlink" title="QoS1"></a>QoS1</h3><blockquote><p>QoS 1 也好理解，我发一个带messageid的消息出去，对方收到了，给我回一个带messageid的ack，我才认为数据收到了。</p></blockquote><h3 id="QoS2"><a href="#QoS2" class="headerlink" title="QoS2"></a>QoS2</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mqtt/qos2-detail.jpg" alt="QoS2的交互过程"></p><h4 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h4><ul><li>publish下发失败了，服务器重发publish。</li><li>pubrec上报失败了，服务器重发publish。这个时候，客户端仍然是重复收到多次publish。</li><li>pubrel下发失败了，服务器重发pubrel。</li><li>pubcomp上报失败了，服务器重发pubrel。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/zerooffdate/article/details/78950907">MQTT协议QoS2 准确一次送达的实现</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/">MQTT协议中文版</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CAP/BASE/ACID</title>
      <link href="/cap-base-and-acid/"/>
      <url>/cap-base-and-acid/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li><li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/13yan/p/9243669.html">【翻译】Brewer’s CAP Theorem CAP定理</a></li></ol><p><a href="http://duanple.com/?p=163">http://duanple.com/?p=163</a></p><p><a href="https://www.julianbrowne.com/article/brewers-cap-theorem">https://www.julianbrowne.com/article/brewers-cap-theorem</a></p><p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86</a></p><p><a href="https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/">https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/</a></p><p><a href="http://duanple.com/?p=143">http://duanple.com/?p=143</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.67.6951&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.67.6951&amp;rep=rep1&amp;type=pdf</a></p><p><a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2PC 和 3PC</title>
      <link href="/2pc-and-3pc/"/>
      <url>/2pc-and-3pc/</url>
      
        <content type="html"><![CDATA[<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC 方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p><ol><li>性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li><li>可靠性问题：如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li><li>数据一致性问题：在阶段 2 中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li></ol><h3 id="情况一：协调者挂了，参与者没挂"><a href="#情况一：协调者挂了，参与者没挂" class="headerlink" title="情况一：协调者挂了，参与者没挂"></a>情况一：协调者挂了，参与者没挂</h3><p>这种情况其实比较好解决，只要找一个协调者的替代者。当他成为新的协调者的时候，询问所有参与者的最后那条事务的执行情况，他就可以知道是应该做什么样的操作了。所以，这种情况不会导致数据不一致。</p><h3 id="情况二：参与者挂了，协调者没挂"><a href="#情况二：参与者挂了，协调者没挂" class="headerlink" title="情况二：参与者挂了，协调者没挂"></a>情况二：参与者挂了，协调者没挂</h3><p>这种情况其实也比较好解决。如果参与者挂了。那么之后的事情有两种情况：</p><p>第一个是挂了就挂了，没有再恢复。那就挂了呗，反正不会导致数据一致性问题。</p><p>第二个是挂了之后又恢复了，这时如果他有未执行完的事务操作，直接取消掉，然后询问协调者目前我应该怎么做，协调者就会比对自己的事务执行记录和该参与者的事务执行记录，告诉他应该怎么做来保持数据的一致性。</p><h3 id="情况三：参与者挂了，协调者也挂了"><a href="#情况三：参与者挂了，协调者也挂了" class="headerlink" title="情况三：参与者挂了，协调者也挂了"></a>情况三：参与者挂了，协调者也挂了</h3><h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p>优点：相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。</p><p>缺点：在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。 所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><h2 id="TCC-和两阶段分布式事务处理的区别"><a href="#TCC-和两阶段分布式事务处理的区别" class="headerlink" title="TCC 和两阶段分布式事务处理的区别"></a>TCC 和两阶段分布式事务处理的区别</h2><p>当讨论 2PC 时，我们只专注于事务处理阶段，因而只讨论 prepare 和 commit，所以，可能很多人都忘了，使用 2PC 事务管理机制时也是有业务逻辑阶段的。正是因为业务逻辑的执行，发起了全局事务，这才有其后的事务处理阶段。实际上，使用 2PC 机制时，以提交为例</p><p>一个完整的事务生命周期是：begin -&gt; 业务逻辑 -&gt; prepare -&gt; commit。</p><p>再看 TCC，也不外乎如此。我们要发起全局事务，同样也必须通过执行一段业务逻辑来实现。该业务逻辑一来通过执行触发 TCC 全局事务的创建；二来也需要执行部分数据写操作；此外，还要通过执行来向 TCC 全局事务注册自己，以便后续 TCC 全局事务 commit/rollback 时回调其相应的 confirm/cancel 业务逻辑。所以，使用 TCC 机制时，以提交为例</p><p>一个完整的事务生命周期是：begin -&gt; 业务逻辑 (try 业务) -&gt; commit (comfirm 业务)。</p><p>综上，我们可以从执行的阶段上将二者一一对应起来：</p><ol><li>2PC 机制的业务阶段 等价于 TCC 机制的 try 业务阶段；</li><li>2PC 机制的提交阶段（prepare &amp; commit） 等价于 TCC 机制的提交阶段（confirm）；</li><li>2PC 机制的回滚阶段（rollback） 等价于 TCC 机制的回滚阶段（cancel）。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/monkeyblog/p/10449363.html">关于分布式事务，XA协议的学习笔记（整理转载）</a></li><li><a href="https://zhuanlan.zhihu.com/p/38177650">分布式事务中2PC与3PC的区别(转)</a></li><li><a href="http://www.hollischuang.com/archives/681#rd?sukey=3997c0719f1515205acb269da14295ad50b0186483fbd0a402a566f45b33525978b375ccc44dba3e85c4d645a320ba47">关于分布式事务、两阶段提交协议、三阶提交协议</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C/18%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E9%99%A4%E4%BA%86%20XA%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F.md">分布式事务（上）：除了 XA，还有哪些原子提交算法吗？</a><br><a href="https://zhuanlan.zhihu.com/p/343226202">https://zhuanlan.zhihu.com/p/343226202</a></li></ol><p><a href="https://zhuanlan.zhihu.com/p/343224188">https://zhuanlan.zhihu.com/p/343224188</a></p><ol><li><a href="https://www.cnblogs.com/qdhxhz/p/11167025.html">分布式事务(1)—2PC和3PC原理</a></li><li><a href="https://github.com/doocs/advanced-java/blob/main/docs/distributed-system/distributed-transaction.md">分布式事务</a></li><li><a href="https://www.modb.pro/db/69275">分布式事务（二）、刚性事务之 2PC、3PC</a> </li><li><a href="https://www.modb.pro/db/69276">分布式事务（三）、柔性事务之 TCC、Saga、本地消息表、事务消息、最大努力通知</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/88290514">正确理解二阶段提交（Two-Phase Commit）</a></li><li><a href="https://database.51cto.com/art/202101/640577.htm">聊聊分布式数据库对2PC的优化</a></li><li><a href="https://juejin.cn/post/6844903951477768205">TCC与两阶段分布式事务处理的区别</a></li><li><a href="https://baijiahao.baidu.com/s?id=1668643758581970944&amp;wfr=spider&amp;for=pc">分布式事务下的刚性事务和柔性事务</a></li><li><a href="https://zhenghe.gitbook.io/open-courses/mit-6.824/2pc-and-3pc">2PC &amp; 3PC</a></li><li><a href="https://zhuanlan.zhihu.com/p/35298019">漫话分布式系统共识协议: 2PC/3PC篇</a></li></ol><p><a href="https://www.youtube.com/watch?v=aDp99WDIM_4">https://www.youtube.com/watch?v=aDp99WDIM_4</a></p><p><a href="https://www.youtube.com/watch?v=S4FnmSeRpAY">https://www.youtube.com/watch?v=S4FnmSeRpAY</a></p><p><a href="https://www.youtube.com/watch?v=aDp99WDIM_4">https://www.youtube.com/watch?v=aDp99WDIM_4</a></p><p><a href="https://www.youtube.com/watch?v=VtUpBtAOizc">https://www.youtube.com/watch?v=VtUpBtAOizc</a></p><p><a href="http://oceanbase.org.cn/?p=195">http://oceanbase.org.cn/?p=195</a></p><p><a href="https://coolshell.cn/articles/10910.html">https://coolshell.cn/articles/10910.html</a></p><p><a href="https://maimai.cn/article/detail?fid=1122653559&amp;efid=jewbG8cL4Wikr2CJ3r_fAw">https://maimai.cn/article/detail?fid=1122653559&amp;efid=jewbG8cL4Wikr2CJ3r_fAw</a></p><p><a href="https://www.the-paper-trail.org/post/2008-11-29-consensus-protocols-three-phase-commit/">https://www.the-paper-trail.org/post/2008-11-29-consensus-protocols-three-phase-commit/</a></p><p><a href="https://www.the-paper-trail.org/post/2008-11-27-consensus-protocols-two-phase-commit/">https://www.the-paper-trail.org/post/2008-11-27-consensus-protocols-two-phase-commit/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hyperloglog</title>
      <link href="/hyperloglog/"/>
      <url>/hyperloglog/</url>
      
        <content type="html"><![CDATA[<h2 id="HyperLogLog结构使用场景"><a href="#HyperLogLog结构使用场景" class="headerlink" title="HyperLogLog结构使用场景"></a>HyperLogLog结构使用场景</h2><h2 id="伯努利试验"><a href="#伯努利试验" class="headerlink" title="伯努利试验"></a>伯努利试验</h2><h2 id="LogLog算法"><a href="#LogLog算法" class="headerlink" title="LogLog算法"></a>LogLog算法</h2><h2 id="HyperLoglog算法"><a href="#HyperLoglog算法" class="headerlink" title="HyperLoglog算法"></a>HyperLoglog算法</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/55defda6dcd2">https://www.jianshu.com/p/55defda6dcd2</a></p><p><a href="https://juejin.cn/book/6844733724618129422/section/6844733724706209805">https://juejin.cn/book/6844733724618129422/section/6844733724706209805</a></p><p><a href="https://juejin.cn/post/6844904194038562830">https://juejin.cn/post/6844904194038562830</a></p><p><a href="https://zhuanlan.zhihu.com/p/265309426">https://zhuanlan.zhihu.com/p/265309426</a></p><ol><li><a href="https://www.cnblogs.com/linguanh/p/10460421.html">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</a></li></ol><p><a href="http://content.research.neustar.biz/blog/hll.html">http://content.research.neustar.biz/blog/hll.html</a></p><p><a href="http://algo.inria.fr/flajolet/Publications/DuFl03-LNCS.pdf">http://algo.inria.fr/flajolet/Publications/DuFl03-LNCS.pdf</a></p><p><a href="https://www.yuque.com/abser/aboutme/nfx0a4">https://www.yuque.com/abser/aboutme/nfx0a4</a></p><p><a href="https://zhuanlan.zhihu.com/p/77289303">https://zhuanlan.zhihu.com/p/77289303</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang 并发</title>
      <link href="/golang-concurrency/"/>
      <url>/golang-concurrency/</url>
      
        <content type="html"><![CDATA[<h2 id="互斥锁Mutex"><a href="#互斥锁Mutex" class="headerlink" title="互斥锁Mutex"></a>互斥锁Mutex</h2><h3 id="示例-用mutex解决并发计数问题"><a href="#示例-用mutex解决并发计数问题" class="headerlink" title="示例: 用mutex解决并发计数问题"></a>示例: 用mutex解决并发计数问题</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> {</span><br><span class="line">sync.Mutex</span><br><span class="line">Count <span class="type">int64</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Incr() {</span><br><span class="line">c.Lock()</span><br><span class="line">c.Count++</span><br><span class="line">c.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Incr10k = <span class="function"><span class="keyword">func</span><span class="params">(counter *Counter, wg *sync.WaitGroup)</span></span> {</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ {</span><br><span class="line">counter.Incr()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> counter Counter</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Incr10k(&amp;counter, &amp;wg)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(counter.Count)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Mutex实现"><a href="#Mutex实现" class="headerlink" title="Mutex实现"></a>Mutex实现</h3><h4 id="go最早期的Mutex实现-最简单的实现"><a href="#go最早期的Mutex实现-最简单的实现" class="headerlink" title="go最早期的Mutex实现: 最简单的实现"></a>go最早期的Mutex实现: 最简单的实现</h4><p>key: 0表示锁未被持有。1表示锁被持有, 没有等待者。值为n表示锁被持有, 还有n-1个等待着。<br>sema: 等待着队列使用的信号量。当锁被占用的时候, 抢锁失败的线程会调用semacquire(), 使用信号量将自己休眠。等锁释放的时候, 信号量将会唤醒队列的头部等待着。</p><ol><li>公平: 排队等待</li><li>不可重入</li><li>其他协程可以释放锁</li></ol><h4 id="go-0-x版本-新增乐观抢锁"><a href="#go-0-x版本-新增乐观抢锁" class="headerlink" title="go 0.x版本: 新增乐观抢锁"></a>go 0.x版本: 新增乐观抢锁</h4><p>非公平: 新协程可能会抢, 而不是每次都在FIFO的队列头部获取</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema <span class="type">uint32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>state这一个字段包含多个意义:</p><ul><li>最高30位表示阻塞等待的waiter数量</li><li>接下来的1位表示是否有唤醒的goroutine. (这个标识有什么作用? 因为被唤醒的goroutine没抢到锁后, 不需要使waiter++, 所以需要区分是否是被唤醒的。)</li><li>最低1位表示这个锁是否被持有</li></ul><p>获取锁的过程:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// Fast path: 幸运case，能够直接获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        old := m.state</span><br><span class="line">        <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态加锁</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift <span class="comment">//等待者数量加一</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> awoke {</span><br><span class="line">            <span class="comment">// goroutine是被唤醒的，</span></span><br><span class="line">            <span class="comment">// 新状态清除唤醒标志</span></span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {<span class="comment">//设置新状态</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> { <span class="comment">// 锁原状态未加锁</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            }</span><br><span class="line">            runtime.Semacquire(&amp;m.sema) <span class="comment">// 请求信号量</span></span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>释放锁的过程:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() {</span><br><span class="line">    <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) <span class="comment">//去掉锁标志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> { <span class="comment">//本来就没有加锁</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    old := <span class="built_in">new</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> { <span class="comment">// 没有等待者，或者有唤醒的waiter，或者锁原来已加锁</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken <span class="comment">// 新状态，准备唤醒goroutine，并设置唤醒标志</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">            runtime.Semrelease(&amp;m.sema)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line">        old = m.state</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="go-1-5版本-新增自旋抢锁"><a href="#go-1-5版本-新增自旋抢锁" class="headerlink" title="go 1.5版本: 新增自旋抢锁"></a>go 1.5版本: 新增自旋抢锁</h4><p>非公平: 新协程可能会抢, 而不是每次都在FIFO的队列头部获取。而且相比于之前的版本, 对比新来请求锁的goroutine和被唤醒的goroutine, 都会自旋地多尝试几次</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// Fast path: 幸运之路，正好获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    iter := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> { <span class="comment">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁</span></span><br><span class="line">        old := m.state <span class="comment">// 先保存当前锁的状态</span></span><br><span class="line">        <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态设置加锁标志</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> { <span class="comment">// 锁还没被释放</span></span><br><span class="line">            <span class="keyword">if</span> runtime_canSpin(iter) { <span class="comment">// 还可以自旋</span></span><br><span class="line">                <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {</span><br><span class="line">                    <span class="comment">// 将锁的唤醒标记置为1，表示已经有醒着的线程正在获取锁，Unlock的时候便无需唤醒新的线程                    </span></span><br><span class="line">                    awoke = <span class="literal">true</span></span><br><span class="line">                }</span><br><span class="line">                runtime_doSpin()</span><br><span class="line">                iter++</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// 自旋，再次尝试请求锁</span></span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> awoke { <span class="comment">// 唤醒状态</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> {</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> { <span class="comment">// 旧状态锁已释放，新状态成功持有了锁，直接返回</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            }</span><br><span class="line">            runtime_Semacquire(&amp;m.sema) <span class="comment">// 阻塞等待</span></span><br><span class="line">            awoke = <span class="literal">true</span> <span class="comment">// 被唤醒</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="go-1-9版本-新增饥饿模式"><a href="#go-1-9版本-新增饥饿模式" class="headerlink" title="go 1.9版本: 新增饥饿模式"></a>go 1.9版本: 新增饥饿模式</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema <span class="type">uint32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>state这一个字段包含多个意义:</p><ul><li>最高29位表示阻塞等待的waiter数量</li><li>接下来的1位表示饥饿标记(此版本新增)</li><li>再接下来的1位表示是否有唤醒的goroutine</li><li>最低1位表示这个锁是否被持有</li></ul><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// Fast path: 幸运之路，一下就获取到了锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争</span></span><br><span class="line">    m.lockSlow()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() {</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">    starving := <span class="literal">false</span> <span class="comment">// 此goroutine的饥饿标记</span></span><br><span class="line">    awoke := <span class="literal">false</span> <span class="comment">// 唤醒标记</span></span><br><span class="line">    iter := <span class="number">0</span> <span class="comment">// 自旋次数</span></span><br><span class="line">    old := m.state <span class="comment">// 当前的锁的状态</span></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="comment">// 锁是非饥饿状态，锁还没被释放，尝试自旋</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {</span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state <span class="comment">// 再次获取锁的状态，之后会检查是否锁被释放了</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked <span class="comment">// 非饥饿状态，加锁</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">// waiter数量加1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> {</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving <span class="comment">// 设置饥饿状态</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不管是获得了锁还是进入休眠，我们都需要清除 mutexWoken 标记</span></span><br><span class="line">        <span class="keyword">if</span> awoke {</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> {</span><br><span class="line">                throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 成功设置新状态</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">            <span class="comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> {</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 处理饥饿状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果以前就在队列里面，加入到队列头</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> {</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 唤醒之后检查锁是否应该处于饥饿状态</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> {</span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> {</span><br><span class="line">                    throw(<span class="string">"sync: inconsistent mutex state"</span>)</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 加锁并且将waiter数减1（加mutexLocked是加锁，减1&lt;&lt;mutexWaiterShift是减少waiter）</span></span><br><span class="line">                delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> { <span class="comment">// 当前goroutine等待还没超过1毫秒, 且没有其他的waiter </span></span><br><span class="line">                    delta -= mutexStarving <span class="comment">// 最后一个waiter或者已经不饥饿了，清除饥饿标记</span></span><br><span class="line">                    <span class="comment">// （同理，减mutexStarving是清楚饥饿标记）</span></span><br><span class="line">                }</span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            }</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            old = m.state</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() {</span><br><span class="line">    <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> {</span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> {</span><br><span class="line">        throw(<span class="string">"sync: unlock of unlocked mutex"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> {</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> {</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) {</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            }</span><br><span class="line">            old = m.state</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="读写锁RWMutex"><a href="#读写锁RWMutex" class="headerlink" title="读写锁RWMutex"></a>读写锁RWMutex</h2><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> {</span><br><span class="line">  w           Mutex   <span class="comment">// 互斥锁解决多个writer的竞争。为 writer 的竞争锁而设计。</span></span><br><span class="line">  writerSem   <span class="type">uint32</span>  <span class="comment">// writer信号量</span></span><br><span class="line">  readerSem   <span class="type">uint32</span>  <span class="comment">// reader信号量</span></span><br><span class="line">  readerCount <span class="type">int32</span>   <span class="comment">// reader的数量。记录当前 reader 的数量（以及是否有 writer 竞争锁）, rw.readerCount是负值的时候，意味着此时有writer等待请求锁</span></span><br><span class="line">  readerWait  <span class="type">int32</span>   <span class="comment">// writer等待完成的reader的数量。记录 writer 请求锁时需要等待 read 完成的 reader 的数量；</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span> <span class="comment">// 最大的 reader 数量</span></span><br></pre></td></tr></tbody></table></figure><p>读读相关操作</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() {</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() {</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> {</span><br><span class="line">        rw.rUnlockSlow(r) <span class="comment">// 有等待的writer</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) {</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// 最后一个reader了，writer终于有机会获得锁了</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>写锁相关操作</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() {</span><br><span class="line">    <span class="comment">// 首先解决其他writer竞争问题</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    <span class="comment">// 反转readerCount，告诉reader有writer竞争锁</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    <span class="comment">// 如果当前有reader持有锁，那么需要等待</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> {</span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() {</span><br><span class="line">    <span class="comment">// 告诉reader没有活跃的writer了</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒阻塞的reader们</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ {</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 释放内部的互斥锁</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>结构体定义:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span></span><br><span class="line">    noCopy noCopy</span><br><span class="line">    <span class="comment">// 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数</span></span><br><span class="line">    <span class="comment">// 另外32bit是用作信号量的</span></span><br><span class="line">    <span class="comment">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法</span></span><br><span class="line">    <span class="comment">// 总之，会找到对齐的那64bit作为state，其余的32bit做信号量</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> state() (statep *<span class="type">uint64</span>, semap *<span class="type">uint32</span>) {</span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> {</span><br><span class="line">        <span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    }</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><p>Add操作:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) {</span><br><span class="line">  <span class="comment">// statep表示wait数和计数值</span></span><br><span class="line">  <span class="comment">// 低32位表示wait数，高32位表示计数值</span></span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="comment">// uint64(delta)&lt;&lt;32 将delta左移32位</span></span><br><span class="line">    <span class="comment">// 因为高32位表示计数值，所以将delta左移32，增加到技术上</span></span><br><span class="line">   state := atomic.AddUint64(statep, <span class="type">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 当前计数值</span></span><br><span class="line">   v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 阻塞在检查点的wait数</span></span><br><span class="line">   w := <span class="type">uint32</span>(state)</span><br><span class="line">   <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> {</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量</span></span><br><span class="line">    <span class="comment">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter</span></span><br><span class="line">   *statep = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- {</span><br><span class="line">      runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Done操作:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done方法实际就是计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() { </span><br><span class="line">  wg.Add(<span class="number">-1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Wait操作:</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() {</span><br><span class="line">   <span class="comment">// statep表示wait数和计数值</span></span><br><span class="line">   <span class="comment">// 低32位表示wait数，高32位表示计数值</span></span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="keyword">for</span> {</span><br><span class="line">      state := atomic.LoadUint64(statep)</span><br><span class="line">      <span class="comment">// 将state右移32位，表示当前计数值</span></span><br><span class="line">      v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">      <span class="comment">// w表示waiter等待值</span></span><br><span class="line">      w := <span class="type">uint32</span>(state)</span><br><span class="line">      <span class="keyword">if</span> v == <span class="number">0</span> {</span><br><span class="line">         <span class="comment">// 如果当前计数值为零，表示当前子goroutine已全部执行完毕，则直接返回</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 否则使用原子操作将state值加一。</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) {</span><br><span class="line">         <span class="comment">// 阻塞休眠等待</span></span><br><span class="line">         runtime_Semacquire(semap)</span><br><span class="line">         <span class="comment">// 被唤醒，不再阻塞，返回</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《极客时间-Go并发编程实战课》</li><li><a href="https://colobu.com/2018/12/18/dive-into-sync-mutex/">sync.mutex 源代码分析</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#mutex">draveness-同步原语与锁</a></li><li><a href="https://www.cnblogs.com/luozhiyun/p/14157542.html">多图详解Go的互斥锁Mutex</a></li><li><a href="https://www.wangt.cc/2021/01/go%e4%b8%ad%e7%94%b1waitgroup%e5%bc%95%e5%8f%91%e5%af%b9%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90%e6%80%9d%e8%80%83/">Go中由WaitGroup引发对内存对齐思考</a></li></ol><p><a href="https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/">https://golang.design/under-the-hood/zh-cn/part1basic/ch05sync/</a></p><p><a href="https://draveness.me/whys-the-design-communication-shared-memory/">https://draveness.me/whys-the-design-communication-shared-memory/</a></p><p><a href="https://blog.csdn.net/fwhezfwhez/article/details/82900498">https://blog.csdn.net/fwhezfwhez/article/details/82900498</a></p><p><a href="https://studygolang.com/articles/29935?fr=sidebar">https://studygolang.com/articles/29935?fr=sidebar</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 调度器</title>
      <link href="/golang-scheduler/"/>
      <url>/golang-scheduler/</url>
      
        <content type="html"><![CDATA[<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><h3 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="基于协作的抢占式调度"></a>基于协作的抢占式调度</h3><blockquote><p>Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="调度器启动"><a href="#调度器启动" class="headerlink" title="调度器启动"></a>调度器启动</h2><h2 id="创建Goroutine"><a href="#创建Goroutine" class="headerlink" title="创建Goroutine"></a>创建Goroutine</h2><h2 id="调度循环"><a href="#调度循环" class="headerlink" title="调度循环"></a>调度循环</h2><h2 id="为什么协程切换的代价比线程切换低"><a href="#为什么协程切换的代价比线程切换低" class="headerlink" title="为什么协程切换的代价比线程切换低?"></a>为什么协程切换的代价比线程切换低?</h2><blockquote><p>协程切换非常简单，就是把当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上就 ok 了。而且完全在用户态进行，一般来说一次协程上下文切换最多就是几十ns 这个量级。</p><p>线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换，也就是特权模式切换，然后需要操作系统调度模块完成线程调度（taskstruct），而且除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等，说白了就是上下文比协程多一些，其实简单比较下 task_strcut 和 任何一个协程库的 coroutine 的 struct 结构体大小就能明显区分出来。<br>恶化cache命中率，提升sys cpu的执行占比，导致侵占用户态的cpu利用率。</p></blockquote><h2 id="进程的开销比线程大在了哪里"><a href="#进程的开销比线程大在了哪里" class="headerlink" title="进程的开销比线程大在了哪里?"></a>进程的开销比线程大在了哪里?</h2><p>创建成本:</p><blockquote><p>Linux 中创建一个进程自然会创建一个线程，也就是主线程。创建进程需要为进程划分出一块完整的内存空间，有大量的初始化操作，比如要把内存分段（堆栈、正文区等）。创建线程则简单得多，只需要确定 PC 指针和寄存器的值，并且给线程分配一个栈用于执行程序，同一个进程的多个线程间可以复用堆栈。因此，创建进程比创建线程慢，而且进程的内存开销更大。</p></blockquote><p>切换成本:</p><blockquote><p>进程切换涉及虚拟地址空间的切换而线程不会。</p><p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.kancloud.cn/aceld/golang/1958305">刘丹冰Aceld-Golang的协程调度器原理及GMP设计思想？</a></li><li><a href="https://tonybai.com/2020/03/21/illustrated-tales-of-go-runtime-scheduler/">Tony Bai-图解Go运行时调度器</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/105447358?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162753851016780255226838%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162753851016780255226838&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-105447358.pc_v2_rank_blog_default&amp;utm_term=Goroutine&amp;spm=1018.2226.3001.4450">Golang 协程Goroutine到底是怎么回事？（一）</a></li><li><a href="https://blog.csdn.net/qiya2007/article/details/105447383?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162753851016780255226838%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162753851016780255226838&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-105447383.pc_v2_rank_blog_default&amp;utm_term=Goroutine&amp;spm=1018.2226.3001.4450">Golang 协程Goroutine到底是怎么回事？（二）</a></li><li><a href="https://talkgo.org/t/topic/31">go夜读-golang 中 goroutine 的调度</a></li><li><a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/">Go 语言原本-并发调度</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">draveness-调度器</a></li><li><a href="https://learnku.com/articles/41728">[典藏版] Golang 调度器 GMP 原理与调度全分析</a></li><li>《Golang 源码剖析 1.5.1 雨痕》</li><li><a href="https://www.zhihu.com/question/308641794">为什么协程切换的代价比线程切换低?</a></li><li><a href="https://segmentfault.com/a/1190000021492983">Netty中的Reactor模型详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/79772089">进程/线程上下文切换会用掉你多少CPU？</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/17%20%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%A4%A7%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%9F.md">《重学操作系统》进程和线程：进程的开销比线程大在了哪里？</a></li><li><a href="https://www.jianshu.com/p/16b83e7facb9">为什么运行时程序要分成内核态和用户态</a></li><li><a href="https://blog.csdn.net/htxhtx123/article/details/104595175">什么是ring0-ring3</a></li><li><a href="https://zhuanlan.zhihu.com/p/69554144">怎样去理解Linux用户态和内核态？</a></li><li><a href="http://www.linfo.org/context_switch.html">Context Switch Definition</a></li><li><a href="https://blog.csdn.net/gatieme/article/details/50779184">Linux系统调用详解（实现机制分析）–linux内核剖析（六）</a></li><li><a href="https://www.zhihu.com/question/32264167">关于go语言协程调度的一个问题(具体请看问题描述)?</a></li><li><a href="https://juejin.cn/post/6844903930497859591">深度解密Go语言之 scheduler</a></li><li><a href="https://cloud.tencent.com/developer/article/1367908">Linux核心调度器之周期性调度器scheduler_tick–Linux进程的管理与调度(十八）</a></li><li><a href="https://segmentfault.com/a/1190000016038785">Golang - 调度剖析【第一部分】</a></li><li><a href="https://segmentfault.com/a/1190000016611742">Golang - 调度剖析【第二部分】</a></li><li><a href="https://segmentfault.com/a/1190000017333717">Golang - 调度剖析【第三部分】</a></li><li><a href="https://www.cnblogs.com/charlieroro/p/12133100.html">linux线程调度策略</a></li><li><a href="https://mp.weixin.qq.com/s/7bjefYPhI03t9HRny42zkA">为什么Go服务容器化之后延迟变高</a></li><li><a href="https://blog.csdn.net/qq_34417408/article/details/110393655">线程比进程更快，吞吐更强，本文从切换方面介绍</a></li></ol><p><a href="http://www.linfo.org/context_switch.html">http://www.linfo.org/context_switch.html</a></p><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=18c9f8f5d9fa76f11dbee46c48954835&amp;type=note">https://note.youdao.com/ynoteshare1/index.html?id=18c9f8f5d9fa76f11dbee46c48954835&amp;type=note</a></p><p><a href="https://xargin.com/go-scheduler/">https://xargin.com/go-scheduler/</a></p><p><a href="https://www.bilibili.com/video/BV1RK4y187k4/?spm_id_from=333.788.recommend_more_video.4">https://www.bilibili.com/video/BV1RK4y187k4/?spm_id_from=333.788.recommend_more_video.4</a></p><p><a href="https://www.bilibili.com/video/BV1pb411v7nu?from=search&amp;seid=2638724496956885629">https://www.bilibili.com/video/BV1pb411v7nu?from=search&amp;seid=2638724496956885629</a></p><p><a href="https://www.bilibili.com/video/BV19r4y1w7Nx?p=17">https://www.bilibili.com/video/BV19r4y1w7Nx?p=17</a></p><p><a href="https://www.bilibili.com/video/BV1MZ4y1V7SP/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1MZ4y1V7SP/?spm_id_from=333.788.recommend_more_video.-1</a></p><p><a href="https://www.bilibili.com/video/BV1Ky4y1r78H/?spm_id_from=333.788.recommend_more_video.1">https://www.bilibili.com/video/BV1Ky4y1r78H/?spm_id_from=333.788.recommend_more_video.1</a></p><p><a href="https://www.bilibili.com/video/BV1zT4y1F7XF?from=search&amp;seid=6090279844654181905">https://www.bilibili.com/video/BV1zT4y1F7XF?from=search&amp;seid=6090279844654181905</a></p><p><a href="https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86--golang-runtime.md">https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86--golang-runtime.md</a></p><p><a href="https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8D%8F%E7%A8%8B%E6%A0%88.md">https://github.com/Zeb-D/my-review/blob/master/go/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E5%8D%8F%E7%A8%8B%E6%A0%88.md</a></p><p><a href="https://www.luozhiyun.com/archives/448">https://www.luozhiyun.com/archives/448</a></p><p><a href="https://www.luozhiyun.com/archives/485">https://www.luozhiyun.com/archives/485</a></p><p><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit">https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit</a></p><p><a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/</a></p><p><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.0.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.0.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/216118842">https://zhuanlan.zhihu.com/p/216118842</a></p><p><a href="https://segmentfault.com/a/1190000039052089">https://segmentfault.com/a/1190000039052089</a></p><p><a href="https://zhuanlan.zhihu.com/p/244054940">https://zhuanlan.zhihu.com/p/244054940</a></p><p><a href="https://www.infoq.cn/article/r6wzs7bvq2er9kuelbqb">https://www.infoq.cn/article/r6wzs7bvq2er9kuelbqb</a></p><p><a href="https://www.infoq.cn/article/NuvRPz1cPk9Cw0HP3bkY?utm_source=related_read&amp;utm_medium=article">https://www.infoq.cn/article/NuvRPz1cPk9Cw0HP3bkY?utm_source=related_read&amp;utm_medium=article</a></p><ol><li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/05.5.html">深入解析Go-抢占式调度</a></li></ol><p><a href="https://zhuanlan.zhihu.com/p/42057783">https://zhuanlan.zhihu.com/p/42057783</a></p><p><a href="http://xiaorui.cc/archives/6535">http://xiaorui.cc/archives/6535</a></p><p><a href="https://juejin.cn/post/6844903846825705485">https://juejin.cn/post/6844903846825705485</a></p><p><a href="https://zboya.github.io/post/go_scheduler/">https://zboya.github.io/post/go_scheduler/</a></p><p><a href="https://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">https://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a></p><p><a href="https://yizhi.ren/2019/06/03/goscheduler/">https://yizhi.ren/2019/06/03/goscheduler/</a></p><p><a href="https://jingwei.link/2019/05/26/golang-routine-scheduler.html">https://jingwei.link/2019/05/26/golang-routine-scheduler.html</a></p><p><a href="https://blog.haohtml.com/archives/18352">https://blog.haohtml.com/archives/18352</a></p><p><a href="http://austsxk.com/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/">http://austsxk.com/2020/08/18/Golang%E8%B0%83%E5%BA%A6%E5%99%A8GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%85%A8%E5%88%86%E6%9E%90/</a></p><p><a href="https://qcrao.com/2019/09/06/dive-into-go-scheduler-source-code/">https://qcrao.com/2019/09/06/dive-into-go-scheduler-source-code/</a></p><p><a href="https://qcrao.com/2020/04/03/talk-about-g0/">https://qcrao.com/2020/04/03/talk-about-g0/</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-a-goroutine-start-and-exit-2b3303890452">https://medium.com/a-journey-with-go/go-how-does-a-goroutine-start-and-exit-2b3303890452</a></p><p><a href="https://medium.com/a-journey-with-go/go-how-does-go-recycle-goroutines-f047a79ab352">https://medium.com/a-journey-with-go/go-how-does-go-recycle-goroutines-f047a79ab352</a></p><p><a href="https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7">https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7</a></p><p><a href="https://medium.com/a-journey-with-go/go-work-stealing-in-go-scheduler-d439231be64d">https://medium.com/a-journey-with-go/go-work-stealing-in-go-scheduler-d439231be64d</a></p><p><a href="https://www.tyx.pub/archives/86">https://www.tyx.pub/archives/86</a></p><p><a href="https://www.pengrl.com/p/39569/">https://www.pengrl.com/p/39569/</a></p><p><a href="https://feiybox.com/2020/03/14/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/">https://feiybox.com/2020/03/14/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</a></p><p><a href="http://odin.show/2020/04/25/golang-GPM">http://odin.show/2020/04/25/golang-GPM</a></p><p><a href="https://www.huweihuang.com/golang-notes/principle/go-scheduler.html">https://www.huweihuang.com/golang-notes/principle/go-scheduler.html</a></p><p><a href="http://qinqiyao.com/2019/12/25/Golang%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">http://qinqiyao.com/2019/12/25/Golang%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</a></p><p><a href="https://blog.crazytaxii.com/posts/scheduling_in_go_part2/">https://blog.crazytaxii.com/posts/scheduling_in_go_part2/</a></p><p><a href="https://www.liuvv.com/p/c8d0853c.html">https://www.liuvv.com/p/c8d0853c.html</a></p><p><a href="https://www.iminho.me/wiki/blog-21.html">https://www.iminho.me/wiki/blog-21.html</a></p><p><a href="https://mdnice.com/writing/98e27d97c9fd43b3aed92f36d7566794">https://mdnice.com/writing/98e27d97c9fd43b3aed92f36d7566794</a></p><p><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#">https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http</title>
      <link href="/http/"/>
      <url>/http/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI网络分层模型"><a href="#OSI网络分层模型" class="headerlink" title="OSI网络分层模型"></a>OSI网络分层模型</h2><p>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；<br>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；<br>第三层：网络层，相当于 TCP/IP 里的网际层；<br>第四层：传输层，相当于 TCP/IP 里的传输层；<br>第五层：会话层，维护网络中的连接状态，即保持会话和同步；<br>第六层：表示层，把数据转换为合适、可理解的语法和语义；<br>第七层：应用层，面向具体的应用传输数据。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；<br>2××：成功，报文已经收到并被正确处理；<br>3××：重定向，资源位置发生变动，需要客户端重新发送请求；<br>4××：客户端错误，请求报文有误，服务器无法处理；<br>5××：服务器错误，服务器在处理请求时内部发生了错误。</p><h2 id="http0-9"><a href="#http0-9" class="headerlink" title="http0.9"></a>http0.9</h2><blockquote><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p></blockquote><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><blockquote><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。</p></blockquote><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></tbody></table></figure><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><blockquote><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>服务器发送完毕，就关闭TCP连接。</p></blockquote><h2 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h2><blockquote><p>引入了POST命令和HEAD命令</p></blockquote><h3 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h3><p>每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></tbody></table></figure><h3 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h3><ol><li>响应第一行是”协议版本 + 状态码（status code） + 状态描述”。</li><li>接下来是”头信息 + 以一个空行结尾表示”头信息部分结束”（\r\n）</li><li>最后是”数据”部分</li></ol><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p></blockquote><blockquote><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。</p></blockquote><blockquote><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p></blockquote><h2 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h2><h3 id="新增命令"><a href="#新增命令" class="headerlink" title="新增命令"></a>新增命令</h3><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><blockquote><p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p></blockquote><blockquote><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p></blockquote><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br></pre></td></tr></tbody></table></figure><blockquote><p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p></blockquote><h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><blockquote><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p></blockquote><blockquote><p>管道机制: 在同一个tcp连接中, 在等待上一个请求响应的同时，发送下一个请求。但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p></blockquote><h3 id="Content-Length字段"><a href="#Content-Length字段" class="headerlink" title="Content-Length字段"></a>Content-Length字段</h3><blockquote><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p></blockquote><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>3495</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p></blockquote><blockquote><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p></blockquote><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br></pre></td></tr></tbody></table></figure><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p></blockquote><blockquote><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p></blockquote><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><blockquote><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><ol><li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li><li>篡改风险（tampering）：第三方可以修改通信内容。</li><li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li></ol></blockquote><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><blockquote><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p></blockquote><h4 id="如何保证公钥不被篡改？"><a href="#如何保证公钥不被篡改？" class="headerlink" title="如何保证公钥不被篡改？"></a>如何保证公钥不被篡改？</h4><blockquote><p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></blockquote><h4 id="公钥加密计算量太大，如何减少耗用的时间？"><a href="#公钥加密计算量太大，如何减少耗用的时间？" class="headerlink" title="公钥加密计算量太大，如何减少耗用的时间？"></a>公钥加密计算量太大，如何减少耗用的时间？</h4><p>解决方法: 用非对称加密来传输对称加密的秘钥</p><h4 id="SSL-TLS基本过程"><a href="#SSL-TLS基本过程" class="headerlink" title="SSL/TLS基本过程"></a>SSL/TLS基本过程</h4><ol><li>客户端向服务器端索要并验证公钥。</li><li>双方协商生成”对话密钥”。</li><li>双方采用”对话密钥”进行加密通信。</li></ol><h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><h3 id="二进制化协议"><a href="#二进制化协议" class="headerlink" title="二进制化协议"></a>二进制化协议</h3><blockquote><p>HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p></blockquote><blockquote><p>二进制协议的一个好处是，可以定义额外的帧。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p></blockquote><h3 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h3><blockquote><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p></blockquote><blockquote><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p></blockquote><h3 id="取消数据流"><a href="#取消数据流" class="headerlink" title="取消数据流"></a>取消数据流</h3><blockquote><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p></blockquote><h3 id="定义优先级"><a href="#定义优先级" class="headerlink" title="定义优先级"></a>定义优先级</h3><blockquote><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p></blockquote><h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><blockquote><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p></blockquote><blockquote><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p></blockquote><h4 id="HPACK"><a href="#HPACK" class="headerlink" title="HPACK"></a>HPACK</h4><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><blockquote><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p></blockquote><blockquote><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p></blockquote><h2 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《极客时间-透视HTTP协议》</li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%85%A8%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">全解网络协议</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a></li><li><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li><li><a href="https://coolshell.cn/articles/19840.html">HTTP的前世今生</a></li><li><a href="https://draveness.me/whys-the-design-https-latency/">为什么 HTTPS 需要 7 次握手以及 9 倍时延</a></li><li><a href="https://my.oschina.net/u/4482993/blog/4631144">小林coding-20 张图解，为什么 HTTP3.0 使用 UDP 协议？</a></li></ol><p><a href="https://imququ.com/post/series.html">https://imququ.com/post/series.html</a></p><p><a href="https://coolshell.cn/articles/19840.html">https://coolshell.cn/articles/19840.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/68024390">https://zhuanlan.zhihu.com/p/68024390</a></p><p><a href="https://zhuanlan.zhihu.com/p/89471776">https://zhuanlan.zhihu.com/p/89471776</a></p><p><a href="https://imququ.com/post/series.html">https://imququ.com/post/series.html</a></p><p><a href="https://httpwg.org/specs/rfc7541.html">https://httpwg.org/specs/rfc7541.html</a></p><p><a href="https://httpwg.org/specs/rfc7540.html">https://httpwg.org/specs/rfc7540.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/143464334">https://zhuanlan.zhihu.com/p/143464334</a></p><p><a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html">https://quicwg.org/base-drafts/draft-ietf-quic-http.html</a></p><p><a href="https://www.chromium.org/quic">https://www.chromium.org/quic</a></p><p><a href="https://zhuanlan.zhihu.com/p/40595473">https://zhuanlan.zhihu.com/p/40595473</a></p><p><a href="https://tools.ietf.org/html/rfc5246">https://tools.ietf.org/html/rfc5246</a></p>]]></content>
      
      
      <categories>
          
          <category> internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
            <tag> http </tag>
            
            <tag> ssl/tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBFT</title>
      <link href="/pbft/"/>
      <url>/pbft/</url>
      
        <content type="html"><![CDATA[<h2 id="两将军问题"><a href="#两将军问题" class="headerlink" title="两将军问题"></a>两将军问题</h2><blockquote><p>根据FLP不可能原理，两将军问题无通用解</p></blockquote><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><blockquote><p>拜占庭系统普遍采用的假设条件包括：</p><ol><li>拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；</li><li>节点之间的错误是不相关的；</li><li>节点之间通过异步网络连接，网络中的消息可能丢失、乱序并延时到达，但大部分协议假设消息在有限的时间里能传达到目的地；</li><li>服务器之间传递的信息，第三方可以嗅探到，但是不能篡改、伪造信息的内容和验证信息的完整性。</li></ol></blockquote><h2 id="BFT-拜占庭容错-简介"><a href="#BFT-拜占庭容错-简介" class="headerlink" title="BFT(拜占庭容错)简介"></a>BFT(拜占庭容错)简介</h2><h2 id="PBFT简介"><a href="#PBFT简介" class="headerlink" title="PBFT简介"></a>PBFT简介</h2><blockquote><p>PBFT算法可以在失效节点不超过总数1/3的情况下同时保证Safety和Liveness</p></blockquote><blockquote><p>PBFT 算法采用密码学相关技术(RSA 签名算法、消息验证编码和摘要)确保消息传递过程无法被篡改和破坏</p></blockquote><blockquote><p>PBFT是一种状态机副本复制算法</p></blockquote><h2 id="SBFT简介"><a href="#SBFT简介" class="headerlink" title="SBFT简介"></a>SBFT简介</h2><p>Hyperledger fabric v1.0对PBFT的改进</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote><p>PBFT算法具有高交易通量和吞吐量，高可用性，易于理解。</p></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote><ol><li>计算效率依赖于参与协议的节点数量，由于每个副本节点都需要和其它节点进行P2P的共识同步，因此随着节点的增多，性能会下降的很快，但在较少节点的情况下可以有不错的性能，并且分叉的几率很低，不适用于节点数量过大的区块链，扩展性差。</li><li>系统节点是固定的，无法应对公有链的开放环境，只适用于联盟链或私<br>有链环境。</li><li>PBFT算法要求总节点数n&gt;=3f+1(其中，f代表作恶节点数)。系统的失效节点数量不得超过全网节点的1/3，容错率相对较低。</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>PBFT算法由于每个副本节点都需要和其他节点进行P2P的共识同步，因此随着节点的增多，性能会下降的很快，但是在较少节点的情况下可以有不错的性能，并且分叉的几率很低。PBFT主要用于联盟链，但是如果能够结合类似DPOS这样的节点代表选举规则的话也可以应用于公联，并且可以在一个不可信的网络里解决拜占庭容错问题，TPS应该是远大于POW的。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/jfkidear/article/details/81275974">https://blog.csdn.net/jfkidear/article/details/81275974</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98</a></p><p><a href="https://zhuanlan.zhihu.com/p/43067427">https://zhuanlan.zhihu.com/p/43067427</a></p><p><a href="https://lrita.github.io/2018/10/28/time-sequence-in-blockchain-by-bft/">https://lrita.github.io/2018/10/28/time-sequence-in-blockchain-by-bft/</a></p><p><a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">http://pmg.csail.mit.edu/papers/osdi99.pdf</a></p><p><a href="https://www.jianshu.com/p/78e2b3d3af62">https://www.jianshu.com/p/78e2b3d3af62</a></p><p>《极客时间-分布式协议与算法实战》</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>InfluxDB</title>
      <link href="/influxdb/"/>
      <url>/influxdb/</url>
      
        <content type="html"><![CDATA[<h2 id="TSM-tree"><a href="#TSM-tree" class="headerlink" title="TSM tree"></a>TSM tree</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li>相比于底层的levelDB, 作为时序数据库需要更多的删除操作: “我们的用户需要一种自动管理数据保留的方法。这意味着我们需要大量的删除。”</li><li>在最开始的时候， influxdb 采用的方案每个shard都是一个独立的数据库实例，底层都是一套独立的LevelDB存储引擎。 这时带来的问题是，LevelDB底层采用level compaction策略，每个存储引擎都会打开比较多的文件，随着shard的增多，最终进程打开的文件句柄会很快触及到上限。</li><li>为了避免删除操作，我们将数据分割成我们称之为shard的数据. influxdb 采用的方案每个shard都是一个独立的数据库实例，底层都是一套独立的LevelDB存储引擎。 这时带来的问题是，LevelDB底层采用level compaction策略，每个存储引擎都会打开比较多的文件，随着shard的增多，最终进程打开的文件句柄会很快触及到上限。（在 InfluxDB 中按照数据的时间戳所在的范围,会去创建不同的 shard）</li><li>由于遇到大量的客户反馈文件句柄过多的问题，InfluxDB在新版本的存储引擎选型中选择了BoltDB替换LevelDB。BoltDB底层数据结构是mmap B+树。 但由于B+ 树会产生大量的随机写。 所以写入性能较差。</li><li>相比于BoltDB: “我们发现了写入吞吐量的一大问题。在数据库超过几GB之后，IOPS开始成为瓶颈”</li><li>我们的计划是在Bolt面前写一个WAL，这样我们可以减少随机插入到keyspace的数量。相反，我们会缓冲彼此相邻的多个写入，然后一次flush它们 但是，这仅仅是为了延缓了这个问题。高IOPS仍然成为一个问题，对于任何在适度工作负荷的场景下，它都会很快出现</li><li>之后Influxdb 最终决定仿照LSM 的思想自研TSM ，主要改进点是基于时序数据库的特性作出一些优化，包含Cache、WAL以及Data File等各个组件，也会有flush、compaction等这类数据操作。</li></ol><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><blockquote><p>TSM的设计目标一是解决LevelDB的文件句柄过多问题，二是解决BoltDB的写入性能问题</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://blog.fatedier.com/2016/07/05/research-of-time-series-database-influxdb/">时间序列数据库调研之InfluxDB</a></li><li><a href="http://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one/">InfluxDB详解之TSM存储引擎解析（一）</a></li><li><a href="http://blog.fatedier.com/2016/08/15/detailed-in-influxdb-tsm-storage-engine-two/">InfluxDB详解之TSM存储引擎解析（二）</a></li><li><a href="https://www.youtube.com/watch?v=rtEalnKT25I">InfluxDB Storage Engine Internals | Metamarkets</a></li><li><a href="https://www.bilibili.com/video/BV1ht411873N?from=search&amp;seid=10631955173242485046">OpenTSDB 时序数据引擎介绍 【 Go 夜读 】</a></li><li><a href="http://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one/">InfluxDB详解之TSM存储引擎解析（一）</a></li><li><a href="http://blog.fatedier.com/2016/08/15/detailed-in-influxdb-tsm-storage-engine-two/">InfluxDB详解之TSM存储引擎解析（二）</a></li><li><a href="https://lrita.github.io/2017/06/12/influxdb-tsdb/">influxdb 源码解析-tsdb</a></li><li><a href="https://jasper-zhang1.gitbooks.io/influxdb/content/">InfluxDB中文文档</a></li><li><a href="https://jasper-zhang1.gitbooks.io/influxdb/content/Concepts/storage_engine.html">InfluxDB的存储引擎和TSM</a></li><li><a href="https://liujiacai.net/blog/2021/01/21/thoughts-of-influxdb-iox/">https://liujiacai.net/blog/2021/01/21/thoughts-of-influxdb-iox/</a></li><li><a href="http://hbasefly.com/2018/01/13/timeseries-database-4/">http://hbasefly.com/2018/01/13/timeseries-database-4/</a></li><li><a href="https://blog.fatedier.com/2016/08/05/detailed-in-influxdb-tsm-storage-engine-one/">InfluxDB详解之TSM存储引擎解析（一）</a></li><li><a href="https://xiazemin.github.io/MyBlog/storage/2020/06/30/tsm.html">TSM-tree</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Percolator</title>
      <link href="/percolator/"/>
      <url>/percolator/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Percolator 是 Google 的上一代分布式事务解决方案，构建在 BigTable 之上，在 Google 内部用于网页索引更新的业务。原理比较简单，总体来说就是一个经过优化的 2PC 的实现，依赖一个单点的授时服务 TSO 来实现单调递增的事务编号生成，提供 SI 的隔离级别。</p></blockquote><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>Percolator的前提是本地事务的数据库支持多版本并发控制协议，也就是mvcc。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://database.51cto.com/art/202101/640577.htm">聊聊分布式数据库对2PC的优化</a></li><li><a href="https://github.com/ngaut/builddatabase/blob/master/percolator/README.md">Google Percolator 的事务模型</a></li><li><a href="https://blog.csdn.net/hnwyllmm/article/details/99988463">Percolator 2PC模型</a></li><li><a href="https://karellincoln.github.io/2018/04/05/percolator-translate/">percolator：在线增量处理系统 中文翻译</a></li><li><a href="https://blog.csdn.net/maray/article/details/6978958">Percolator中的两阶段提交实现分析</a></li><li><a href="https://www.daimajiaoliu.com/daima/471ac65cb10040c">Percolator 中的分布式事务</a></li><li>《拉钩教育-24讲吃透分布式数据库》</li></ol><p><a href="http://research.google.com/pubs/pub36726.html">http://research.google.com/pubs/pub36726.html</a></p><p><a href="https://www.cnblogs.com/foxmailed/p/3887430.html">https://www.cnblogs.com/foxmailed/p/3887430.html</a></p><p><a href="https://www.jianshu.com/p/05194f4b29dd">https://www.jianshu.com/p/05194f4b29dd</a></p><p><a href="https://blog.csdn.net/maray/article/details/6978958">https://blog.csdn.net/maray/article/details/6978958</a></p><p><a href="http://mysql.taobao.org/monthly/2018/11/02/">http://mysql.taobao.org/monthly/2018/11/02/</a></p><p><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Peng.pdf">https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Peng.pdf</a></p><p><a href="https://karellincoln.github.io/2018/04/05/percolator-translate/">https://karellincoln.github.io/2018/04/05/percolator-translate/</a></p><p><a href="https://blog.csdn.net/linuxheik/article/details/77800659">https://blog.csdn.net/linuxheik/article/details/77800659</a></p><p><a href="https://pingcap.com/blog-cn/tidb-transaction-model">https://pingcap.com/blog-cn/tidb-transaction-model</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/zookeeper/"/>
      <url>/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="设计的zab算法"><a href="#设计的zab算法" class="headerlink" title="设计的zab算法"></a>设计的zab算法</h2><blockquote><p>Zab协议是为分布式协调服务Zookeeper专门设计的一种 支持崩溃恢复 的 原子广播协议 ，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议。</p></blockquote><h3 id="discovery阶段"><a href="#discovery阶段" class="headerlink" title="discovery阶段"></a>discovery阶段</h3><h3 id="synchronization阶段"><a href="#synchronization阶段" class="headerlink" title="synchronization阶段"></a>synchronization阶段</h3><h3 id="broadcast阶段"><a href="#broadcast阶段" class="headerlink" title="broadcast阶段"></a>broadcast阶段</h3><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><blockquote><p>一旦 Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。</p></blockquote><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>需要全量发送history:<br>follower -&gt; leader -&gt; follower</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.youtube.com/watch?v=pbmyrNjzdDk">https://www.youtube.com/watch?v=pbmyrNjzdDk</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C">ZooKeeper源码分析与实战</a></li><li><a href="https://www.huaweicloud.com/articles/b696779df9cf3272db9695a83efae29f.html">Zab协议：一致性协议</a></li><li><a href="https://www.huaweicloud.com/articles/ca89fb0a9b4ada8bd5784a5d5992fa6b.html">ZAB和Paxos算法的联系与区别</a></li><li><a href="https://www.jianshu.com/p/78cdf955ceca">算法ZAB与Paxos</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> distribute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consistency </tag>
            
            <tag> zab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TiDB</title>
      <link href="/tidb/"/>
      <url>/tidb/</url>
      
        <content type="html"><![CDATA[<h2 id="NewSQL"><a href="#NewSQL" class="headerlink" title="NewSQL"></a>NewSQL</h2><ol><li>强一致事务是否必须在数据库层解决？</li><li>数据的增长速度是否不可预估的？</li><li>扩容的频率是否已超出了自身运维能力？</li><li>相比响应时间更看重吞吐？</li><li>是否必须做到对应用完全透明？</li><li>是否有熟悉NewSQL数据库的DBA团队？</li></ol><p>优点：</p><ol><li>高度兼容MySQL: 大多数情况下，无需修改代码即可从 MySQL 轻松迁移至 TiDB，分库分表后的 MySQL 集群亦可通过 TiDB 工具进行实时迁移。</li><li>水平弹性扩展: 通过简单地增加新节点即可实现 TiDB 的水平扩展，按需扩展吞吐或存储，轻松应对高并发、海量数据场景。</li><li>分布式事务: TiDB 100% 支持标准的 ACID 事务。</li><li>真正金融级高可用: 相比于传统主从 (M-S) 复制方案，基于 Raft 的多数派选举协议可以提供金融级的 100% 数据强一致性保证，且在不丢失大多数副本的前提下，可以实现故障的自动恢复 (auto-failover)，无需人工介入。</li><li>一站式HTAP解决方案: TiDB 作为典型的 OLTP 行存数据库，同时兼具强大的 OLAP 性能，配合 TiSpark，可提供一站式 HTAP解决方案，一份存储同时处理OLTP &amp; OLAP无需传统繁琐的 ETL 过程。</li><li>云原生SQL数据库: TiDB 是为云而设计的数据库，同 Kubernetes深度耦合，支持公有云、私有云和混合云，使部署、配置和维护变得十分简单。</li></ol><h2 id="TiDB-Server"><a href="#TiDB-Server" class="headerlink" title="TiDB Server"></a>TiDB Server</h2><blockquote><p>SQL 层，对外暴露 MySQL 协议的连接 endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划。TiDB 层本身是无状态的，实践中可以启动多个 TiDB 实例，通过负载均衡组件（如 LVS、HAProxy 或 F5）对外提供统一的接入地址，客户端的连接可以均匀地分摊在多个 TiDB 实例上以达到负载均衡的效果。TiDB Server 本身并不存储数据，只是解析 SQL，将实际的数据读取请求转发给底层的存储节点 TiKV（或 TiFlash）。</p></blockquote><h2 id="PD-Placement-Driver-Server"><a href="#PD-Placement-Driver-Server" class="headerlink" title="PD (Placement Driver Server)"></a>PD (Placement Driver Server)</h2><blockquote><p>整个 TiDB 集群的元信息管理模块，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，并为分布式事务分配事务 ID。PD 不仅存储元信息，同时还会根据 TiKV 节点实时上报的数据分布状态，下发数据调度命令给具体的 TiKV 节点，可以说是整个集群的“大脑”。此外，PD 本身也是由至少 3 个节点构成，拥有高可用的能力。建议部署奇数个 PD 节点。</p></blockquote><p>对以上的问题和场景进行分类和整理，可归为以下两类：</p><p>第一类：作为一个分布式高可用存储系统，必须满足的需求，包括几种：</p><ol><li>副本数量不能多也不能少</li><li>副本需要根据拓扑结构分布在不同属性的机器上</li><li>节点宕机或异常能够自动合理快速地进行容灾</li></ol><p>第二类：作为一个良好的分布式系统，需要考虑的地方包括：</p><ol><li>维持整个集群的 Leader 分布均匀</li><li>维持每个节点的储存容量均匀</li><li>维持访问热点分布均匀</li><li>控制负载均衡的速度，避免影响在线服务</li><li>管理节点状态，包括手动上线/下线节点</li></ol><p>满足第一类需求后，整个系统将具备强大的容灾功能。满足第二类需求后，可以使得系统整体的资源利用率更高且合理，具备良好的扩展性。</p><p>为了满足这些需求，首先需要收集足够的信息，比如每个节点的状态、每个 Raft Group 的信息、业务访问操作的统计等；其次需要设置一些策略，PD 根据这些信息以及调度的策略，制定出尽量满足前面所述需求的调度计划；最后需要一些基本的操作，来完成调度计划。</p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>每个 TiKV 节点会定期向 PD 汇报节点的状态信息</p><p>每个 Raft Group 的 Leader 会定期向 PD 汇报 Region 的状态信息</p><h3 id="TSO"><a href="#TSO" class="headerlink" title="TSO"></a>TSO</h3><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><h3 id="Split-Merge"><a href="#Split-Merge" class="headerlink" title="Split/Merge"></a>Split/Merge</h3><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h2 id="TiKV-Server"><a href="#TiKV-Server" class="headerlink" title="TiKV Server"></a>TiKV Server</h2><blockquote><p>负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region。TiKV 的 API 在 KV 键值对层面提供对分布式事务的原生支持，默认提供了 SI (Snapshot Isolation) 的隔离级别，这也是 TiDB 在 SQL 层面支持分布式事务的核心。TiDB 的 SQL 层做完 SQL 解析后，会将 SQL 的执行计划转换为对 TiKV API 的实际调用。所以，数据都存储在 TiKV 中。另外，TiKV 中的数据都会自动维护多副本（默认为三副本），天然支持高可用和自动故障转移。</p></blockquote><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ol><li>Atomicity(原子性): 要么都成功, 要么都失败</li><li>Consistency(一致性): 任何事务都不破坏事务的完整性</li><li>Isolation(隔离性): 防止事务交叉执行, 而导致的数据不一致</li><li>Durability(持久性): 任何修改提交后都是持久的, 不会丢失。</li></ol><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol><li>Read uncommitted: 会有脏读问题</li><li>Read committed: 不可重复读</li><li>Repeatable read: 幻读问题。事务A select全表, 发现只有id为1和2的数据, 然后事务B插入id为3的数据后进行了提交, 当事务A也插入id为3的数据时会失败。</li></ol><h3 id="Percolator"><a href="#Percolator" class="headerlink" title="Percolator"></a>Percolator</h3><h4 id="TSO-TimeStamp-Oracle"><a href="#TSO-TimeStamp-Oracle" class="headerlink" title="TSO (TimeStamp Oracle)"></a>TSO (TimeStamp Oracle)</h4><h4 id="2pc"><a href="#2pc" class="headerlink" title="2pc"></a>2pc</h4><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-architecture">TiDB 整体架构</a></li><li><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-storage">TiDB 数据库的存储</a></li><li><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-computing">TiDB 数据库的计算</a></li><li><a href="https://docs.pingcap.com/zh/tidb/stable/tidb-scheduling">TiDB 数据库的调度</a></li><li><a href="https://talkgo.org/t/topic/68">go夜读-TiDB 源码阅读之 Transaction</a></li><li><a href="https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/two-phase-locking">TiDB 乐观事务 + SRTT 算法及其并发瓶颈</a></li><li><a href="https://pingcap.com/blog-cn/pessimistic-transaction-the-new-features-of-tidb">TiDB 新特性漫谈：悲观事务</a></li><li><a href="https://pingcap.com/blog-cn/tidb-transaction-model">TiKV 事务模型概览，Google Spanner 开源实现</a></li><li><a href="https://www.youtube.com/watch?v=A46VE3aUTKo">TiDB 源码阅读之 Transaction 【 Go 夜读 】</a></li><li><a href="https://blog.csdn.net/chdhust/article/details/74839277">分布式系统的时间</a></li><li><a href="https://zhuanlan.zhihu.com/p/261115166">Percolator - 分布式事务的理解与分析</a></li><li><a href="https://pingcap.com/zh/blog/placement-driver">TiKV 功能介绍 - Placement Driver</a></li><li><a href="https://pingcap.com/zh/blog/talk-principles-practice">Building a Reliable Large-Scale Distributed Database - Principles and Practice</a></li><li><a href="https://pingcap.com/zh/blog/the-design-and-implementation-of-multi-raft">TiKV 源码解析系列 - multi-raft 设计与实现</a></li><li><a href="https://yushuangqi.com/blog/2016/tidb-yuan-ma-chu-tan.html">TiDB源码初探</a></li></ol><p><a href="https://docs.pingcap.com/zh/tidb/stable/tikv-overview">https://docs.pingcap.com/zh/tidb/stable/tikv-overview</a></p><p><a href="https://zhuanlan.zhihu.com/p/24118962">https://zhuanlan.zhihu.com/p/24118962</a></p><p><a href="http://research.google.com/pubs/pub36726.html">http://research.google.com/pubs/pub36726.html</a></p><p><a href="https://pingcap.com/blog-cn/percolator-and-txn/">https://pingcap.com/blog-cn/percolator-and-txn/</a></p><p><a href="https://www.jianshu.com/p/513fc11cbb1e">https://www.jianshu.com/p/513fc11cbb1e</a></p><p><a href="https://docs.jdcloud.com/cn/tidb-service/secondary-index">https://docs.jdcloud.com/cn/tidb-service/secondary-index</a></p><p><a href="https://docs.pingcap.com/zh/tidb/stable/optimistic-transaction">https://docs.pingcap.com/zh/tidb/stable/optimistic-transaction</a></p><p><a href="https://docs.pingcap.com/zh/tidb/stable/pessimistic-transaction">https://docs.pingcap.com/zh/tidb/stable/pessimistic-transaction</a></p><p><a href="https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/two-phase-locking">https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/two-phase-locking</a></p><p><a href="https://www.jdon.com/55452">https://www.jdon.com/55452</a></p><p><a href="https://github.com/ngaut/builddatabase">https://github.com/ngaut/builddatabase</a></p><p><a href="https://www.iocoder.cn/TiDB/good-collection/">https://www.iocoder.cn/TiDB/good-collection/</a></p><p><a href="https://blog.csdn.net/TiDB_PingCAP/article/details/99945822">https://blog.csdn.net/TiDB_PingCAP/article/details/99945822</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang map实现</title>
      <link href="/golang-map/"/>
      <url>/golang-map/</url>
      
        <content type="html"><![CDATA[<h2 id="map内部数据结构"><a href="#map内部数据结构" class="headerlink" title="map内部数据结构"></a>map内部数据结构</h2><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/golang-map/map-view.jpg" alt="map内部结构-整体"></p><h3 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h3><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> {</span><br><span class="line"><span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">count <span class="type">int</span></span><br><span class="line">flags <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// buckets 的对数 log_2</span></span><br><span class="line">B <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">noverflow <span class="type">uint16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">hash0 <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line"><span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">buckets unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">oldbuckets unsafe.Pointer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">nevacuate <span class="type">uintptr</span></span><br><span class="line">extra     *mapextra</span><br><span class="line"></span><br><span class="line"><span class="comment">// optional fields</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="buckets"><a href="#buckets" class="headerlink" title="buckets"></a>buckets</h3><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> {</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h3><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> {</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="type">uintptr</span></span><br><span class="line">    overflow  <span class="type">uintptr</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><h2 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h2><h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>当负载过多时, 会触发增量扩容</p><h3 id="原地整理"><a href="#原地整理" class="headerlink" title="原地整理"></a>原地整理</h3><p>当overflow过多时, 会触发原地整理迁移</p><h3 id="渐进式迁移"><a href="#渐进式迁移" class="headerlink" title="渐进式迁移"></a>渐进式迁移</h3><p>每次最多前一两个bucket</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="普通遍历"><a href="#普通遍历" class="headerlink" title="普通遍历"></a>普通遍历</h3><h3 id="渐进式迁移过程中的map遍历"><a href="#渐进式迁移过程中的map遍历" class="headerlink" title="渐进式迁移过程中的map遍历"></a>渐进式迁移过程中的map遍历</h3><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="key-可以是-float-型吗"><a href="#key-可以是-float-型吗" class="headerlink" title="key 可以是 float 型吗"></a>key 可以是 float 型吗</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://my.oschina.net/renhc/blog/2208417">Go map实现原理</a></li><li><a href="https://mp.weixin.qq.com/s/2CDpE5wfoiNXm1agMAq4wA">深度解密Go语言之map</a></li><li><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">draveness-golang-map</a></li><li><a href="https://www.cnblogs.com/sunsky303/p/11815172.html">你不知道的Golang map</a></li></ol><p><a href="https://juejin.cn/post/6954707500151078919">https://juejin.cn/post/6954707500151078919</a></p><p><a href="https://segmentfault.com/a/1190000023879178">https://segmentfault.com/a/1190000023879178</a></p><p><a href="https://www.cnblogs.com/33debug/p/11851585.html">https://www.cnblogs.com/33debug/p/11851585.html</a></p><p><a href="https://github.com/cch123/golang-notes/blob/master/map.md">https://github.com/cch123/golang-notes/blob/master/map.md</a></p><p><a href="https://lukechampine.com/hackmap.html">https://lukechampine.com/hackmap.html</a></p><p><a href="https://juejin.cn/post/6844903848587296781">https://juejin.cn/post/6844903848587296781</a></p><p><a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a></p><p><a href="https://cloud.tencent.com/developer/article/1422446">https://cloud.tencent.com/developer/article/1422446</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Memory Model</title>
      <link href="/golang-memory-model/"/>
      <url>/golang-memory-model/</url>
      
        <content type="html"><![CDATA[<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><ol><li>init函数顺序: a依赖b。那么b包的init函数happens-before于a包的init函数</li><li>启动goroutine的go语句的执行, 一定happens-before此goroutine内代码的执行</li><li>channel<ol><li>发送 happens-before 接受</li><li>close() happens-before 从关闭的Channel中读取出一个零值</li><li>对于unbuffered的Channel, 读取数据的调用一定happens-before往此Channel发送数据的调用完成</li><li>对于buffered channel, 如果Channel的容量是m(m&gt;0), 那么第n个receive一定happens-before 第n+m个send的完成</li></ol></li><li>互斥锁: 第n次的m.Unlock一定happens-before第n+1次m.Lock方法的返回</li><li>Once: 对于once.Do(f), 函数f一定会在Do方法返回前执行</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a></li><li>《极客时间-Go并发编程实战》</li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础知识</title>
      <link href="/redis/"/>
      <url>/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/xmind/redis.xmind.svg" alt="Redis思维导图"></p><h2 id="高性能IO模型"><a href="#高性能IO模型" class="headerlink" title="高性能IO模型"></a>高性能IO模型</h2><p>请参考我的另一篇文章:<a href="/high-performance-network-model/">高性能网络模型</a></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="AOF基本概念"><a href="#AOF基本概念" class="headerlink" title="AOF基本概念"></a>AOF基本概念</h4><p>相比于数据库的写前日志(Write Ahead Log, WAL), AOF是在执行完命令后, 写入的日志。</p><p>传统的数据库日志如redo log(重做日志), 记录的是修改后的数据, 而AOF里记录的是Redis服务器收到的每一条redis通信协议格式的命令。</p><p>为了避免开销, 写AOF之前并不会进行语法校验。所以先记日志再执行的话，可能会记录错误的指令。<br>而如果先执行命令, 成功后再记录AOF的话，就不会存在这样的问题。</p><h4 id="AOF三种写回策略"><a href="#AOF三种写回策略" class="headerlink" title="AOF三种写回策略"></a>AOF三种写回策略</h4><p>可以选择appendfsync配置的三个可选值, 来选择对应的写回策略</p><ul><li>always, 每个写命令都立即将日志写回磁盘</li><li>everysec, 每秒写回</li><li>no, redis不主动写回磁盘, 只是先把日志写到AOF文件的内存缓冲区中, 由操作系统决定何时写回磁盘。</li></ul><h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><p>在重写时, 创建一个新的AOF文件, 扫描当前数据库中的所有键值对, 并写入到这个新的AOF文件中。<br>这样就可以减少AOF文件里key的无用历史记录。</p><p>重写是由后台线程bgrewriteof来完成的，被主线程fork出来的时候会有主线程的一份内存拷贝, 这里就包含了数据库的最新数据。<br>bgrewriteof子进程就可以在不影响主线程的情况下, 写入重写日志。<br>如果redis在这期间内有新的写入, 在写入AOF缓冲的时候, 还会往AOF重写缓冲里写一份数据。等重写日志完成后, 这些新的操作记录也会写入到新的AOF文件中。<br>之后就可以用新的AOF文件替代旧文件了。</p><blockquote><p>fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。我的描述不太严谨了，非常感谢指出！</p></blockquote><blockquote><p>Kaito同学还提到了Huge page。这个特性大家在使用Redis也要注意。Huge page对提升TLB命中率比较友好，因为在相同的内存容量下，使用huge page可以减少页表项，TLB就可以缓存更多的页表项，能减少TLB miss的开销。</p></blockquote><blockquote><p>但是，这个机制对于Redis这种喜欢用fork的系统来说，的确不太友好，尤其是在Redis的写入请求比较多的情况下。因为fork后，父进程修改数据采用写时复制，复制的粒度为一个内存页。如果只是修改一个256B的数据，父进程需要读原来的内存页，然后再映射到新的物理地址写入。一读一写会造成读写放大。如果内存页越大（例如2MB的大页），那么读写放大也就越严重，对Redis性能造成影响。</p></blockquote><blockquote><p>Huge page在实际使用Redis时是建议关掉的。</p></blockquote><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>可以使用save命令让主进程执行全量快照备份, 也可以使用bgsave命令fork出子进程进行快照备份。<br>在快照过程中如果有写操作, 那么会触发fork的copy on write机制。</p><h3 id="混合快照"><a href="#混合快照" class="headerlink" title="混合快照"></a>混合快照</h3><p>混合RDB和AOF</p><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p>可以通过replicaof命令(Redis5.0之前是slaveof), 设置主从关系。<br>比如在B实例上执行如下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;A实例的IP地址&gt; &lt;A实例的Redis端口&gt;</span><br></pre></td></tr></tbody></table></figure><p>就可以让B作为A的从库, 并从A上复制数据。</p><h3 id="主从间同步数据"><a href="#主从间同步数据" class="headerlink" title="主从间同步数据"></a>主从间同步数据</h3><h4 id="第一阶段-建立连接-协商同步"><a href="#第一阶段-建立连接-协商同步" class="headerlink" title="第一阶段: 建立连接, 协商同步"></a>第一阶段: 建立连接, 协商同步</h4><p>从实例会给主实例发送 psync {runID} {offset} 。<br>第一次建立主从关系的话, 从实例是不知道主实例的runID的, 所以runID部分会是’?’。<br>之前没有同步过数据, 所以offset部分是-1。</p><p>主实例收到建立的请求后, 会向从实例发送<code>FULLRESYNC</code> {runID} {offset}。<br><code>FULLRESYNC</code> 表示第一次复制采用的全量复制, 也就是说, 主库会把当前所有的数据都复制给从库。</p><h4 id="第二阶段-主库同步数据给从库"><a href="#第二阶段-主库同步数据给从库" class="headerlink" title="第二阶段: 主库同步数据给从库"></a>第二阶段: 主库同步数据给从库</h4><p>主库执行bgsave命令, 生成RDB文件传输给从库。<br>从库收到RDB文件后, 会先清空当前数据库, 在本地完成RDB加载。<br>在同步期间如果有新的数据产生, 主库会在内存中用专门的replication buffer 记录RDB文件生成后收到的所有写操作。</p><h4 id="第三阶段-主库发送新写命令给从库"><a href="#第三阶段-主库发送新写命令给从库" class="headerlink" title="第三阶段: 主库发送新写命令给从库"></a>第三阶段: 主库发送新写命令给从库</h4><p>主库把replication buffer发送给从库。</p><h4 id="主从级联模式"><a href="#主从级联模式" class="headerlink" title="主从级联模式"></a>主从级联模式</h4><p><code>主-从</code>模式下, 如果从库数量很多, 那么会给主库带来压力。所以可以考虑<code>主-从-从</code>模式。</p><h3 id="主从库间网络断了怎么办？"><a href="#主从库间网络断了怎么办？" class="headerlink" title="主从库间网络断了怎么办？"></a>主从库间网络断了怎么办？</h3><p>在Redis2.8之前, 在网络断了后, 主从会重新进行一次全量复制。</p><p>在Redis2.8开始, 网络断了后, 会先采用增量复制的方式继续同步。</p><p>repl_backlog_buffer是一个环形缓冲区, 主库会记录自己写到的位置, 从库则会记录自己已经读到的位置。<br>大小一般设置为：<code>(主库写入命令速度*操作大小 - 主从库间网络传输命令速度*操作大小) * 2</code></p><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>哨兵主要负责三个任务: 监控、选主、通知。</p><ul><li>监控: 哨兵进程在运行时, 周期性地给所有的主从库发送PING命令, 检测他们是否仍然在线运行。<br>如果再规定的时间内没有响应PING命令, 那么会标记为”下线状态”。如果主库下线的话, 就会开始自动切换主库的流程。</li><li>选主: 主库挂了后, 哨兵就需要从很多歌从库里, 选择一个新主库。选主的过程, 又分为 <code>筛选</code> 和 <code>打分</code>两个阶段。<ul><li>筛选。不在线的从库需要筛选出去。网络总是段连的从库需要筛选出去。(根据配置项down-after-milliseconds * 10判定。<br>down-after-milliseconds是主从库锻炼的最大连接超时时间。如果断连次数超过10次, 那么说明这个从库的网络状况不好)</li><li>打分。打分会经过多轮, 如果某一轮出现了得分最高的从库, 那么那么它就是主库了, 选主过程到此结束。否则继续下一轮选举。<ul><li>第一轮: 优先级最高的从库的最高分。</li><li>第二轮: 和旧主库同步程度最接近的从库得最高分。</li><li>第三轮: ID号小的从库得高分。</li></ul></li></ul></li><li>通知: 选好新的主库后, 哨兵会把新主库的链接信息发送给其他从库, 让他们执行eplicaof命令,<br>和新主库建立连接, 并进行数据复制。同时, 哨兵会把新主库的链接信息通知给客户端, 让他们把请求操作发送到新主库上。</li></ul><p>在redis哨兵集群中, 有N/2 + 1 个哨兵认为主库下线了(这个值由redis管理员设定), 才能最终判定为”客观下线”, 进行新主库的选举。</p><p>在redis主库中, 有一个名为”<strong>sentinel</strong>:hello”的<code>pub/sub</code>频道, 哨兵把自己的IP和端口发布到<br>“<strong>sentinel</strong>:hello”频道上, 其他哨兵订阅了这个频道后就可以获取到该哨兵的IP和端口, 以此来建立连接, 组成哨兵集群。</p><p>哨兵除了彼此之间建立连接形成集群意外, 还需要和从库建立连接, 对主从库都进行心跳判断。</p><p>哨兵通过给主库发送INFO命令来获取从库的信息。</p><p>本质上说, 哨兵就是一个运行在特定模式下的Redis实例, 只不过它并不服务其他请求操作, 只是完成监控、选主和通知的任务。<br>每个哨兵实例也提供pub/sub机制, 客户端可以从哨兵订阅消息。哨兵提供的消息大致有一下几个：</p><table><thead><tr><th>事件</th><th>相关频道</th></tr></thead><tbody><tr><td>实例进入”主观下线”装填</td><td>+sdown</td></tr><tr><td>实例退出”主观下线”装填</td><td>-sdown</td></tr><tr><td>实例进入”客观下线”装填</td><td>+odown</td></tr><tr><td>实例退出”客观下线”装填</td><td>-0down</td></tr><tr><td>哨兵发送SLAVEOF命令重新配置从库</td><td>+slave-reconf-sent</td></tr><tr><td>从库配置了新主库, 但尚未进行同步</td><td>+slave-reconf-inprog</td></tr><tr><td>从库配置了新主库, 且和新主库完成同步</td><td>+slave-reconf-done</td></tr><tr><td>新主库切换</td><td>+switch-master</td></tr></tbody></table><p>客户端可以订阅这些消息来获取相信的信息。比如订阅所有所实例的客观下线状态的事件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE +odown</span><br></pre></td></tr></tbody></table></figure><p>或者订阅所有的事件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE *</span><br></pre></td></tr></tbody></table></figure><p>当哨兵把新主库选择出来后, 客户端就会看到下面的switch-master事件, 这样就会知道新主库的地址和端口了。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</span><br></pre></td></tr></tbody></table></figure><p>leader哨兵才可以执行主从切换的过程。哨兵leader选举需要满足2个条件：<br>    1. 拿到半数以上的票<br>    1. 拿到的票数大于等于哨兵配置文件中的quorum值</p><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><h3 id="横向扩容？纵向扩容？"><a href="#横向扩容？纵向扩容？" class="headerlink" title="横向扩容？纵向扩容？"></a>横向扩容？纵向扩容？</h3><p>纵向机器成本高, 也会导致单实例存储的数据过多, RDB有压力</p><h3 id="Redis-Cluster是什么"><a href="#Redis-Cluster是什么" class="headerlink" title="Redis Cluster是什么"></a>Redis Cluster是什么</h3><p>采用哈希槽(Hash Slot)来处理数据和实例之间的映射关系。<br>在Redis Cluster方案中, 一个切片集群共有16384个哈希槽，<br>这些哈希槽类似于数据分区, 每个键值对都会根据key映射到一个哈希槽中。</p><h3 id="槽是怎么计算的"><a href="#槽是怎么计算的" class="headerlink" title="槽是怎么计算的"></a>槽是怎么计算的</h3><p>按照CRC16算法计算一个16bit的值, 然后再由这个16bit值对16384取模, 得到哈希槽的编号。</p><p>如果集群中有N个实例, 那么实例上的槽的个数为16384/N个。</p><p>也可以使用<code>cluster addslots</code>命令指定每个实例上的哈希槽个数。如果总共设置了5个槽, 那么槽的编号就是<code>CRC16(key)%5</code>。</p><h3 id="客户端怎么知道哪个key在哪个实例上？"><a href="#客户端怎么知道哪个key在哪个实例上？" class="headerlink" title="客户端怎么知道哪个key在哪个实例上？"></a>客户端怎么知道哪个key在哪个实例上？</h3><p>Redis会把自己的槽信息发送给和它相连的其他信息, 这样每个实例就有所有的槽信息了。</p><p>当客户端访问任意一个实例时, 便可以把槽的信息缓存在本地, 这样就知道对应的key应该发给哪个实例了。</p><h3 id="在集群中-实例和哈希槽的对应关系发生变化了怎么办？"><a href="#在集群中-实例和哈希槽的对应关系发生变化了怎么办？" class="headerlink" title="在集群中, 实例和哈希槽的对应关系发生变化了怎么办？"></a>在集群中, 实例和哈希槽的对应关系发生变化了怎么办？</h3><p>Redis Cluster提供了一种重定向机制: 当客户端给一个Redis实例发送数据读写操作时, 如果这个实力上并没有对应的数据,<br>这个实例就会给客户端返回MOVED重定向命令, 其中就带着对应实例的IP和端口</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) MOVED 13320 172.16.19.5:5379</span><br></pre></td></tr></tbody></table></figure><p>如果slot正好再迁移中, 那么可能会返回ASK命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) ASK 13320 172.16.19.5:5379</span><br></pre></td></tr></tbody></table></figure><h3 id="为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？"><a href="#为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？" class="headerlink" title="为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？"></a>为什么对key做CRC计算？直接key的slot的对应关系存下来可以吗？</h3><p>不行。</p><ol><li>表的量会随着key增加而增大</li><li>这个表只存一份的话会有单点问题, 如果部署多份的话会有一致性问题, 提高了系统复杂度。</li><li>CRC类似于hash, 可以使哈希结果更加分散</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>极客时间, 《Redis核心技术与实战》</li><li>《Redis 5 设计与源码分析》</li><li>《Redis设计与实现》</li><li><a href="https://blog.csdn.net/qingyangcc123/article/details/107644885">解析Redis网络模型的源码</a></li><li><a href="https://www.cnblogs.com/lizhimin123/p/10197431.html">Redis源码剖析（十一）–AOF持久化</a></li><li><a href="https://blog.csdn.net/bruce128/article/details/104579288">redis aof持久化源码分析</a></li><li><a href="https://blog.csdn.net/hangbo216/article/details/68925644">redis aof持久化的源码分析</a></li><li><a href="https://blog.csdn.net/Namcodream521/article/details/83032615">kqueue的用法</a></li><li><a href="https://my.oschina.net/xilidou/blog/4381183">Redis 中的事件驱动模型</a></li><li><a href="https://blog.csdn.net/qq_35181209/article/details/80353299">Redis时间事件源码解析</a></li><li><a href="https://redisbook.readthedocs.io/en/latest/internal/ae.html">Redis事件</a></li><li><a href="https://www.dazhuanlan.com/2019/12/16/5df6dec38a0fa/">Redis 客户端与服务器连接流程实例</a></li><li><a href="https://blog.csdn.net/fishmai/article/details/78515355">深入浅出 Redis client/server交互流程</a></li><li><a href="https://blog.csdn.net/qq_32095699/article/details/99689830">Linux – fork() 写时拷贝（copy-on-write）</a></li><li><a href="https://vlambda.com/wz_5hpcZyGM8O2.html">Redis的RDB持久化</a></li><li><a href="https://zhuanlan.zhihu.com/p/27441342">Java NIO(7): Epoll版的Selector</a></li><li><a href="https://juejin.cn/post/6916042914837561351">石杉的架构笔记一杯茶的功夫，上手Redis持久化机制</a></li><li><a href="https://jiekun.dev/posts/redis-tio-implementation/">https://jiekun.dev/posts/redis-tio-implementation/</a></li><li><a href="https://jiekun.dev/posts/2020-03-14-redis-6-0-acl%E5%9F%BA%E4%BA%8Ebitmap%E5%AE%9E%E7%8E%B0/">https://jiekun.dev/posts/2020-03-14-redis-6-0-acl%E5%9F%BA%E4%BA%8Ebitmap%E5%AE%9E%E7%8E%B0/</a></li><li><a href="https://jiekun.dev/posts/2020-01-31-redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/">https://jiekun.dev/posts/2020-01-31-redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/</a></li><li><a href="https://blog.csdn.net/cywosp/article/details/8767327">https://blog.csdn.net/cywosp/article/details/8767327</a></li><li><a href="https://blog.csdn.net/xinghuah/article/details/80487525">https://blog.csdn.net/xinghuah/article/details/80487525</a></li><li><a href="https://www.iocoder.cn/Redis/good-collection/">https://www.iocoder.cn/Redis/good-collection/</a></li><li><a href="https://draveness.me/whys-the-design-redis-single-thread/">https://draveness.me/whys-the-design-redis-single-thread/</a></li><li><a href="https://draveness.me/whys-the-design-redis-bgsave-fork/">https://draveness.me/whys-the-design-redis-bgsave-fork/</a></li><li><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li><a href="https://segmentfault.com/a/1190000038398292">一个基于运气的数据结构, zset</a></li><li><a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></li><li><a href="https://zhenghe-md.github.io/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/">https://zhenghe-md.github.io/blog/2020/03/08/Scaling-Memcache-at-Facebook-2013/</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C">300分钟吃透分布式缓存</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98">Redis 核心原理与实战</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9137897.html">深入学习Redis（2）：持久化</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html">深入学习Redis（3）：主从复制</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9609938.html">深入学习Redis（4）：哨兵</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9853040.html">深入学习Redis（5）：集群</a></li><li><a href="https://www.cnblogs.com/javastack/p/12848446.html">Redis 到底是单线程还是多线程？我要吊打面试官！</a></li><li><a href="https://blog.csdn.net/weixin_45583158/article/details/100143587">正式支持多线程！Redis 6.0与老版性能对比评测</a></li><li><a href="https://zhuanlan.zhihu.com/p/80335611">为什么Redis集群有16384个槽</a></li><li><a href="https://zhuanlan.zhihu.com/p/145186839">你了解 Redis 的三种集群模式吗？</a></li><li><a href="https://juejin.cn/post/6844903663362637832">深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</a></li><li><a href="https://blog.csdn.net/u013378306/article/details/109707279">redis 主从同步过程原理 以及 RDB/AOF/混合模式 持久化日志</a></li><li><a href="https://zhuanlan.zhihu.com/p/41228196">P2P 网络核心技术：Gossip 协议</a></li><li><a href="https://www.kancloud.cn/digest/redis-code">Redis源码分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor-Model</title>
      <link href="/reactor-model/"/>
      <url>/reactor-model/</url>
      
        <content type="html"><![CDATA[<h2 id="传统多线程"><a href="#传统多线程" class="headerlink" title="传统多线程"></a>传统多线程</h2><h2 id="单线程Reactor模式"><a href="#单线程Reactor模式" class="headerlink" title="单线程Reactor模式"></a>单线程Reactor模式</h2><p>异步非阻塞IO</p><blockquote><p>传统方案，也就是一个请求开一个线程在请求数量庞大时是无法接受的，所以我们需要去寻求一种高伸缩性的方案，请求数量低的时候效率很高而且请求数量很庞大的时候依旧不会崩溃。<br>主要有以下几点 当客户端数量庞大的时候，我们的服务要能够优雅地降低速度但是不至于崩溃。</p><p>但是任务分发可能会更慢，而且必须手动将事件和对应的处理动作绑定，相应的编程实现也会更难。</p></blockquote><ol><li>当一个NIO线程同时处理成百上千的链路，性能上无法支撑，即使NIO线程的CPU负荷达到100%，也无法完全处理消息</li><li>当NIO线程负载过重后，处理速度会变慢，会导致大量客户端连接超时，超时之后往往会重发，更加重了NIO线程的负载。</li><li>可靠性低，一个线程意外死循环，会导致整个通信系统不可用</li></ol><h2 id="Reactor线程池模式"><a href="#Reactor线程池模式" class="headerlink" title="Reactor线程池模式"></a>Reactor线程池模式</h2><p>使用线程池</p><blockquote><p>在绝大多数场景下，该模型都能满足性能需求。但是，在一些特殊的应用场景下，如服务器会对客户端的握手消息进行安全认证。这类场景下，单独的一个Acceptor线程可能会存在性能不足的问题。</p></blockquote><h2 id="Reactor主从模式"><a href="#Reactor主从模式" class="headerlink" title="Reactor主从模式"></a>Reactor主从模式</h2><p>单Reactor缺点:</p><ol><li>单Reactor需要响应连接和读写事件，单线程处理任务较多</li><li>单Reactor连接和读写事件放在一块处理，会互相影响，而且本身读写事件是一个比较<br>耗时的操作，当一个读写事件处理事件太长，那么势必会影响下一个连接事件的处理，影响<br>用户连接，这是个非常不友好的事情，很影响体验</li></ol><h2 id="Netty中Reactor主从模式的变种"><a href="#Netty中Reactor主从模式的变种" class="headerlink" title="Netty中Reactor主从模式的变种"></a>Netty中Reactor主从模式的变种</h2><p>去掉了Reactor的线程池。</p><blockquote><p>当系统在运行过程中，如果频繁的进行线程上下文切换，会带来额外的性能损耗。</p><p>多线程并发执行某个业务流程，业务开发者还需要时刻对线程安全保持警惕，哪些数据可能会被并发修改，如何保护？这不仅降低了开发效率，也会带来额外的性能损耗。</p><p>为了解决上述问题，Netty采用了串行化设计理念</p><p>从消息的读取、编码以及后续Handler的执行，始终都由IO线程EventLoop负责，这就意味着整个流程不会进行线程上下文的切换，数据也不会面临被并发修改的风险。这也解释了为什么Netty线程模型去掉了Reactor主从模型中线程池。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/381483820">深入Netty逻辑架构，从Reactor线程模型开始</a></li><li><a href="https://haoxpdp.github.io/categories/sth/scalableIOinJava/"><scalable io="" in="" java=""> 翻译</scalable></a></li><li><a href="https://www.cnblogs.com/shoshana-kong/p/14652527.html">一步一图，带你走进 Netty 的世界！</a></li><li><a href="https://zhuanlan.zhihu.com/p/70970558">高性能：《一遍文章带你看懂 Netty世界》</a></li><li><a href="https://www.cnblogs.com/zl1991/p/12098272.html">高性能跨平台网络IO（Reactor、epoll、iocp）总结</a></li><li><a href="https://blog.csdn.net/weixin_38312719/article/details/108271087">Reactor(主从)原理详解与实现</a></li><li><a href="https://blog.csdn.net/qq_37535749/article/details/115400243">单Reactor和主从Reactor模式介绍</a></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp</title>
      <link href="/tcp/"/>
      <url>/tcp/</url>
      
        <content type="html"><![CDATA[<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-con.jpg" alt="三次握手"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-close-con.jpg" alt="四次挥手"></p><h2 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><blockquote><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。</p></blockquote><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><blockquote><p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p></blockquote><blockquote><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。</p></blockquote><h3 id="SACK重传机制-Selective-Acknowledgment-选择性确认"><a href="#SACK重传机制-Selective-Acknowledgment-选择性确认" class="headerlink" title="SACK重传机制(Selective Acknowledgment 选择性确认)"></a>SACK重传机制(Selective Acknowledgment 选择性确认)</h3><blockquote><p>这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p></blockquote><h3 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h3><blockquote><p>D-SACK 有这么几个好处： </p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol></blockquote><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote><p>拥塞窗口 cwnd 变化的规则：</p><ol><li>只要网络中没有出现拥塞，cwnd 就会增大；</li><li>但网络中出现了拥塞，cwnd 就减少；</li></ol></blockquote><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><blockquote><p>为什么需要慢启动?</p><p>发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件而动态改变速度。此时，根据交换数据来估算客户端与服务器之间的可用带宽是唯一的方法，而且这也是慢启动算法的设计思路。</p></blockquote><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。<br>一般来说 ssthresh 的大小是 65535 字节。</p><h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：tcp</p><ul><li>ssthresh 设为 cwnd/2</li><li>cwnd 重置为 1</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-hp01.jpg" alt="拥塞发生"></p><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><blockquote><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p></blockquote><p>进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p><ul><li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li><li>ssthresh = cwnd;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/tcp/tcp-hp02.jpg" alt="快速恢复"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%85%A8%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">全解网络协议</a></li><li><a href="https://blog.csdn.net/qq_34827674/article/details/105606205">小林coding-30 张图解： 面试必问的 TCP 重传、滑动窗口、流量控制、拥塞控制</a></li><li><a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a></li><li><a href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）</a></li><li><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/34%20%20UDP%20%E5%8D%8F%E8%AE%AE%EF%BC%9AUDP%20%E5%92%8C%20TCP%20%E7%9B%B8%E6%AF%94%E5%BF%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F.md">UDP 协议：UDP 和 TCP 相比快在哪里？</a></li><li><a href="https://www.zhihu.com/question/24853633/answer/573627478">TCP 为什么是三次握手，而不是两次或四次？</a></li><li><a href="https://www.huaweicloud.com/articles/8357193.html">Linux系列：TCP慢启动原理（拥塞控制机制）</a></li><li><a href="https://zhuanlan.zhihu.com/p/53374516">“三次握手，四次挥手”你真的懂吗？</a></li><li><a href="https://chenxfeng.github.io/2017/05/10/computer_network/computer_network_3%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82(Transport%20Layer)/">传输层(Transport Layer)</a></li></ol><p><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html">http://www.ruanyifeng.com/blog/2009/03/tcp-ip_model.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html">http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html</a></p><p><a href="https://datatracker.ietf.org/doc/rfc1644/">https://datatracker.ietf.org/doc/rfc1644/</a></p><p><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm</a></p><p><a href="https://www.youtube.com/playlist?list=PLoCMsyE1cvdWKsLVyf6cPwCLDIZnOj0NS">https://www.youtube.com/playlist?list=PLoCMsyE1cvdWKsLVyf6cPwCLDIZnOj0NS</a></p><p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">https://draveness.me/whys-the-design-tcp-three-way-handshake/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-performance/">https://draveness.me/whys-the-design-tcp-performance/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">https://draveness.me/whys-the-design-tcp-segment-ip-packet/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-message-frame/">https://draveness.me/whys-the-design-tcp-message-frame/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-time-wait/">https://draveness.me/whys-the-design-tcp-time-wait/</a></p><p><a href="https://draveness.me/whys-the-design-tcp-message-frame/">https://draveness.me/whys-the-design-tcp-message-frame/</a></p>]]></content>
      
      
      <categories>
          
          <category> internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>udp</title>
      <link href="/udp/"/>
      <url>/udp/</url>
      
        <content type="html"><![CDATA[<h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li>协议开销小、效率高。</li><li>UDP是无连接的，即发送数据之前不需要建立连接。</li><li>UDP使用尽最大努力交付，即不保证可靠交付。</li><li>UDP没有拥塞控制。</li><li>UDP支持一对一、一对多、多对一和多对多交互通信。</li><li>UDP的首部开销小，只有8个字节。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://draveness.me/whys-the-design-udp-minimum-header/">https://draveness.me/whys-the-design-udp-minimum-header/</a></p><ol><li><a href="https://my.oschina.net/u/4482993/blog/4631144">小林coding-20 张图解，为什么 HTTP3.0 使用 UDP 协议？</a></li><li><a href="https://www.cnblogs.com/skyfsm/p/6287787.html">Linux编程之UDP SOCKET全攻略</a></li></ol><p><a href="https://www.cnblogs.com/xiaolincoding/p/15000967.html">https://www.cnblogs.com/xiaolincoding/p/15000967.html</a></p><p><a href="https://blog.csdn.net/guoweimelon/article/details/50878072">https://blog.csdn.net/guoweimelon/article/details/50878072</a></p><p><a href="https://segmentfault.com/a/1190000023501344">https://segmentfault.com/a/1190000023501344</a></p><p><a href="https://www.jianshu.com/p/f5b0c20442ee">https://www.jianshu.com/p/f5b0c20442ee</a></p><p><a href="https://www.huaweicloud.com/articles/12660893.html">https://www.huaweicloud.com/articles/12660893.html</a></p><p><a href="https://www.huaweicloud.com/articles/12534559.html">https://www.huaweicloud.com/articles/12534559.html</a></p><p><a href="https://websec.readthedocs.io/zh/latest/network/udp.html">https://websec.readthedocs.io/zh/latest/network/udp.html</a></p>]]></content>
      
      
      <categories>
          
          <category> internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
            <tag> udp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无锁并发(lock free)</title>
      <link href="/lock-free/"/>
      <url>/lock-free/</url>
      
        <content type="html"><![CDATA[<h2 id="atomic-cas"><a href="#atomic-cas" class="headerlink" title="atomic-cas"></a>atomic-cas</h2><h2 id="lock-free-queue"><a href="#lock-free-queue" class="headerlink" title="lock free queue"></a>lock free queue</h2><p>Disruptor:<br><a href="https://zhuanlan.zhihu.com/p/336912752">https://zhuanlan.zhihu.com/p/336912752</a></p><p><a href="https://blog.csdn.net/xy010902100449/article/details/47045599">https://blog.csdn.net/xy010902100449/article/details/47045599</a></p><p>定长:<br><a href="https://coolshell.cn/articles/8239.html">https://coolshell.cn/articles/8239.html</a><br><a href="http://www.searchtb.com/2012/10/introduction_to_disruptor.html">http://www.searchtb.com/2012/10/introduction_to_disruptor.html</a></p><p>变长:<br><a href="http://blog.csdn.net/linzhaolover/article/details/9771329">http://blog.csdn.net/linzhaolover/article/details/9771329</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://lrita.github.io/2020/04/24/michael-lockfree-queue/">https://lrita.github.io/2020/04/24/michael-lockfree-queue/</a></p><p><a href="http://oceanbase.org.cn/?p=183">http://oceanbase.org.cn/?p=183</a></p><p><a href="https://coolshell.cn/articles/8239.html">https://coolshell.cn/articles/8239.html</a></p><p><a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf</a></p><p><a href="https://blog.csdn.net/en_joker/article/details/101701389">https://blog.csdn.net/en_joker/article/details/101701389</a></p><p><a href="https://www.codeproject.com/Articles/153898/Yet-another-implementation-of-a-lock-free-circul">https://www.codeproject.com/Articles/153898/Yet-another-implementation-of-a-lock-free-circul</a></p><p><a href="https://www.cl.cam.ac.uk/research/srg/netos/papers/2002-casn.pdf">https://www.cl.cam.ac.uk/research/srg/netos/papers/2002-casn.pdf</a></p><p><a href="http://ifeve.com/lock-free-linked-list/">http://ifeve.com/lock-free-linked-list/</a></p><p><a href="https://coolshell.cn/articles/9703.html">https://coolshell.cn/articles/9703.html</a></p><p><a href="https://coolshell.cn/articles/9169.html">并发框架DISRUPTOR译文</a></p>]]></content>
      
      
      <categories>
          
          <category> lock free </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lock free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-innodb</title>
      <link href="/mysql-innodb/"/>
      <url>/mysql-innodb/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><ol><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>缓冲组件</li><li>插件式存储引擎</li><li>物理文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/mysql-arch.jpg" alt="mysql体系结构"></p><h3 id="InnoDB特点概述"><a href="#InnoDB特点概述" class="headerlink" title="InnoDB特点概述"></a>InnoDB特点概述</h3><ol><li>主要面向<code>OLTP</code></li><li>通过使用<code>MVCC</code>来获得高并发性, 提供一致性非锁定读, 并实现了<code>SQL</code>标准的4中隔离级别</li><li>支持行锁</li><li>使用<code>next-key locking</code>的策略来避免幻读(<code>phantom</code>)现象</li><li>提供了插入缓冲(<code>insert buffer</code>)、二次写(<code>double write</code>)、自适应哈希索引(<code>adptive hash index</code>)、预读(<code>read ahead</code>)等高性能和高可用功能</li></ol><h2 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h2><p>InnoDB线程:<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/innodb-arch.jpg" alt="InnoDB体系结构"><br>InnoDB内存:<br><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/innodb-mem.jpg" alt="InnoDB内存数据对象"></p><h3 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h3><h3 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h3><p>主要负责IO请求的回调处理, 有4类<code>IO Thread</code>:</p><ul><li><code>write</code>: 默认<code>innodb_write_io_threads = 4</code>, 即默认是4线程</li><li><code>read</code>: 默认<code>innodb_read_io_threads = 4</code></li><li><code>insert buffer thread</code></li><li><code>log IO thread</code></li></ul><h3 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h3><p>从<code>InnoDB 1.1 版本</code>开始, <code>purge</code>操作可以独立到单独的线程中进行。用于回收<code>undo</code>页。</p><h3 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h3><p>在<code>InnoDB 1.2版本</code>中引入的(之前在<code>Master Thread</code>中)。用于脏页的刷新操作。</p><h3 id="缓冲池-Buffer-Pool"><a href="#缓冲池-Buffer-Pool" class="headerlink" title="缓冲池(Buffer Pool)"></a>缓冲池(Buffer Pool)</h3><p>缓冲池的设计目的是为了协调CPU速度与磁盘速度的鸿沟。 </p><p>把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</p><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><ol><li>Buffer Pool中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是16KB</li><li>为了管理Pool中的缓存页，Innodb为每一个缓存页创建了一些所谓的控制信息。–控制信息也是写在页上面的。</li><li>控制信息包括该页所属的表空间编号、页号、缓存页在Buffer Pool中的地址、链表节点信息、一些锁信息以及LSN信息。</li><li>因为每个缓存页对应的控制信息占用的内存大小是相同的，因此从buffer pool中分配一块内存专门记录控制信息–控制块</li><li>控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边</li><li>控制块和缓存页之间是有碎片的–当然如果大小分配合理也有可能没有碎片。</li><li>每个控制块大约占用缓存页大小的5%,innodb_buffer_pool_size设置的大小并不包含控制块的大小，也就是说InnoDB在为Buffer Pool向操作系统申请连续的内存空间时，这片连续的内存空间一般会比innodb_buffer_pool_size的值大5%左右</li></ol><p><a href="https://gist.github.com/jboner/2841832">时延参考数据</a> :</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Latency Comparison Numbers (~2012)</span><br><span class="line">----------------------------------</span><br><span class="line">L1 cache reference                           0.5 ns</span><br><span class="line">Branch mispredict                            5   ns</span><br><span class="line">L2 cache reference                           7   ns                      14x L1 cache</span><br><span class="line">Mutex lock/unlock                           25   ns</span><br><span class="line">Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache</span><br><span class="line">Compress 1K bytes with Zippy             3,000   ns        3 us</span><br><span class="line">Send 1K bytes over 1 Gbps network       10,000   ns       10 us</span><br><span class="line">Read 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD</span><br><span class="line">Read 1 MB sequentially from memory     250,000   ns      250 us</span><br><span class="line">Round trip within same datacenter      500,000   ns      500 us</span><br><span class="line">Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory</span><br><span class="line">Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip</span><br><span class="line">Read 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">1 ns = 10^-9 seconds</span><br><span class="line">1 us = 10^-6 seconds = 1,000 ns</span><br><span class="line">1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</span><br></pre></td></tr></tbody></table></figure><h4 id="缓冲池对读写操作的关系"><a href="#缓冲池对读写操作的关系" class="headerlink" title="缓冲池对读写操作的关系"></a>缓冲池对读写操作的关系</h4><ul><li>读: 判断要读取的页是否在缓冲池中, 如果不在则会将页加载到缓冲池中, 然后再从缓冲池中读取。</li><li>写: 对于数据库中页的修改操作, 首先修改在缓冲池中的页, 然后再通过<code>CheckPoint</code>机制刷新回磁盘上。</li></ul><h4 id="缓冲池中的数据页类型"><a href="#缓冲池中的数据页类型" class="headerlink" title="缓冲池中的数据页类型"></a>缓冲池中的数据页类型</h4><ul><li>索引页</li><li>数据页</li><li>undo页</li><li>插入缓冲(<code>insert buffer</code>)</li><li>自适应哈希索引(<code>adaptive hash index</code>)</li><li>InnoDB存储的锁信息</li><li>数据字典信息(<code>data dictionary</code>)</li></ul><h4 id="LRU-List"><a href="#LRU-List" class="headerlink" title="LRU List"></a>LRU List</h4><p>InnoDB存储引擎中, 缓冲池中页的大小默认为16KB, 是通过使用LRU算法来进行管理的。</p><p>InnoDB存储引擎对传统的LRU算法做了<code>midpoint insertion strategy</code>优化, 不会直接插入到列表的头部, 而是会插入到<code>midpoint</code>位置。默认情况下该位置在LRU列表的5/8处(63%)。</p><p><code>midpoint insertion strategy</code> 可以防止热点数据被移出LRU列表。比如全表扫描的时候, 很可能新的页并不会频繁使用, 显然这些页替换调LRU的热点数据是不明智的。</p><h4 id="Free-List"><a href="#Free-List" class="headerlink" title="Free List"></a>Free List</h4><p><code>LRU List</code>新增节点的时候, 会先从<code>Free list</code>申请, 如果<code>Free list</code>里没有可用的空闲页, 那么<code>LRU list</code>将淘汰末尾的页, 然后将该也空间分配给新的页。</p><h4 id="Flush-List"><a href="#Flush-List" class="headerlink" title="Flush List"></a>Flush List</h4><p><code>LRU list</code>列表中的页被修改后, 这些脏页就会被维护到<code>Flush list</code>中, 数据库会根据<code>CheckPoint</code>机制将脏页刷新回磁盘。</p><h3 id="重做日志缓冲-redo-log-buffer"><a href="#重做日志缓冲-redo-log-buffer" class="headerlink" title="重做日志缓冲(redo log buffer)"></a>重做日志缓冲(redo log buffer)</h3><p>默认大小为<code>innodb_log_buffer_size = 838869</code>, 即 8MB。</p><p>通常情况下, 8MB足以满足大部分的应用。因为重做日志在下列三种情况会刷到外部磁盘的重做日志文件中:</p><ul><li>Master Thread每秒会将<code>redo log buffer</code>刷到 <code>redo log file</code>中</li><li>每个事物提交时会将<code>redo log buffer</code>刷到 <code>redo log file</code>中</li><li>当重做日志缓冲池剩余空间小于1/2时会将<code>redo log buffer</code>刷到 <code>redo log file</code>中</li></ul><h3 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h3><p>对一些数据结构本身的内存进行分配时, 需要重额外的内存池进行申请。例如缓冲池中的帧缓冲(<code>frame buffer</code>)还有缓冲控制对象(<code>buffer control block</code>)等。</p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p>InnoDB存储引擎内部, 有两种<code>Checkpoint</code>, 分别是<code>Sharp Checkpoint</code>, <code>Fuzzy Checkpoint</code>。<code>Checkpoint</code>技术的目的是解决一下几个问题:</p><ol><li>缩短数据库的恢复时间: 当数据库发生宕机时, 数据库不需要重做所有的日志, 只需对<code>Checkpoint</code>之后的重做日志进行恢复, 这样就大大缩短了恢复的时间。</li><li>缓冲池不够时, 将脏页刷新到磁盘: 当缓冲池不够用时, 根据LRU算法会淘汰掉一些页, 若淘汰的页为脏页, 那么需要强制执行<code>CheckPoint</code>, 将脏页刷回磁盘。</li><li>重做日志不可用时, 刷新脏页: 重做日志的空间是有限的, 是循环使用的。当被覆盖的时候, 需要强制执行<code>Checkpoint</code>将脏页刷新到磁盘。</li></ol><h4 id="Sharp-Checkpoint"><a href="#Sharp-Checkpoint" class="headerlink" title="Sharp Checkpoint"></a>Sharp Checkpoint</h4><p><code>Sharp Checkpoint</code>会将所有的脏页刷新回磁盘。发生在数据库关闭的时候。</p><h4 id="Fuzzy-Checkpoint"><a href="#Fuzzy-Checkpoint" class="headerlink" title="Fuzzy Checkpoint"></a>Fuzzy Checkpoint</h4><p>InnoDB存储引擎内部使用<code>Fuzzy Checkpoint</code>进行页的刷新, 即只刷新一部分脏页。分为以下几种情况:</p><ol><li>Master Thread Checkpoint: 在 <code>Master Thread</code> 的 <code>flush loop</code> 中, 每秒或每十秒触发。</li><li>FLUSH_LRU_LIST checkpoint: <code>Page Cleaner</code>线程会检查LRU列表中是否有足够的可用空闲页, 默认为<code>innodb_lru_scan_depth = 1024</code>。倘若如果没有1024个可用空闲页, 那么会将LRU列表尾端的页移除, 如果这些页中有脏页, 那么需要进行<code>Checkpoint</code></li><li>Async/Sync Flush Checkpoint: 当重做日志文件不可用的时候, 会触发。主要是为了保证重做日志的循环使用。</li><li>Dirty Page too much Checkpoint: 当脏页数太多的时候, 会导致InnoDB存储引擎强制进行<code>Checkpoint</code>. 默认是当超过<code>innodb_max_dirty_pages_pct = 75</code>的时候, 即脏页数量占据75%的时候, 会强制进行<code>Checkpoint</code></li></ol><h2 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h2><h3 id="插入缓冲-Insert-Buffer"><a href="#插入缓冲-Insert-Buffer" class="headerlink" title="插入缓冲(Insert Buffer)"></a>插入缓冲(Insert Buffer)</h3><p>目的: 为了提升辅助索引的插入性能</p><h4 id="插入缓冲的作用"><a href="#插入缓冲的作用" class="headerlink" title="插入缓冲的作用"></a>插入缓冲的作用</h4><p>辅助索引的插入是较为离散的, 为了避免更新辅助索引的时候要频繁地离散读取数据,<br>所以InnoDB存储引擎设计了<code>Insert Buffer</code>, 对于非聚集索引的插入或更新操作, 不是每次都直接插入到索引页中,<br>而是先判断插入的非聚集索引页是否在缓冲池中, 若存在, 则直接插入;<br>若不存在, 那么先放入到一个<code>Insert Buffer</code>对象中, 假装已经插入到叶子节点, 再以一定的频率合并(merge)到辅助索引叶子节点中。 </p><h4 id="插入缓冲的缺点"><a href="#插入缓冲的缺点" class="headerlink" title="插入缓冲的缺点"></a>插入缓冲的缺点</h4><ol><li>如果数据库发生了宕机, 有大量的<code>Insert Buffer</code>没有合并到实际的非聚集索引中去, 那么此时恢复可能需要很长的时间, 极端情况下甚至要几个小时。</li><li>在写密集的情况下, 插入缓冲会占用过多的缓冲池内存(innodb_buffer_pool), 默认最大可以占用到1/2的缓冲池内存。</li></ol><h4 id="使用插入缓冲需要满足的条件"><a href="#使用插入缓冲需要满足的条件" class="headerlink" title="使用插入缓冲需要满足的条件"></a>使用插入缓冲需要满足的条件</h4><p><code>Insert Buffer</code>的使用需要同时满足一下两个条件:</p><ul><li>索引是辅助索引(secondary index)</li><li>索引不是唯一(unique)的</li></ul><h4 id="唯一索引为什么不能使用插入缓冲"><a href="#唯一索引为什么不能使用插入缓冲" class="headerlink" title="唯一索引为什么不能使用插入缓冲"></a>唯一索引为什么不能使用插入缓冲</h4><p>为什么不能是唯一的? 如果要校验唯一性, 那么就还是需要进行读取加载对应的数据页才能进行判断。</p><h4 id="变更缓冲-Change-buffer"><a href="#变更缓冲-Change-buffer" class="headerlink" title="变更缓冲(Change buffer)"></a>变更缓冲(Change buffer)</h4><p>InnoDB从1.0.x版本开始引入了<code>Change Buffer</code>, 可以看做是<code>Insert Buffer</code>的升级版, 支持<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>。</p><p>InnoDB1.2.x版本开始可以通过参数<code>innodb_change_buffer_max_size</code>来控制<code>Change Buffer</code>最大使用内存的数量, 默认值为25, 表示最多使用1/4的缓冲池内存空间。</p><h4 id="Insert-Change-Buffer的实现"><a href="#Insert-Change-Buffer的实现" class="headerlink" title="Insert/Change Buffer的实现"></a>Insert/Change Buffer的实现</h4><p><code>Insert/Change Buffer</code>的数据结构是一颗<code>B+树</code>, 且全局只有一颗<code>Insert/Change Buffer B+树</code>。</p><h4 id="什么时候合并-Merge-Insert-Buffer"><a href="#什么时候合并-Merge-Insert-Buffer" class="headerlink" title="什么时候合并(Merge) Insert Buffer"></a>什么时候合并(Merge) Insert Buffer</h4><ul><li>辅助索引页被读取到缓冲池时: 例如在执行SELECT查询时, 此时需要将辅助索引页读取到缓冲池中, 此时需要检查<code>Insert Buffer Bitmap</code>页, 确认该索引是否有记录存放于<code>Insert Buffer B+树</code>中。如果有, 则将<code>Insert Buffer B+树</code>中的记录插入到该辅助索引页中。</li><li><code>Insert Buffer Bitmap</code> 页追踪到该辅助索引页已无可用空间时: <code>Insert Buffer Bitmap</code>里会记录可用空间, 若检测到插入记录后不够1/32页的剩余空间, 则会强制进行一次合并操作。</li><li><code>Master Thread</code>: 每秒或每10秒进行一次<code>Merge Insert Buffer</code>的操作。会随机地选择<code>Insert Buffer B+树</code>中连续的几页, 进行merge。</li></ul><h3 id="两次写-double-write"><a href="#两次写-double-write" class="headerlink" title="两次写(double write)"></a>两次写(double write)</h3><p>目的: 提供数据页的可靠性</p><p>可能某个16KB的页只写了前4KB时, 数据库发生了宕机, 这种情况被称为部分写失效(<code>partial page write</code>)。</p><h3 id="自适应哈希索引-Adaptive-Hash-Index-AHI"><a href="#自适应哈希索引-Adaptive-Hash-Index-AHI" class="headerlink" title="自适应哈希索引(Adaptive Hash Index, AHI)"></a>自适应哈希索引(Adaptive Hash Index, AHI)</h3><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><h3 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h3><h2 id="Mysql数据库的文件"><a href="#Mysql数据库的文件" class="headerlink" title="Mysql数据库的文件"></a>Mysql数据库的文件</h2><h2 id="InnoDB存储引擎表的文件"><a href="#InnoDB存储引擎表的文件" class="headerlink" title="InnoDB存储引擎表的文件"></a>InnoDB存储引擎表的文件</h2><h2 id="InnoDB存储引擎表的逻辑存储及实现"><a href="#InnoDB存储引擎表的逻辑存储及实现" class="headerlink" title="InnoDB存储引擎表的逻辑存储及实现"></a>InnoDB存储引擎表的逻辑存储及实现</h2><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h3><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="MySQL表级锁"><a href="#MySQL表级锁" class="headerlink" title="MySQL表级锁"></a>MySQL表级锁</h3><p><code>MySQL</code>里面表级别的锁有两种:</p><ol><li>表锁: InnoDB支持行锁, 所以一般不使用<code>lock tables</code>命令来控制并发。</li><li>元数据锁(meta data lock, MDL): 公平的读写锁。 不需要显示使用, 在访问一个表的时候会被自动加上。MDL的作用是保证读写的正确性, 防止查询的过程中表结构发生变更。</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="主从复制的步骤"><a href="#主从复制的步骤" class="headerlink" title="主从复制的步骤"></a>主从复制的步骤</h3><ol><li><code>master</code>把数据更改记录到<code>binlog</code>中</li><li><code>slave</code>把主服务器的<code>binlog</code>复制到自己的中继日志(<code>relay log</code>)中</li><li><code>slave</code>重做中继日志中的日志, 把更改应用到自己的数据库上, 以达到最终一致性。</li></ol><h3 id="主从复制工作原理"><a href="#主从复制工作原理" class="headerlink" title="主从复制工作原理"></a>主从复制工作原理</h3><ol><li><code>slave</code>的I/O线程负责读取<code>master</code>的<code>binlog</code>, 并将其保存为<code>relay log</code></li><li><code>slave</code>的SQL线程负责执行中继日志</li></ol><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/mysql-slave-binlog.jpg" alt="mysql主从复制"></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h3><ol><li>大量请求阻塞: 在高并发场景下，大量请求都需要操作数据库，导致连接数不够了，请求处于阻塞状态。</li><li>存储出现问题: 业务量剧增，单库数据量越来越大，给存储造成巨大压力。</li></ol><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>分表：是为了解决由于单张表数据量多大，而导致查询慢的问题。大致三、四千万行数据就得拆分，不过具体还是得看每一行的数据量大小，有些字段都很小的可能支持更多行数，有些字段大的可能一千万就顶不住了。</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>分库：是为了解决服务器资源受单机限制，顶不住高并发访问的问题，把请求分配到多台服务器上，降低服务器压力。</p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><h3 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h3><p>大众点评订单</p><p>通过UserId后四位mod 32分到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表</p><p>按2^n拆分(类比HashMap里的2^n。对比一下一致性哈希。)</p><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/sharding-hash-table.jpg" alt="查询切分-分库"><br>将ID和库的Mapping关系记录在一个单独的库中。</p><p>优点：ID和库的Mapping算法可以随意更改。<br>缺点：引入额外的单点。</p><h3 id="范围路由"><a href="#范围路由" class="headerlink" title="范围路由"></a>范围路由</h3><p>比如按照时间区间或ID区间来切分。</p><p>优点：单表大小可控，天然水平扩展。不需要做数据迁移<br>缺点：有热点问题, 一段时间的数据会集中到一张表上。无法解决集中写入瓶颈的问题。</p><h3 id="range-hash"><a href="#range-hash" class="headerlink" title="range+hash"></a>range+hash</h3><p>微信红包场景可用</p><p><img src="https://cdn.jsdelivr.net/gh/GoldArowana/static_source@main/post-content-pic/mysql/sharding-range-hash.jpg" alt="range+hash分库分表"></p><p>snowflake模式下要注意, 每毫秒第一个id要随机生成, 例如leaf, 否则hash分库会不均匀。</p><h3 id="分库分表带来的复杂性"><a href="#分库分表带来的复杂性" class="headerlink" title="分库分表带来的复杂性"></a>分库分表带来的复杂性</h3><h4 id="跨库关联查询"><a href="#跨库关联查询" class="headerlink" title="跨库关联查询"></a>跨库关联查询</h4><p>在单库未拆分表之前，我们可以很方便使用 join 操作关联多张表查询数据，但是经过分库分表后两张表可能都不在一个数据库中，如何使用 join 呢？</p><p>有几种方案可以解决：</p><ol><li>字段冗余：把需要关联的字段放入主表中，避免 join 操作；</li><li>数据抽象：通过ETL等将数据汇合聚集，生成新的表；</li><li>全局表：比如一些基础表可以在每个数据库中都放一份；</li><li>应用层组装：将基础数据查出来，通过应用程序计算组装；</li></ol><h4 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>单数据库可以用本地事务搞定，使用多数据库就只能通过分布式事务解决了。<br>常用解决方案有：基于可靠消息（MQ）的解决方案、两阶段事务提交、柔性事务等。</p><h4 id="排序、分页、函数计算问题"><a href="#排序、分页、函数计算问题" class="headerlink" title="排序、分页、函数计算问题"></a>排序、分页、函数计算问题</h4><p>在使用 SQL 时 order by， limit 等关键字需要特殊处理，一般来说采用分片的思路：</p><p>先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终得到结果。</p><h4 id="分布式-ID"><a href="#分布式-ID" class="headerlink" title="分布式 ID"></a>分布式 ID</h4><p>如果使用 Mysql 数据库在单库单表可以使用 id 自增作为主键，分库分表了之后就不行了，会出现id 重复。<br>常用的分布式 ID 解决方案有：</p><ol><li>UUID</li><li>基于数据库自增单独维护一张 ID表</li><li>号段模式</li><li>Redis</li><li>雪花算法（Snowflake）</li><li>百度uid-generator</li><li>美团Leaf</li><li>滴滴Tinyid</li></ol><h4 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h4><p>分库分表之后可能会面临从多个数据库或多个子表中获取数据，一般的解决思路有：客户端适配和代理层适配。<br>业界常用的中间件有：</p><ol><li>shardingsphere（前身 sharding-jdbc）</li><li>Mycat</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.youtube.com/watch?v=x5tqzyf0zrk&amp;list=PLSE8ODhjZXjbohkNBWQs_otTrBTrjyohi&amp;index=9">cmu讲lock/latch 例子比较详细</a></li><li><a href="https://www.zhihu.com/question/30272728">数据库事务原子性、一致性是怎样实现的？</a></li><li>《Mysql技术内幕 InnoDB存储引擎》</li><li><a href="https://www.cnblogs.com/geaozhang/p/7241744.html">InnoDB关键特性之double write</a></li><li><a href="https://juejin.cn/post/6890830002162499598">InnoDB 重要特性 Double Write 实现原理</a></li><li><a href="https://blog.csdn.net/synchronizing/article/details/109025093">mysql 为何需要Double Write？有redo log还不够吗？</a></li><li><a href="https://www.zhihu.com/question/59729819/answer/284180647">MySQL：数据库宕机以后恢复的过程？如何保证事务的ACID特性？</a></li><li><a href="https://blog.jcole.us/innodb/">On learning InnoDB: A journey to the core</a></li><li><a href="http://blog.itpub.net/15498/viewspace-2153760/">innodb_support_xa的作用</a></li><li><a href="https://www.cnblogs.com/AlmostWasteTime/p/10330151.html">MySQL学习（二）索引与锁</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL 8.0 Reference Manual-InnoDB Locking</a></li><li><a href="https://www.cnblogs.com/cchust/p/4255499.html">Innodb行锁源码学习(一)</a></li><li><a href="https://zhuanlan.zhihu.com/p/139489272">MySQL Innodb行锁剖析</a></li><li><a href="https://github.com/hedengcheng/tech/blob/master/database/MySQL/MySQL%20%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90.pdf">MySQL 加锁处理分析</a></li><li><a href="https://cloud.tencent.com/developer/article/1441250">分库分表？如何做到永不迁移数据和避免热点？</a></li><li><a href="http://mysql.taobao.org/monthly/2018/03/01/">MySQL · 源码分析 · InnoDB的read view，回滚段和purge过程简介</a></li><li><a href="https://blog.csdn.net/huangzhilin2015/article/details/115195777">MySQL总结–MVCC（read view和undo log）</a></li><li><a href="https://blog.csdn.net/qq_42651904/article/details/110622818">从ReadView深入理解MySql MVCC原理</a></li><li><a href="https://www.jianshu.com/p/8845ddca3b23">MVCC多版本并发控制</a></li><li><a href="https://blog.csdn.net/h2604396739/article/details/100280126">mysql Innodb_buffer_pool的原理</a></li><li><a href="https://www.jianshu.com/p/c53c8ab650b5">MySQL幻读</a></li><li><a href="https://mp.weixin.qq.com/s/850S0HZ5SlwSFuJK9BLgrw">InnoDB MVCC何时创建read view</a></li><li><a href="https://tech.meituan.com/2018/12/06/binlog-dw.html">美团DB数据同步到数据仓库的架构与实践</a></li><li><a href="https://www.jianshu.com/p/a053abfd52c4">面试题：我们为什么要分库分表？</a></li><li><a href="https://www.cnblogs.com/lizo/p/8035036.html">数据库分库分表事务解决方案</a></li><li><a href="https://tech.meituan.com/2016/12/19/mtddl.html">MTDDL——美团点评分布式数据访问层中间件</a></li><li><a href="https://zhuanlan.zhihu.com/p/24036067">大众点评订单系统分库分表实践</a></li><li><a href="http://blog.51yip.com/mysql/949.html">mysql分表的3种方法</a></li><li><a href="https://zhuanlan.zhihu.com/p/84224499">MySQL分库分表方案</a></li><li><a href="https://www.zhihu.com/question/459955079">在面试时被问到，为什么MySQL数据库数据量大了要进行分库分表？</a></li><li><a href="https://segmentfault.com/a/1190000023914691">数据库分库分表解决方案汇总</a></li><li><a href="https://zhuanlan.zhihu.com/p/355302417">MYSQL单表数据达2000万性能严重下降，为什么？</a></li><li><a href="https://crossoverjie.top/2019/04/16/framework-design/sharding-db/">一次分表踩坑实践的探讨</a></li><li><a href="https://crossoverjie.top/2019/06/13/framework-design/sharding-db-02/">分表后需要注意的二三事</a></li><li><a href="https://crossoverjie.top/2019/07/24/framework-design/sharding-db-03/">一次难得的分库分表实践</a></li><li><a href="https://www.infoq.cn/article/zmlcbpihothwjeqmzd4i">数据库分库分表基础和实践</a></li><li><a href="https://www.jianshu.com/p/7d8e2c02b07b">数据库分库分表思路 （1）（数据库分区、分表、分库、分片）</a></li><li><a href="https://www.kancloud.cn/digest/innodb-zerok">innodb源码分析</a></li><li><a href="https://www.kancloud.cn/digest/mysqlsummary/132848">Mysql数据库常用分库和分表方式</a></li><li><a href="https://mp.weixin.qq.com/s/1ZWOLPV4fCqi2EebU_C9YA">MySQL索引前世今生</a></li><li><a href="https://segmentfault.com/a/1190000014810628">MySQL 2PC &amp; Group Commit</a></li><li><a href="https://www.cnblogs.com/kismetv/p/10331633.html">深入学习MySQL事务：ACID特性的实现原理</a></li><li><a href="http://mysql.taobao.org/monthly/2015/05/01/">MySQL · 引擎特性 · InnoDB redo log漫游</a></li><li><a href="http://mysql.taobao.org/monthly/2015/04/01/">MySQL · 引擎特性 · InnoDB undo log 漫游</a></li><li><a href="http://mysql.taobao.org/monthly/2015/06/01/">MySQL · 引擎特性 · InnoDB 崩溃恢复过程</a></li></ol><p><a href="https://zhuanlan.zhihu.com/p/341317422">https://zhuanlan.zhihu.com/p/341317422</a></p><p><a href="https://zhuanlan.zhihu.com/p/343226202">https://zhuanlan.zhihu.com/p/343226202</a></p><p><a href="http://kernelmaker.github.io/InnoDB_redo_log">http://kernelmaker.github.io/InnoDB_redo_log</a></p><p><a href="http://mysql.taobao.org/monthly/">http://mysql.taobao.org/monthly/</a></p><p><a href="https://toutiao.io/posts/2cvy58/preview">https://toutiao.io/posts/2cvy58/preview</a></p><p><a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html">https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
            <tag> innodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>raft协议</title>
      <link href="/raft/"/>
      <url>/raft/</url>
      
        <content type="html"><![CDATA[<h2 id="Raft简介"><a href="#Raft简介" class="headerlink" title="Raft简介"></a>Raft简介</h2><p>复制日志问题: 是复制状态机的一种抽象, 把具有一定顺序的一系列action抽象成一条日志(log), 每个action都是日志中的一个条目(entry)。<br>如果想让每个节点的服务状态相同, 则要把日志中的所有entry按照记录顺序执行一遍。<br>所以复制状态机的核心问题就变成了让每个节点都具有相同的日志的问题, 也就是把日志复制到每个节点上的问题。</p><h3 id="组成成员"><a href="#组成成员" class="headerlink" title="组成成员"></a>组成成员</h3><ul><li>leader</li><li>follower</li></ul><h2 id="Raft三大部分"><a href="#Raft三大部分" class="headerlink" title="Raft三大部分"></a>Raft三大部分</h2><h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><h4 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h4><p>任期主要解决一下两个问题</p><p>问题1: 所有follower同事开始争leader。<br>问题2: 脑裂。</p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><ol><li>leader收到客户端请求后, 将entry记录追加到末尾(append操作, 即插入到当前index处)。每追加一个entry, index就会加1。</li><li>leader之后会向所有follower发送AppendEntries请求。</li><li>leader收到大多数follower的成功请求后, 这个entry就被leader认为达到提交状态了。leader将这个entry应用到状态机中。</li></ol><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h4 id="一致性检查"><a href="#一致性检查" class="headerlink" title="一致性检查"></a>一致性检查</h4><h4 id="不提交旧的leader的entry"><a href="#不提交旧的leader的entry" class="headerlink" title="不提交旧的leader的entry"></a>不提交旧的leader的entry</h4><h3 id="角色改变"><a href="#角色改变" class="headerlink" title="角色改变"></a>角色改变</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">寻找一种易于理解的一致性算法（扩展版）</a></li><li><a href="https://talkgo.org/t/topic/51">go夜读-etcd raft 源码阅读</a></li><li><a href="https://talkgo.org/t/topic/882">go夜读-通过 hashicorp/raft 库手把手调试 raft 算法</a></li><li><a href="https://zhuanlan.zhihu.com/p/55070003">对Raft的理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/42239873">线性一致性：什么是线性一致性？</a></li></ol><p><a href="https://www.luozhiyun.com/archives/287">https://www.luozhiyun.com/archives/287</a></p><p><a href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a></p><p><a href="https://disksing.com/even-node-raft/">https://disksing.com/even-node-raft/</a></p><p><a href="https://www.youtube.com/watch?v=UzzcUS2OHqo">https://www.youtube.com/watch?v=UzzcUS2OHqo</a></p><p><a href="https://www.youtube.com/watch?v=64Zp3tzNbpE">https://www.youtube.com/watch?v=64Zp3tzNbpE</a></p><p><a href="https://www.youtube.com/watch?v=4r8Mz3MMivY">https://www.youtube.com/watch?v=4r8Mz3MMivY</a></p><p><a href="https://www.cnblogs.com/linbingdong/p/6442673.html">https://www.cnblogs.com/linbingdong/p/6442673.html</a></p><p><a href="https://www.youtube.com/watch?v=fcFqFfsAlSQ">https://www.youtube.com/watch?v=fcFqFfsAlSQ</a></p><p><a href="https://zhuanlan.zhihu.com/p/262192992">https://zhuanlan.zhihu.com/p/262192992</a></p><p><a href="https://www.youtube.com/watch?v=g4epAvtzDYA">https://www.youtube.com/watch?v=g4epAvtzDYA</a></p><p><a href="https://github.com/wenweihu86/raft-java">https://github.com/wenweihu86/raft-java</a></p><p><a href="https://mendylee.gitbooks.io/geeker-study-courses/content/fen-bu-shi-jia-gou-jing-dian-tu-shu-he-lun-wen-ff08-fen-bu-shi-jia-gou-ff09.html">https://mendylee.gitbooks.io/geeker-study-courses/content/fen-bu-shi-jia-gou-jing-dian-tu-shu-he-lun-wen-ff08-fen-bu-shi-jia-gou-ff09.html</a></p><p><a href="https://draveness.me/consensus/">https://draveness.me/consensus/</a></p><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>]]></content>
      
      
      <categories>
          
          <category> distribute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> consistency </tag>
            
            <tag> distribute </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paxos协议</title>
      <link href="/paxos/"/>
      <url>/paxos/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h2><h3 id="基本角色"><a href="#基本角色" class="headerlink" title="基本角色"></a>基本角色</h3><ul><li>proposer</li><li>acceptor</li><li>learner</li></ul><h3 id="提议编号"><a href="#提议编号" class="headerlink" title="提议编号"></a>提议编号</h3><p>每个提议都包含一个提议编号, 并且这个提议编号是唯一且递增的。</p><p>这里提供一种参考思路: 每个进行都会分配一个唯一的进程标识(processid, 32位), 每个进程都维护一个计数器(counter, 32位)。那么提议编号可以设计为 counter&lt;&lt;32 + processid</p><h3 id="选择提案"><a href="#选择提案" class="headerlink" title="选择提案"></a>选择提案</h3><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><h3 id="学习值"><a href="#学习值" class="headerlink" title="学习值"></a>学习值</h3><h3 id="distinguished-learner"><a href="#distinguished-learner" class="headerlink" title="distinguished learner"></a>distinguished learner</h3><h2 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h2><h3 id="独立实例运行的完整paxos算法"><a href="#独立实例运行的完整paxos算法" class="headerlink" title="独立实例运行的完整paxos算法"></a>独立实例运行的完整paxos算法</h3><h4 id="脑裂处理"><a href="#脑裂处理" class="headerlink" title="脑裂处理"></a>脑裂处理</h4><h4 id="空洞处理"><a href="#空洞处理" class="headerlink" title="空洞处理"></a>空洞处理</h4><h3 id="只运行一次prepare消息的完整paxos算法"><a href="#只运行一次prepare消息的完整paxos算法" class="headerlink" title="只运行一次prepare消息的完整paxos算法"></a>只运行一次prepare消息的完整paxos算法</h3><h4 id="脑裂处理-1"><a href="#脑裂处理-1" class="headerlink" title="脑裂处理"></a>脑裂处理</h4><h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><h3 id="空洞处理-1"><a href="#空洞处理-1" class="headerlink" title="空洞处理"></a>空洞处理</h3><h2 id="原子广播"><a href="#原子广播" class="headerlink" title="原子广播"></a>原子广播</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://duanple.com/?p=174">拜占庭将军问题</a></li><li><a href="https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">The Part-Time Parliament</a></li><li><a href="https://blog.csdn.net/zhaoshouyue/article/details/92787920">Paxos算法《The Part-Time Parliament》译文</a></li><li><a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">Paxos Made Simple</a></li><li><a href="https://www.jianshu.com/p/67dd80555ba2">Paxos Made Simple 译文</a></li><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf">Fast Paxos</a></li></ol><p><a href="https://zhuanlan.zhihu.com/p/343225569">https://zhuanlan.zhihu.com/p/343225569</a></p><p><a href="https://disksing.com/paxos/">https://disksing.com/paxos/</a></p><p><a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">https://lamport.azurewebsites.net/pubs/paxos-simple.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/343225836">https://zhuanlan.zhihu.com/p/343225836</a></p><p><a href="http://www.read.seas.harvard.edu/~kohler/class/08w-dsi/chandra07paxos.pdf">http://www.read.seas.harvard.edu/~kohler/class/08w-dsi/chandra07paxos.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/343226028">https://zhuanlan.zhihu.com/p/343226028</a></p><p><a href="https://zhuanlan.zhihu.com/p/343225670">https://zhuanlan.zhihu.com/p/343225670</a></p><p><a href="https://zhuanlan.zhihu.com/p/343225248">https://zhuanlan.zhihu.com/p/343225248</a></p><p><a href="http://duanple.com/?p=164">http://duanple.com/?p=164</a></p><p><a href="http://linbingdong.com/2017/11/21/PhxPaxos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/">http://linbingdong.com/2017/11/21/PhxPaxos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</a></p><p><a href="https://www.cnblogs.com/linbingdong/p/6253479.html">https://www.cnblogs.com/linbingdong/p/6253479.html</a></p><p><a href="https://www.zhihu.com/question/19787937">https://www.zhihu.com/question/19787937</a></p><p><a href="https://www.youtube.com/watch?v=JEpsBg0AO6o">https://www.youtube.com/watch?v=JEpsBg0AO6o</a></p><p><a href="https://www.youtube.com/watch?v=d7nAGI_NZPk">https://www.youtube.com/watch?v=d7nAGI_NZPk</a></p><p><a href="https://www.youtube.com/watch?v=fcFqFfsAlSQ">https://www.youtube.com/watch?v=fcFqFfsAlSQ</a></p><p><a href="https://www.youtube.com/watch?v=-Bl5GleEN5s">https://www.youtube.com/watch?v=-Bl5GleEN5s</a></p><p><a href="https://www.youtube.com/watch?v=uBQSE4MMWhY">https://www.youtube.com/watch?v=uBQSE4MMWhY</a></p><p><a href="https://www.youtube.com/watch?v=JEpsBg0AO6o">https://www.youtube.com/watch?v=JEpsBg0AO6o</a></p><p><a href="https://www.youtube.com/playlist?list=PLkLazW-A4v3KEuYn-rW_19OEnPmn0Gq3v">https://www.youtube.com/playlist?list=PLkLazW-A4v3KEuYn-rW_19OEnPmn0Gq3v</a></p><p><a href="https://www.youtube.com/watch?v=bkWL4mtiVbs">https://www.youtube.com/watch?v=bkWL4mtiVbs</a></p><p><a href="https://www.youtube.com/watch?v=vmwnhZmEZjc">https://www.youtube.com/watch?v=vmwnhZmEZjc</a></p><p><a href="https://blog.openacid.com/algo/paxos/">https://blog.openacid.com/algo/paxos/</a></p><p><a href="https://drmingdrmer.github.io/algo/2020/10/18/quorum.html">https://drmingdrmer.github.io/algo/2020/10/18/quorum.html</a></p><p><a href="https://github.com/kr/paxos">https://github.com/kr/paxos</a></p><p><a href="https://github.com/openacid/paxoskv">https://github.com/openacid/paxoskv</a></p><p><a href="https://lrita.github.io/2018/10/23/safety-and-liveness-in-distributed/">https://lrita.github.io/2018/10/23/safety-and-liveness-in-distributed/</a></p><p><a href="https://zhuanlan.zhihu.com/p/21438357?refer=lynncui">https://zhuanlan.zhihu.com/p/21438357?refer=lynncui</a></p><p><a href="https://zhuanlan.zhihu.com/p/21466932">https://zhuanlan.zhihu.com/p/21466932</a></p><p><a href="http://oceanbase.org.cn/?p=90">http://oceanbase.org.cn/?p=90</a></p><p><a href="http://oceanbase.org.cn/?p=111">http://oceanbase.org.cn/?p=111</a></p><p><a href="http://oceanbase.org.cn/?p=160">http://oceanbase.org.cn/?p=160</a></p><p><a href="http://oceanbase.org.cn/?p=136">http://oceanbase.org.cn/?p=136</a></p><p><a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)#Multi-Paxos">https://en.wikipedia.org/wiki/Paxos_(computer_science)#Multi-Paxos</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDg2NjIyMA==&amp;mid=203607654&amp;idx=1&amp;sn=bfe71374fbca7ec5adf31bd3500ab95a&amp;key=8ea74966bf01cfb6684dc066454e04bb5194d780db67f87b55480b52800238c2dfae323218ee8645f0c094e607ea7e6f&amp;ascene=1&amp;uin=MjA1MDk3Njk1&amp;devicetype=webwx&amp;version=70000001&amp;pass_ticket=2ivcW/cENyzkz/GjIaPDdMzzf+berd36/R3FYecikmo=">https://mp.weixin.qq.com/s?__biz=MjM5MDg2NjIyMA==&amp;mid=203607654&amp;idx=1&amp;sn=bfe71374fbca7ec5adf31bd3500ab95a&amp;key=8ea74966bf01cfb6684dc066454e04bb5194d780db67f87b55480b52800238c2dfae323218ee8645f0c094e607ea7e6f&amp;ascene=1&amp;uin=MjA1MDk3Njk1&amp;devicetype=webwx&amp;version=70000001&amp;pass_ticket=2ivcW%2FcENyzkz%2FGjIaPDdMzzf%2Bberd36%2FR3FYecikmo%3D</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=403582309&amp;idx=1&amp;sn=80c006f4e84a8af35dc8e9654f018ace&amp;scene=1&amp;srcid=0119gtt2MOru0Jz4DHA3Rzqy&amp;key=710a5d99946419d927f6d5cd845dc9a72ff3d652a8e66f0ddf87d91262fd262f61f63660690d2d5da76a44a29e155610&amp;ascene=0&amp;uin=MjA1MDk3Njk1&amp;devicetype=iMac+MacBookPro11,4+OSX+OSX+10.11.1+build(15B42)&amp;version=11020201&amp;pass_ticket=bhstP11nRHvorVXvQ4pt9fzB9Vdzj5sSRBe84783gsg=">https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=403582309&amp;idx=1&amp;sn=80c006f4e84a8af35dc8e9654f018ace&amp;scene=1&amp;srcid=0119gtt2MOru0Jz4DHA3Rzqy&amp;key=710a5d99946419d927f6d5cd845dc9a72ff3d652a8e66f0ddf87d91262fd262f61f63660690d2d5da76a44a29e155610&amp;ascene=0&amp;uin=MjA1MDk3Njk1&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42)&amp;version=11020201&amp;pass_ticket=bhstP11nRHvorVXvQ4pt9fzB9Vdzj5sSRBe84783gsg%3D</a></p><p><a href="https://github.com/hedengcheng/tech/blob/master/distributed/PaxosRaft%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E5%8F%8A%E5%85%B6%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.pdf">https://github.com/hedengcheng/tech/blob/master/distributed/PaxosRaft%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E5%8F%8A%E5%85%B6%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.pdf</a></p><p><a href="https://github.com/oldratlee/translations/tree/master/paxoslease">https://github.com/oldratlee/translations/tree/master/paxoslease</a></p><p><a href="https://github.com/oldratlee/translations/tree/master/paxos-made-simple">https://github.com/oldratlee/translations/tree/master/paxos-made-simple</a></p>]]></content>
      
      
      <categories>
          
          <category> distribute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paxos </tag>
            
            <tag> consistency </tag>
            
            <tag> distribute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用工具</title>
      <link href="/tools/"/>
      <url>/tools/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xargin.com/diagram-tools-intro/">https://xargin.com/diagram-tools-intro/</a></p><p><a href="https://coolors.co/palettes/trending">https://coolors.co/palettes/trending</a></p><p><a href="https://draveness.me/sketch-and-sketch/">https://draveness.me/sketch-and-sketch/</a></p><p>youtube开启双语字幕: <a href="https://github.com/ADengrc/youtube-captions">https://github.com/ADengrc/youtube-captions</a></p><p><a href="https://blog.sky03.cn/posts/4873.html#toc-heading-6">https://blog.sky03.cn/posts/4873.html#toc-heading-6</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java原子类cas的实现原理</title>
      <link href="/java-atomic-cas/"/>
      <url>/java-atomic-cas/</url>
      
        <content type="html"><![CDATA[<h2 id="cas简介"><a href="#cas简介" class="headerlink" title="cas简介"></a>cas简介</h2><h3 id="cas是什么"><a href="#cas是什么" class="headerlink" title="cas是什么"></a>cas是什么</h3><blockquote><p>CAS(compare and swap)，比较和交换，是原子操作的一种，<br>可用于在多线程编程中实现不被打断的数据交换操作，<br>从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。<br>该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。<br>现代的大多数CPU都实现了CAS,它是一种无锁(lock-free),且非阻塞的一种算法，保持数据的一致性。</p></blockquote><h3 id="cas能干什么"><a href="#cas能干什么" class="headerlink" title="cas能干什么"></a>cas能干什么</h3><p>它可以用于解决多线程并发安全的问题。比如多线程修改一个变量, 进行自增操作时, 由于线程的工作线程写回主存时会有覆盖问题, 就像是’丢失了几次写操作’一样。</p><p>(线程工作内存和主存等相关问题请查阅JMM, 这里不再过多描述)</p><p>这里就是一个多线程同时修改counter的<strong>错误</strong>使用方式:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongCounter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">function</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">                System.out.println(counter++);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(function).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.printf(<span class="string">"final counter: %d \n"</span>, counter);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*  output:</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">3990</span></span><br><span class="line"><span class="comment">3991</span></span><br><span class="line"><span class="comment">3992</span></span><br><span class="line"><span class="comment">3993</span></span><br><span class="line"><span class="comment">3994</span></span><br><span class="line"><span class="comment">final counter: 3995 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><p>最终会看到counter只加到了3995, 而没有加到预期的4000</p><h3 id="使用cas完成计数案例"><a href="#使用cas完成计数案例" class="headerlink" title="使用cas完成计数案例"></a>使用cas完成计数案例</h3><p>我们把上面的错误案例修改一下, 借助atomic类的cas的来完成多线程计数功能:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterCAS</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">var</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">function</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">                <span class="type">var</span> <span class="variable">current</span> <span class="operator">=</span> counter.getAndIncrement();</span><br><span class="line">                System.out.println(current);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(function).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.printf(<span class="string">"final counter: %d \n"</span>, counter.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    3996</span></span><br><span class="line"><span class="comment">    3997</span></span><br><span class="line"><span class="comment">    3998</span></span><br><span class="line"><span class="comment">    3999</span></span><br><span class="line"><span class="comment">    final counter: 4000 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到最终输出的是4000, 复合我们的预期。</p><h3 id="cas的优点"><a href="#cas的优点" class="headerlink" title="cas的优点"></a>cas的优点</h3><ol><li>线程安全</li><li>乐观锁思想, 不用抢锁。没有竞争到的线程也不用挂起/切换上下文。低并发的时候有很好的表现</li></ol><h3 id="cas的缺点"><a href="#cas的缺点" class="headerlink" title="cas的缺点"></a>cas的缺点</h3><ol><li>不适用于高并发场景, 会造成过多的自旋, 使cpu空转</li><li>会产生ABA问题</li></ol><h2 id="Atomic类的getAndIncrement-的实现原理"><a href="#Atomic类的getAndIncrement-的实现原理" class="headerlink" title="Atomic类的getAndIncrement()的实现原理"></a>Atomic类的getAndIncrement()的实现原理</h2><p>在 <code>java.util.concurrent.atomic.AtomicInteger</code> 里getAndIncrement()方法实现如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span></span><br><span class="line">    <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments the current value,</span></span><br><span class="line"><span class="comment"> * with memory effects as specified by {<span class="doctag">@link</span> VarHandle#getAndAdd}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Equivalent to {<span class="doctag">@code</span> getAndAdd(1)}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发现是调用了jdk.internal.misc.Unsafe.getAndAddInt()方法实现的。参数是this, VALUE, 还有1。</p><p>其中1很好理解, 就是让计数器counter的值每次自增1的意思。</p><p>VALUE可以理解为value变量在AtomicInteger对象里的偏移量, 可以通过this+VALUE来定位到value这个变量, 以便直接对内存进行操作。</p><p>getAndAddInt()方法内部实现如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> {</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    } <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">getIntVolatile</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">weakCompareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> expected,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> expected,</span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> x)</span>;</span><br></pre></td></tr></tbody></table></figure><p>其中的<code>o</code>就是刚才传入的 AtomicInteger对象的<code>this</code>。<br>其中的<code>weakCompareAndSetInt</code>最终是调用的native方法<code>compareAndSetInt</code>。</p><p>发现里面的逻辑很简单, 就是一个do-while循环:<br>通过<code>this和offset</code>从内存里拿到了当前的value值, 记为<code>v</code>。<br>然后通过while循环不断地调用<code>compareAndSetInt</code>, 尝试进行<strong>比较再替换</strong>。</p><h2 id="cas-的实现原理"><a href="#cas-的实现原理" class="headerlink" title="cas 的实现原理"></a>cas 的实现原理</h2><h2 id="cas的源码探索之旅-java-c-汇编"><a href="#cas的源码探索之旅-java-c-汇编" class="headerlink" title="cas的源码探索之旅(java -> c++ -> 汇编)"></a>cas的源码探索之旅(java -&gt; c++ -&gt; 汇编)</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/zhoufanyang_china/article/details/89488959">【并发编程】CAS与FAA</a></li><li><a href="https://en.wikipedia.org/wiki/Double_compare-and-swap">Double compare-and-swap</a></li><li><a href="https://cloud.tencent.com/developer/article/1634000">x86系统cache locking的原理</a></li></ol><p><a href="https://coolshell.cn/articles/11454.html">https://coolshell.cn/articles/11454.html</a></p><p><a href="https://blog.csdn.net/qq_35642036/article/details/82801708">https://blog.csdn.net/qq_35642036/article/details/82801708</a></p><p><a href="https://albk.tech/%E8%81%8A%E8%81%8ACPU%E7%9A%84LOCK%E6%8C%87%E4%BB%A4.html">https://albk.tech/%E8%81%8A%E8%81%8ACPU%E7%9A%84LOCK%E6%8C%87%E4%BB%A4.html</a></p><p><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf">https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf</a></p><p><a href="https://www.zhihu.com/question/65372648">https://www.zhihu.com/question/65372648</a></p><p><a href="https://hjlarry.github.io/docs/go/lock/">https://hjlarry.github.io/docs/go/lock/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> atomic </tag>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据面试问题</title>
      <link href="/big-data-questions/"/>
      <url>/big-data-questions/</url>
      
        <content type="html"><![CDATA[<h2 id="一、黑名单网页过滤"><a href="#一、黑名单网页过滤" class="headerlink" title="一、黑名单网页过滤"></a>一、黑名单网页过滤</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实通过判断网页url是否在黑名单里, 现一个黑名单网页过滤系统。<br>每个网页的url最多占用64B。</p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ol><li>允许有万分之一以下的判断失误率。</li><li>使用的额外空间不要超过30GB</li></ol><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h4 id="思路1-哈希表-不可行"><a href="#思路1-哈希表-不可行" class="headerlink" title="思路1: 哈希表(不可行)"></a>思路1: 哈希表(不可行)</h4><p>如果通过哈希表保存, 那么64B * 100亿 &gt; 640GB, 显然不符合要求。</p><h4 id="思路2-布隆过滤器"><a href="#思路2-布隆过滤器" class="headerlink" title="思路2: 布隆过滤器"></a>思路2: 布隆过滤器</h4><p>可以使用布隆过滤器。</p><h2 id="二、在20亿个整数中找到出现次数最多的数"><a href="#二、在20亿个整数中找到出现次数最多的数" class="headerlink" title="二、在20亿个整数中找到出现次数最多的数"></a>二、在20亿个整数中找到出现次数最多的数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一个包含20亿个全是32位整数的大文件, 在其中找到出现次数最多的数。</p><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ol><li>内存限制为2GB</li></ol><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><h4 id="思路1-直接使用哈希表-不可行"><a href="#思路1-直接使用哈希表-不可行" class="headerlink" title="思路1: 直接使用哈希表(不可行)"></a>思路1: 直接使用哈希表(不可行)</h4><p>如果用哈希表做词频统计, key需要占用4B, value需要占用4B,  那么可能最多需要的空间是: (4B+4B) * 20亿 &gt; 16GB, 显然这种方法不满足要求</p><h4 id="思路2-分片后使用哈希表"><a href="#思路2-分片后使用哈希表" class="headerlink" title="思路2: 分片后使用哈希表"></a>思路2: 分片后使用哈希表</h4><p>可以通过哈希函数, 将20亿个数分成16个小文件。每个小文件对应的数不会大于2亿种, 用哈希表计算2亿种数的词频大约需要1.6GB内存。<br>接下来只需要选出这16个小文件各自的最高词频即可。</p><h2 id="三、40亿个非负整数中找到未出现的数"><a href="#三、40亿个非负整数中找到未出现的数" class="headerlink" title="三、40亿个非负整数中找到未出现的数"></a>三、40亿个非负整数中找到未出现的数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 请在一个有40亿个无符号整数的文件中, 找出未出现过的数。</p><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用1GB内存</li></ol><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><h4 id="思路1-直接使用哈希表-不可行-1"><a href="#思路1-直接使用哈希表-不可行-1" class="headerlink" title="思路1: 直接使用哈希表(不可行)"></a>思路1: 直接使用哈希表(不可行)</h4><p>如果直接使用哈希表, 那么需要使用内存: 4B * 40亿 ≈ 16GB, 显然是不满足条件的。</p><h4 id="思路2-bitmap"><a href="#思路2-bitmap" class="headerlink" title="思路2: bitmap"></a>思路2: bitmap</h4><p>4294967295个bit数组占用500MB空间, 可以解决这个问题。</p><h2 id="四、在40亿个非负整数中找出1个未出现过的数"><a href="#四、在40亿个非负整数中找出1个未出现过的数" class="headerlink" title="四、在40亿个非负整数中找出1个未出现过的数"></a>四、在40亿个非负整数中找出1个未出现过的数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 请在一个有40亿个无符号整数的文件中, 找出1个未出现过的数</p><h3 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用10MB内存</li></ol><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><h4 id="思路-分片统计-然后用bitmap"><a href="#思路-分片统计-然后用bitmap" class="headerlink" title="思路: 分片统计, 然后用bitmap"></a>思路: 分片统计, 然后用bitmap</h4><p>将0 ~ 4294967295划分为64个区间, 统计每个区间的数字种类。如果哪个区间的总数不到 (4294967296/64)个, 那么说明在这个区间可以找出未出现过的数。<br>在对应的区间内使用bitset寻找未出现的数, 4294967296/64 = 67108864 bit ≈ 8MB</p><h2 id="五、40亿个非负整数中找到出现两次的数"><a href="#五、40亿个非负整数中找到出现两次的数" class="headerlink" title="五、40亿个非负整数中找到出现两次的数"></a>五、40亿个非负整数中找到出现两次的数</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 现在有40亿个无符号整数, 找出所有出现了2次的数。 </p><h3 id="要求-4"><a href="#要求-4" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用1GB的内存</li></ol><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><h4 id="思路-bitmap变种"><a href="#思路-bitmap变种" class="headerlink" title="思路: bitmap变种"></a>思路: bitmap变种</h4><p>普通的bitmap值只有0和1, 在这道题下, 我们让bitmap的值支持0~3。所以申请的空间是4294967295 * 2bit = 1GB。<br>遍历所有文件, bitmap值为0表示未出现过, 1表示出现过1次, 2表示出现过2次, 3表示出现次数多于2次。</p><h2 id="六、40亿个非负整数中找到中位数"><a href="#六、40亿个非负整数中找到中位数" class="headerlink" title="六、40亿个非负整数中找到中位数"></a>六、40亿个非负整数中找到中位数</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>32位无符号整数的范围是 0 ~ 4294967295, 现在有40亿个无符号整数, 找出中位数。</p><h3 id="要求-5"><a href="#要求-5" class="headerlink" title="要求"></a>要求</h3><ol><li>最多使用10MB的内存</li></ol><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><h4 id="思路-文件分流"><a href="#思路-文件分流" class="headerlink" title="思路: 文件分流"></a>思路: 文件分流</h4><p>(2 * 1000 * 1000) * 32bit ≈ 8MB , 所以我们将每 2000000 个数字划为一个区间。<br>4294967296/ 2000000 向上取整为2148个区间。<br>遍历一遍文件, 统计每个区间的总词频。<br>之后可以定位到中位数在具体的一个区间内, 再次遍历文件, 不在这个区间的数字忽略不计, 统计这个区间的每个数的词频, 找出中位数。</p><p><a href="https://www.sohu.com/a/138204769_236714">大数据求职必看：经典的大数据面试问题 )</a><br><a href="">程序员代码面试指南 第6章</a></p><p><a href="http://duanple.com/?p=289">http://duanple.com/?p=289</a></p>]]></content>
      
      
      <categories>
          
          <category> big data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> big data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protobuf基础知识</title>
      <link href="/protobuf/"/>
      <url>/protobuf/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote><p>Protocol Buffer是Google提供的跨语言、跨平台的二进制序列化方案，可用于数据存储、数据交换等场景，扩展性非常高。</p></blockquote><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="varint"><a href="#varint" class="headerlink" title="varint"></a>varint</h3><h3 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h3><blockquote><p><code>zigzag</code>编码的出现是为了解决<code>varint</code>对负数编码效率低的问题。<code>zigzag</code>编码的原理非常简单，就是将有符号整数映射为无符号整数。在实现上，映射通过移位即可实现，而不需要使用映射表来存储。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li>《深入理解序列化与反序列化》</li><li><a href="https://segmentfault.com/a/1190000020500985?utm_source=tag-newest">详解varint编码原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> distribute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> distribute </tag>
            
            <tag> protobuf </tag>
            
            <tag> rpc </tag>
            
            <tag> grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问google.com的时候都发生了什么</title>
      <link href="/what-happens-when-browse-google-com/"/>
      <url>/what-happens-when-browse-google-com/</url>
      
        <content type="html"><![CDATA[<h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><h2 id="ISO-7层网络模型"><a href="#ISO-7层网络模型" class="headerlink" title="ISO 7层网络模型"></a>ISO 7层网络模型</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>网络服务与最终用户的一个接口。<br>协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）<br>格式有，JPEG、ASCll、EBCDIC、加密格式等</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）<br>对应主机进程，指本地主机与远程主机正在进行的会话</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>定义传输数据的协议端口号，以及流控和差错校验。<br>协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>进行逻辑地址寻址，实现不同网络之间的路径选择。<br>协议有：ICMP IGMP IP（IPV4 IPV6）</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>建立逻辑连接、进行硬件地址寻址、差错校验 等功能。（由底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>建立、维护、断开物理连接。（由底层网络定义协议）</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.zhihu.com/question/21546408">有了 IP 地址，为什么还要用 MAC 地址？</a></li></ol><p><a href="https://draveness.me/whys-the-design-non-unique-mac-address/">https://draveness.me/whys-the-design-non-unique-mac-address/</a></p><p><a href="https://draveness.me/whys-the-design-ipv6-replacing-ipv4/">https://draveness.me/whys-the-design-ipv6-replacing-ipv4/</a></p>]]></content>
      
      
      <categories>
          
          <category> internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年学习计划</title>
      <link href="/leaning-plan-for-2021/"/>
      <url>/leaning-plan-for-2021/</url>
      
        <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol><li>JMM ✅</li></ol><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ol><li>内存管理 ✅</li><li>GMP ✅</li><li>GC ✅</li><li>并发 ✅</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol><li>阅读网络是怎样连接的, 下半本书, 并整理出笔记 ✅</li><li>tcp ✅</li><li>selector, poll, epoll</li><li>MQTT</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>1。 刷20道leetcode ✅</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ol><li>集群 ✅</li><li>哨兵 ✅</li><li>源码</li><li>hyperloglog ✅</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li>b树、b+树 ✅</li><li>事务 ✅</li><li>MVCC ✅</li><li>了解newSQL, TiDB, TiKV, boltdb, leveldb, rockdb ✅</li><li>sstable, lsm, tsm ✅</li><li>ES倒排索引</li></ol><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><ol><li>kafka基本原理 ✅</li></ol><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol><li>面向对象</li><li>架构设计原则</li><li>设计模式</li><li>DDD</li><li>《DDIA》 ✅</li></ol>]]></content>
      
      
      <categories>
          
          <category> leaning-plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leaning-plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建记录</title>
      <link href="/hexo/"/>
      <url>/hexo/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm list --depth=0</span></span><br><span class="line">├── hexo-deployer-git@2.1.0</span><br><span class="line">├── hexo-filter-flowchart@1.0.4</span><br><span class="line">├── hexo-filter-github-emojis@3.0.4</span><br><span class="line">├── hexo-generator-archive@1.0.0</span><br><span class="line">├── hexo-generator-category@1.0.0</span><br><span class="line">├── hexo-generator-index@2.0.0</span><br><span class="line">├── hexo-generator-search@2.4.1</span><br><span class="line">├── hexo-generator-tag@1.0.0</span><br><span class="line">├── hexo-lazyload-image@1.0.9</span><br><span class="line">├── hexo-permalink-pinyin@1.1.0</span><br><span class="line">├── hexo-renderer-ejs@1.0.0</span><br><span class="line">├── hexo-renderer-marked@3.3.0</span><br><span class="line">├── hexo-renderer-stylus@2.0.1</span><br><span class="line">├── hexo-server@2.0.0</span><br><span class="line">├── hexo-tag-plantuml@1.0.0</span><br><span class="line">├── hexo-theme-landscape@0.0.3</span><br><span class="line">├── hexo-wordcount@6.0.1</span><br><span class="line">└── hexo@5.3.0</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>代码高亮, tomorrow night eighties:<br><a href="https://github.com/chriskempson/tomorrow-theme">https://github.com/chriskempson/tomorrow-theme</a></p><p>参考文章:</p><ol><li><a href="https://www.cnblogs.com/fanbi/p/7044587.html">通过使用CSS字体阴影效果解决hover图片时显示文字看不清的问题</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
